<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BALL SURVIVAL</title>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex; justify-content: center; align-items: center;
            min-height: 100vh; overflow: hidden; color: white;
        }
        body.mc-skin #gameContainer,
        body.mc-skin #levelUpNotice,
        body.mc-skin #gameOver { font-family: 'Press Start 2P', monospace; }

        :fullscreen body, :-webkit-full-screen body { min-height: 100vh; }
        :fullscreen #gameContainer, :-webkit-full-screen #gameContainer {
            transform-origin: center center;
        }
        #fsBtn {
            position: fixed; top: 10px; right: 10px; z-index: 9999;
            background: rgba(0,0,0,0.7); color: white; border: 2px solid rgba(59,130,246,0.5);
            padding: 8px 14px; border-radius: 6px; cursor: pointer; font-size: 18px;
            transition: background 0.2s;
        }
        #fsBtn:hover { background: rgba(59,130,246,0.3); }

        #loginScreen {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        #loginContainer {
            background: rgba(0,0,0,0.9);
            border-radius: 8px;
            padding: 60px;
            text-align: center;
            border: 3px solid rgba(59,130,246,0.5);
            box-shadow: 0 0 50px rgba(59,130,246,0.3);
            max-width: 400px;
            width: 90%;
        }
        #loginContainer h1 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #3b82f6;
            text-shadow: 3px 3px 0px #1e3a8a;
            font-weight: bold;
        }
        #loginForm, #registerForm {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        #loginForm input, #registerForm input {
            background: rgba(255,255,255,0.08);
            border: 2px solid rgba(255,255,255,0.2);
            color: white;
            padding: 12px 16px;
            border-radius: 6px;
            font-family: 'Arial', sans-serif;
            font-size: 13px;
            transition: all 0.2s;
        }
        #loginForm input:focus, #registerForm input:focus {
            outline: none;
            border-color: #3b82f6;
            background: rgba(59,130,246,0.15);
            box-shadow: 0 0 20px rgba(59,130,246,0.3);
        }
        #loginForm input::placeholder, #registerForm input::placeholder {
            color: rgba(255,255,255,0.4);
        }

        #mainMenu {
            background: rgba(0,0,0,0.9); border-radius: 8px; padding: 60px;
            text-align: center; border: 3px solid rgba(59,130,246,0.5);
            box-shadow: 0 0 50px rgba(59,130,246,0.3);
        }
        #mainMenu h1 { font-size: 48px; margin-bottom: 30px; color: #3b82f6; text-shadow: 3px 3px 0px #1e3a8a; font-weight: bold; }
        .menu-btn {
            background: #3b82f6; color: white; border: none; border-bottom: 4px solid #1d4ed8;
            padding: 16px 40px; font-size: 15px; font-family: 'Arial', sans-serif; font-weight: bold;
            border-radius: 6px; cursor: pointer; margin: 10px; transition: transform 0.1s; display: inline-block; min-width: 240px;
        }
        .menu-btn:hover { transform: translateY(-2px); background: #2563eb; }
        .menu-btn:active { transform: translateY(2px); border-bottom-width: 1px; }
        .currency-display { font-size: 20px; color: #fbbf24; margin: 20px 0; font-weight: bold; }
        #tutorial {
            display: none; background: rgba(0,0,0,0.95); border-radius: 8px;
            padding: 40px; max-width: 700px; border: 3px solid rgba(59,130,246,0.5);
        }
        #tutorial h2 { font-size: 26px; color: #3b82f6; margin-bottom: 20px; font-weight: bold; }
        .tutorial-section { margin: 20px 0; text-align: left; }
        .tutorial-section h3 { color: #fbbf24; margin-bottom: 10px; font-size: 15px; font-weight: bold; }
        .tutorial-section p { font-size: 13px; line-height: 2.2; }
        #characterShop {
            display: none; background: rgba(0,0,0,0.95); border-radius: 8px;
            padding: 40px; max-width: 1100px; border: 3px solid rgba(59,130,246,0.5);
            max-height: 90vh; overflow-y: auto; position: relative;
        }
        #charShopBackBtn {
            background: #3b82f6; color: white; border: none; border-bottom: 4px solid #1d4ed8;
            padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 13px;
            font-family: 'Arial', sans-serif; font-weight: bold;
            transition: transform 0.1s;
            position: fixed; bottom: 20px; right: 20px; z-index: 1001;
            display: inline-block;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            animation: slideInFromRight 0.3s ease-out;
            width: 100px;
            text-align: center;
            background: #3b82f6; border: none; border-bottom: 4px solid #1d4ed8;
            padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 13px;
            font-family: 'Arial', sans-serif; font-weight: bold;
            transition: transform 0.1s;
            position: fixed; bottom: 20px; right: 20px; z-index: 1001;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }
        #charShopBackBtn:hover { transform: translateY(-2px); background: #2563eb; }
        #charShopBackBtn:active { transform: translateY(2px); border-bottom-width: 1px; }
        #shopBackBtn {
            background: #3b82f6; color: white; border: none; border-bottom: 4px solid #1d4ed8;
            padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 13px;
            font-family: 'Arial', sans-serif; font-weight: bold;
            transition: transform 0.1s;
            position: fixed; bottom: 20px; right: 20px; z-index: 1001;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            animation: slideInFromRight 0.3s ease-out;
            width: auto;
            text-align: center;
        }
        #waveShop.show #shopBackBtn {
            display: inline-block;
        }
        #waveShop::-webkit-scrollbar-track { background: transparent; }
        #shopBackBtn:hover { transform: translateY(-2px); background: #2563eb; }
        #shopBackBtn:active { transform: translateY(2px); border-bottom-width: 1px; }
        #waveShopBackBtn {
            background: #3b82f6; color: white; border: none; border-bottom: 4px solid #1d4ed8;
            padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 13px;
            font-family: 'Arial', sans-serif; font-weight: bold;
            transition: transform 0.1s;
            position: fixed; bottom: 20px; right: 20px; z-index: 1001;
            display: inline-block;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            animation: slideInFromRight 0.3s ease-out;
        }
        #waveShopBackBtn:hover { transform: translateY(-2px); background: #2563eb; }
        #waveShopBackBtn:active { transform: translateY(2px); border-bottom-width: 1px; }
        @keyframes slideInFromRight {
            from { transform: translateX(100px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        #charShopBackBtn:hover { transform: translateY(-2px); background: #2563eb; }
        #charShopBackBtn:active { transform: translateY(2px); border-bottom-width: 1px; }
        #characterShop::-webkit-scrollbar { width: 8px; }
        #characterShop::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); border-radius: 4px; }
        #characterShop::-webkit-scrollbar-thumb { background: #3b82f6; border-radius: 4px; }
        #characterShop h2 { font-size: 28px; color: #3b82f6; margin-bottom: 30px; text-align: center; font-weight: bold; }
        .character-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 16px; margin-bottom: 30px; }
        .character-card:hover { transform: scale(1.04); border-color: #3b82f6; }
        .character-card.selected { border-color: #22c55e; box-shadow: 0 0 20px rgba(34,197,94,0.4); }
        .character-card.locked { opacity: 0.5; cursor: not-allowed; }
        .character-card.limited-card {
            border: 3px solid #00008b;
            box-shadow: 0 0 20px rgba(0,0,139,0.6), inset 0 0 15px rgba(0,0,139,0.2);
            animation: limitedGlow 2s ease-in-out infinite;
            position: relative;
            opacity: 0.5;
        }
        .character-card.limited-card.expired {
            border: 3px solid #7f1d1d;
            box-shadow: 0 0 20px rgba(127,29,29,0.6), inset 0 0 15px rgba(127,29,29,0.2);
            animation: expiredGlow 2s ease-in-out infinite;
            opacity: 0.5;
            cursor: not-allowed !important;
        }
        @keyframes limitedGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(0,0,139,0.6), inset 0 0 15px rgba(0,0,139,0.2); }
            50% { box-shadow: 0 0 30px rgba(0,0,139,0.8), inset 0 0 20px rgba(0,0,139,0.3); }
        }
        @keyframes expiredGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(127,29,29,0.6), inset 0 0 15px rgba(127,29,29,0.2); }
            50% { box-shadow: 0 0 30px rgba(127,29,29,0.8), inset 0 0 20px rgba(127,29,29,0.3); }
        }
        .character-card.limited-card::before {
            content: '‚è±Ô∏è LIMITED';
            position: absolute;
            top: 8px;
            left: 8px;
            background: linear-gradient(135deg, rgba(0,0,139,0.9), rgba(0,0,205,0.9));
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 9px;
            font-weight: bold;
            border: 1px solid #00008b;
            box-shadow: 0 0 10px rgba(0,0,139,0.6);
            letter-spacing: 0.5px;
        }
        .limited-timer {
            position: absolute;
            top: 30px;
            left: 8px;
            background: rgba(0,0,139,0.85);
            color: #fbbf24;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 8px;
            font-weight: bold;
            border: 1px solid #00008b;
            box-shadow: 0 0 8px rgba(251,191,36,0.5);
            white-space: nowrap;
            text-align: center;
        }
        .character-card.admin-card {
            background: linear-gradient(135deg, rgba(255,0,0,0.15), rgba(255,165,0,0.15), rgba(255,255,0,0.15), rgba(0,255,0,0.15), rgba(0,0,255,0.15), rgba(128,0,128,0.15));
            border: 3px solid transparent;
            background-clip: padding-box;
            position: relative;
            animation: adminGlow 2s linear infinite;
        }
        @keyframes adminGlow {
            0% { box-shadow: 0 0 20px #ff0000; }
            16% { box-shadow: 0 0 20px #ff8800; }
            33% { box-shadow: 0 0 20px #ffff00; }
            50% { box-shadow: 0 0 20px #00ff00; }
            66% { box-shadow: 0 0 20px #0088ff; }
            83% { box-shadow: 0 0 20px #8800ff; }
            100% { box-shadow: 0 0 20px #ff0000; }
        }
        .character-preview { width: 64px; height: 64px; margin: 0 auto 12px; border-radius: 8px; display: flex; align-items: center; justify-content: center; overflow: hidden; }
        .character-preview img { width: 64px; height: 64px; image-rendering: pixelated; border-radius: 4px; }
        .character-name { font-size: 14px; font-weight: bold; margin-bottom: 6px; }
        .character-ability { font-size: 11px; color: #fbbf24; margin-bottom: 8px; line-height: 1.8; }
        .character-price { font-size: 13px; color: #22c55e; font-weight: bold; }
        .admin-price { font-size: 11px; color: #ff6b6b; font-weight: bold; animation: rainbowText 2s linear infinite; }
        @keyframes rainbowText {
            0%{color:#ff0000}16%{color:#ff8800}33%{color:#ffff00}50%{color:#00ff00}66%{color:#0088ff}83%{color:#8800ff}100%{color:#ff0000}
        }

        #gameContainer {
            display: none; background: rgba(255,255,255,0.03); border-radius: 8px;
            padding: 16px; box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }
        canvas { background: #0f0f1e; border-radius: 2px; display: block; border: 3px solid rgba(100,200,255,0.25); max-width: 100%; }
        #hud { display: flex; gap: 8px; margin-top: 10px; }
        .stat-box { background: rgba(0,0,0,0.8); padding: 8px 12px; border-radius: 4px; flex: 1; border: 2px solid rgba(255,255,255,0.15); }
        .stat-label { font-size: 10px; opacity: 0.6; margin-bottom: 4px; font-weight: bold; text-transform: uppercase; }
        .stat-value { font-size: 14px; font-weight: bold; }
        body.mc-skin .stat-label { font-size: 6px; }
        body.mc-skin .stat-value { font-size: 10px; }
        body.mc-skin #rReady { font-size: 8px !important; }
        body.mc-skin #controls { font-size: 7px; }
        .progress-bar { background: rgba(0,0,0,0.5); height: 5px; overflow: hidden; margin-top: 4px; border: 1px solid rgba(255,255,255,0.15); }
        .progress-fill { height: 100%; transition: width 0.3s; }
        .health-bar { background: #ef4444; }
        .exp-bar { background: #3b82f6; }
        .mana-bar { background: #8b5cf6; }
        #levelUpNotice {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0);
            background: rgba(0,0,0,0.97); padding: 40px; border-radius: 8px; text-align: center;
            z-index: 1000; border: 4px solid #fbbf24; box-shadow: 0 0 50px rgba(251,191,36,0.4); transition: transform 0.2s;
            max-height: 90vh; overflow-y: auto;
        }
        #levelUpNotice.show { transform: translate(-50%, -50%) scale(1); }
        #levelUpNotice h2 { font-size: 32px; color: #fbbf24; margin-bottom: 20px; font-weight: bold; }
        body.mc-skin #levelUpNotice h2 { font-size: 22px; text-shadow: 3px 3px 0 #92400e; }
        body.mc-skin #levelUpNotice p { font-size: 9px; }
        .upgrade-btn {
            background: #3b82f6; color: white; border: none; border-bottom: 4px solid #1d4ed8;
            padding: 14px 20px; font-size: 14px; font-family: inherit; border-radius: 6px;
            cursor: pointer; margin: 6px; transition: transform 0.1s; display: block; width: 100%; font-weight: bold;
        }
        body.mc-skin .upgrade-btn { font-size: 9px; font-family: 'Press Start 2P', monospace; border-radius: 2px; }
        .upgrade-btn:hover { background: #2563eb; transform: translateY(-2px); }
        .upgrade-btn.disabled-upgrade {
            background: #374151; border-bottom-color: #1f2937; cursor: not-allowed; opacity: 0.5;
        }
        .upgrade-btn.disabled-upgrade:hover { transform: none; background: #374151; }
        #controls { text-align: center; margin-top: 8px; font-size: 12px; opacity: 0.5; }
        #gameOver {
            display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.97); padding: 40px; border-radius: 8px;
            text-align: center; z-index: 1000; border: 4px solid #ef4444;
        }
        #gameOver h2 { font-size: 40px; color: #ef4444; margin-bottom: 20px; font-weight: bold; }
        body.mc-skin #gameOver h2 { font-size: 28px; text-shadow: 3px 3px 0 #7f1d1d; }
        #gameOver p { font-size: 16px; margin: 10px 0; }
        body.mc-skin #gameOver p { font-size: 10px; }
        .restart-btn {
            background: #3b82f6; color: white; border: none; border-bottom: 4px solid #1d4ed8;
            padding: 12px 30px; font-size: 16px; font-family: inherit; font-weight: bold; border-radius: 6px; cursor: pointer; margin: 8px;
        }
        body.mc-skin .restart-btn { font-size: 11px; font-family: 'Press Start 2P', monospace; border-radius: 2px; }
        .restart-btn:hover { background: #2563eb; }
        #gameWrapper { position: relative; display: inline-block; }
        #playerSkinOverlay {
            position: absolute; display: none; pointer-events: none;
            image-rendering: pixelated; border-radius: 50%; z-index: 10;
        }
        #deathFeed {
            position: absolute; bottom: 8px; left: 50%; transform: translateX(-50%);
            pointer-events: none; z-index: 500;
            display: flex; flex-direction: column; align-items: center; gap: 3px; width: 1060px;
        }
        .death-msg {
            background: rgba(0,0,0,0.78); font-family: 'Press Start 2P', monospace;
            font-size: 8px; padding: 5px 12px; opacity: 1; transition: opacity 0.6s;
            white-space: nowrap; text-shadow: 1px 1px 0 #000; color: #fff;
        }
        .death-msg .victim { color: #ffff55; }
        .death-msg .killer { color: #55ffff; }

        #tutorialOverlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2500;
        }
        #tutorialPanel {
            background: rgba(15,23,42,0.98);
            border-radius: 10px;
            border: 3px solid rgba(59,130,246,0.8);
            padding: 24px 28px;
            max-width: 520px;
            width: 90%;
            box-shadow: 0 0 40px rgba(15,23,42,0.9);
            text-align: left;
        }
        #tutorialTitle {
            font-size: 22px;
            margin-bottom: 10px;
            color: #60a5fa;
            font-weight: bold;
        }
        #tutorialBody {
            font-size: 14px;
            line-height: 1.8;
            margin-bottom: 18px;
        }
        #tutorialHint {
            font-size: 12px;
            opacity: 0.7;
            margin-bottom: 14px;
        }
        #tutorialButtons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        .tutorial-btn {
            padding: 8px 16px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
        }
        .tutorial-btn.primary {
            background: #3b82f6;
            color: white;
        }
        .tutorial-btn.primary:hover {
            background: #2563eb;
        }
        .tutorial-btn.ghost {
            background: transparent;
            color: #e5e7eb;
            border: 1px solid rgba(148,163,184,0.7);
        }
        .tutorial-btn.ghost:hover {
            background: rgba(15,23,42,0.8);
        }
        .tutorial-highlight {
            position: relative;
            z-index: 2600;
            box-shadow: 0 0 0 3px rgba(250,204,21,0.9), 0 0 25px rgba(250,204,21,0.8);
            border-radius: 8px;
            transition: box-shadow 0.2s;
        }

        #moneyPopup {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%) scale(0);
            background: rgba(0,0,0,0.95); border: 3px solid #fbbf24; border-radius: 8px;
            padding: 30px 50px; text-align: center; z-index: 2000; transition: transform 0.2s;
        }
        #moneyPopup.show { transform: translate(-50%,-50%) scale(1); }
        #moneyPopup h3 { font-size: 22px; color: #fbbf24; margin-bottom: 10px; }
        #moneyPopup p { font-size: 14px; }

        #streakDisplay {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            font-family: 'Press Start 2P', monospace; font-size: 11px;
            color: #fbbf24; text-shadow: 0 0 10px #fbbf24;
            pointer-events: none; z-index: 500; opacity: 0; transition: opacity 0.3s;
        }

        #adminKeys {
            display: none; position: absolute; top: 4px; left: 4px;
            display: flex; gap: 3px; flex-wrap: wrap; max-width: 300px; pointer-events: none;
        }
        .admin-key {
            background: rgba(0,0,0,0.7); border: 1px solid; border-radius: 3px;
            font-size: 7px; padding: 2px 4px; font-family: 'Press Start 2P', monospace;
            text-align: center; min-width: 32px;
        }

        #waveShop {
            display: none; position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: rgba(5, 5, 20, 0.98);
            border: 4px solid #fbbf24;
            border-radius: 12px; padding: 30px 36px;
            z-index: 2000; text-align: center;
            box-shadow: 0 0 80px rgba(251,191,36,0.3), 0 0 40px rgba(0,0,0,0.8);
            min-width: 700px; max-width: 90vw;
            max-height: 90vh; overflow-y: auto;
            transition: transform 0.25s cubic-bezier(.34,1.56,.64,1);
        }
        #waveShop::-webkit-scrollbar { width: 6px; }
        #waveShop::-webkit-scrollbar-thumb { background: #fbbf24; border-radius: 3px; }
        #waveShop.show { transform: translate(-50%, -50%) scale(1); display: block; }
        #waveShop h2 { font-size: 26px; color: #fbbf24; margin-bottom: 4px; font-weight: bold; text-shadow: 0 0 20px rgba(251,191,36,0.6); }
        #waveShop .shop-subtitle { font-size: 12px; color: rgba(255,255,255,0.5); margin-bottom: 18px; }
        #waveShop .shop-gold { font-size: 18px; color: #fbbf24; margin-bottom: 20px; font-weight: bold; }
        .shop-section-label { font-size: 11px; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 2px; margin: 14px 0 10px; text-align: left; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 6px; }
        .shop-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(190px, 1fr)); gap: 12px; margin-bottom: 14px; }
        .shop-item {
            background: rgba(255,255,255,0.06); border: 2px solid rgba(255,255,255,0.15);
            border-radius: 8px; padding: 14px 12px; cursor: pointer; transition: all 0.18s;
            text-align: center; position: relative;
        }
        .shop-item:hover:not(.shop-item-owned):not(.shop-item-cantafford) { border-color: #fbbf24; background: rgba(251,191,36,0.12); transform: translateY(-2px); }
        .shop-item.shop-item-owned { border-color: #22c55e; background: rgba(34,197,94,0.1); cursor: default; }
        .shop-item.shop-item-cantafford { opacity: 0.4; cursor: not-allowed; }
        .shop-item.shop-item-maxed { border-color: #a855f7; background: rgba(168,85,247,0.1); cursor: default; }
        .shop-item-icon { font-size: 28px; margin-bottom: 8px; }
        .shop-item-name { font-size: 13px; font-weight: bold; margin-bottom: 4px; }
        .shop-item-desc { font-size: 10px; color: rgba(255,255,255,0.55); line-height: 1.7; margin-bottom: 8px; }
        .shop-item-cost { font-size: 12px; font-weight: bold; }
        .shop-item-cost.free { color: #22c55e; }
        .shop-item-cost.cheap { color: #86efac; }
        .shop-item-cost.mid { color: #fbbf24; }
        .shop-item-cost.pricey { color: #f97316; }
        .shop-item-cost.expensive { color: #ef4444; }
        .shop-item-tier { position: absolute; top: 6px; right: 8px; font-size: 9px; opacity: 0.6; }
        .shop-item-stack { position: absolute; top: 6px; left: 8px; font-size: 9px; color: #a855f7; font-weight: bold; }
        .shop-skip-btn {
            background: rgba(255,255,255,0.08); color: rgba(255,255,255,0.5);
            border: 2px solid rgba(255,255,255,0.15); padding: 10px 30px;
            border-radius: 6px; cursor: pointer; font-size: 13px; font-family: inherit;
            margin-top: 10px; transition: all 0.15s;
        }
        .shop-skip-btn:hover { background: rgba(255,255,255,0.14); color: white; }
        .shop-reroll-btn {
            background: rgba(59,130,246,0.2); color: #93c5fd;
            border: 2px solid rgba(59,130,246,0.4); padding: 10px 20px;
            border-radius: 6px; cursor: pointer; font-size: 13px; font-family: inherit;
            margin-top: 10px; margin-right: 8px; transition: all 0.15s;
        }
        .shop-reroll-btn:hover { background: rgba(59,130,246,0.35); }
        .shop-reroll-btn:disabled { opacity: 0.35; cursor: not-allowed; }

        #settingsMenu {
            display: none; background: rgba(0,0,0,0.95); border-radius: 8px;
            padding: 40px; max-width: 680px; width: 90vw;
            border: 3px solid rgba(59,130,246,0.5);
            max-height: 90vh; overflow-y: auto;
        }
        #settingsMenu::-webkit-scrollbar { width: 6px; }
        #settingsMenu::-webkit-scrollbar-thumb { background: #3b82f6; border-radius: 3px; }
        #settingsMenu h2 { font-size: 26px; color: #3b82f6; margin-bottom: 24px; font-weight: bold; }
        .settings-section { margin-bottom: 28px; }
        .settings-section h3 { color: #fbbf24; font-size: 13px; font-weight: bold; margin-bottom: 14px; text-transform: uppercase; letter-spacing: 1px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 6px; }
        .keybind-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; }
        .keybind-label { font-size: 13px; color: rgba(255,255,255,0.8); }
        .keybind-btn {
            background: rgba(255,255,255,0.08); border: 2px solid rgba(255,255,255,0.25);
            color: white; padding: 6px 16px; border-radius: 5px; cursor: pointer;
            font-size: 12px; font-family: 'Press Start 2P', monospace; min-width: 90px;
            text-align: center; transition: all 0.15s;
        }
        .keybind-btn:hover { border-color: #3b82f6; background: rgba(59,130,246,0.15); }
        .keybind-btn.listening { border-color: #fbbf24; background: rgba(251,191,36,0.15); color: #fbbf24; animation: kbPulse 0.7s ease-in-out infinite; }
        @keyframes kbPulse { 0%,100%{opacity:1} 50%{opacity:0.5} }
        .settings-toggle-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; }
        .settings-toggle-label { font-size: 13px; }
        .toggle-switch { position: relative; width: 44px; height: 24px; cursor: pointer; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .toggle-slider { position: absolute; inset: 0; background: #374151; border-radius: 24px; transition: background 0.2s; }
        .toggle-slider:before { content:''; position:absolute; height:18px; width:18px; left:3px; bottom:3px; background:white; border-radius:50%; transition:transform 0.2s; }
        .toggle-switch input:checked + .toggle-slider { background: #3b82f6; }
        .toggle-switch input:checked + .toggle-slider:before { transform: translateX(20px); }
        .slider-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; gap: 14px; }
        .slider-row label { font-size: 13px; white-space: nowrap; min-width: 120px; }
        .slider-row input[type=range] { flex: 1; accent-color: #3b82f6; }
        .slider-row span { font-size: 12px; color: #fbbf24; min-width: 36px; text-align: right; }
        .settings-reset-btn {
            background: rgba(239,68,68,0.15); color: #ef4444; border: 2px solid rgba(239,68,68,0.3);
            padding: 8px 20px; border-radius: 5px; cursor: pointer; font-size: 12px; font-family: inherit;
            margin-right: 8px; transition: all 0.15s;
        }
        .settings-reset-btn:hover { background: rgba(239,68,68,0.3); }

        .info-btn {
            display: block; width: calc(100% - 16px); margin: 6px 8px 8px;
            background: rgba(255,255,255,0.07); color: rgba(255,255,255,0.7);
            border: 1px solid rgba(255,255,255,0.2); border-radius: 5px;
            padding: 5px 0; font-size: 10px; font-family: inherit; cursor: pointer;
            transition: all 0.15s; letter-spacing: 0.05em;
        }
        .info-btn:hover { background: rgba(59,130,246,0.25); color: white; border-color: #3b82f6; }
        #infoModal {
            display: none; position: fixed; inset: 0; z-index: 5000;
            background: rgba(0,0,0,0.82); backdrop-filter: blur(6px);
            justify-content: center; align-items: center;
        }
        #infoModal.open { display: flex; animation: fadeInBlur 0.3s ease-out; }
        @keyframes fadeInBlur {
            from { background: rgba(0,0,0,0); backdrop-filter: blur(0px); }
            to { background: rgba(0,0,0,0.82); backdrop-filter: blur(6px); }
        }
        #infoBox {
            animation: popBounce 0.9s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }
        @keyframes popBounce {
            0% {
                transform: scale(0) rotateZ(-15deg);
                opacity: 0;
            }
            15% {
                transform: scale(1.15) rotateZ(8deg);
                opacity: 1;
            }
            30% {
                transform: scale(0.95) rotateZ(-3deg);
                opacity: 1;
            }
            50% {
                transform: scale(1.08) rotateZ(2deg);
                opacity: 1;
            }
            65% {
                transform: scale(0.98) rotateZ(-1deg);
                opacity: 1;
            }
            80% {
                transform: scale(1.02) rotateZ(0.5deg);
                opacity: 1;
            }
            100% {
                transform: scale(1) rotateZ(0deg);
                opacity: 1;
            }
        }
        #infoBox {
            background: rgba(10,12,28,0.98); border-radius: 12px;
            padding: 36px 40px; max-width: 520px; width: 90%;
            border: 2px solid rgba(255,255,255,0.15);
            box-shadow: 0 0 60px rgba(0,0,0,0.9);
            position: relative;
        }
        #infoBox .info-header {
            display: flex; align-items: center; gap: 16px; margin-bottom: 22px;
        }
        #infoBox .info-icon {
            width: 54px; height: 54px; border-radius: 8px; flex-shrink: 0;
            display: flex; align-items: center; justify-content: center; font-size: 28px;
        }
        #infoBox h3 { font-size: 20px; font-weight: bold; margin-bottom: 2px; }
        #infoBox .info-tag {
            font-size: 10px; opacity: 0.5; letter-spacing: 0.1em; text-transform: uppercase;
        }
        #infoBox .info-section { margin-bottom: 16px; }
        #infoBox .info-section-title {
            font-size: 10px; text-transform: uppercase; letter-spacing: 0.12em;
            opacity: 0.5; margin-bottom: 7px; border-bottom: 1px solid rgba(255,255,255,0.08);
            padding-bottom: 4px;
        }
        #infoBox .info-row {
            display: flex; justify-content: space-between; align-items: center;
            font-size: 12px; margin-bottom: 5px;
        }
        #infoBox .info-row .label { opacity: 0.6; }
        #infoBox .info-row .value { font-weight: bold; }
        #infoBox .info-desc {
            font-size: 12px; line-height: 1.7; opacity: 0.8;
        }
        #infoBox .info-tip {
            margin-top: 14px; font-size: 11px; padding: 10px 14px;
            background: rgba(255,255,255,0.05); border-radius: 6px;
            border-left: 3px solid #3b82f6; opacity: 0.85; line-height: 1.6;
        }
        #infoBox .close-info {
            position: absolute; top: 14px; right: 16px;
            background: none; border: none; color: rgba(255,255,255,0.4);
            font-size: 20px; cursor: pointer; line-height: 1;
        }
        #infoBox .close-info:hover { color: white; }

        #pauseMenu {
            display: none; position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.97); border-radius: 10px; padding: 44px 60px;
            text-align: center; z-index: 3000;
            border: 3px solid rgba(59,130,246,0.5);
            box-shadow: 0 0 60px rgba(0,0,0,0.8);
            min-width: 320px;
        }
        #pauseMenu h2 { font-size: 32px; color: #3b82f6; margin-bottom: 8px; font-weight: bold; }
        #pauseMenu .pause-sub { font-size: 11px; color: rgba(255,255,255,0.4); margin-bottom: 28px; }
        .pause-btn {
            display: block; width: 100%; background: rgba(255,255,255,0.07);
            border: 2px solid rgba(255,255,255,0.15); color: white;
            padding: 13px 20px; font-size: 14px; font-family: inherit; font-weight: bold;
            border-radius: 6px; cursor: pointer; margin-bottom: 10px; transition: all 0.15s;
            text-align: left;
        }
        .pause-btn:hover { background: rgba(59,130,246,0.2); border-color: #3b82f6; }
        .pause-btn.danger { border-color: rgba(239,68,68,0.3); }
        .pause-btn.danger:hover { background: rgba(239,68,68,0.15); border-color: #ef4444; }
        #pauseOverlay {
            display: none; position: fixed; inset: 0;
            background: rgba(0,0,0,0.55); z-index: 2999;
            backdrop-filter: blur(3px);
        }
        #statsPanel {
            display: none; position: fixed; bottom: 20px; right: 20px;
            background: rgba(0,0,0,0.95); border: 3px solid #3b82f6;
            border-radius: 8px; padding: 20px; color: white;
            font-family: 'Arial', sans-serif; z-index: 999;
            min-width: 280px; box-shadow: 0 0 40px rgba(59,130,246,0.3);
        }
        #statsPanel.show { display: block; }
        #statsPanel h3 { color: #3b82f6; margin-bottom: 15px; font-size: 18px; text-shadow: 0 0 10px rgba(59,130,246,0.5); }
        .stat-row { display: flex; justify-content: space-between; margin: 8px 0; font-size: 13px; padding: 5px 0; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .stat-label { color: #a0aec0; font-weight: bold; }
        .stat-value { color: #4ade80; font-weight: bold; }
        #biomeIndicator { position: fixed; top: 80px; right: 20px; background: rgba(0,0,0,0.8); border: 2px solid #fbbf24; border-radius: 6px; padding: 12px 16px; color: white; font-size: 13px; z-index: 100; }
        #biomeIndicator .biome-name { color: #fbbf24; font-weight: bold; margin-bottom: 4px; }
        #biomeIndicator .biome-effect { color: rgba(255,255,255,0.7); font-size: 11px; }
    </style>
</head>
<body>

<button id="fsBtn" onclick="toggleFullscreen()" title="Fullscreen">‚õ∂</button>



<div id="mainMenu">
    <p style="font-family: 'Press Start 2P', monospace; font-size: 14px; color: #fbbf24; margin: 0 0 15px 0; opacity: 0.7;">The First Limited (Will Be Gone Next Friday)</p>
    <h1>‚öîÔ∏è BALL SURVIVAL ‚öîÔ∏è</h1>
    <div class="currency-display">üí∞ $<span id="totalMoney">0</span></div>
    <button class="menu-btn" onclick="showTutorial()">üìñ Tutorial</button>
    <button class="menu-btn" onclick="showCharacterShop()">Characters</button>
    <button class="menu-btn" onclick="startGame()">‚ñ∂Ô∏è Play Game</button>
    <button class="menu-btn" onclick="showSettings(false)" style="background:#6b7280;border-bottom-color:#374151;">‚öôÔ∏è Settings</button>
    <div style="margin-top: 20px; display: flex; gap: 8px; justify-content: center;">
        <input type="text" id="codeInput" placeholder="Enter code..." style="padding: 8px 12px; border: 2px solid #fbbf24; background: #1a1a1a; color: #fbbf24; font-family: monospace; border-radius: 4px; width: 150px;">
        <button class="menu-btn" onclick="submitCode()" style="padding: 8px 16px; font-size: 14px; border-bottom: 3px solid #ca8a04; margin: 0;">Submit</button>
    </div>
</div>

<div id="tutorial" style="display:none;"></div>

<div id="characterShop">
    <h2>CHARACTER SHOP</h2>
    <div class="currency-display">üí∞ $<span id="shopMoney">0</span></div>
    <div class="character-grid">
        <div class="character-card selected" onclick="selectCharacter('default')">
            <div class="character-preview" style="background:#3b82f6;box-shadow:0 0 20px rgba(59,130,246,.8);"></div>
            <div class="character-name">The Veteran</div>
            <div class="character-ability">Evolves every 30s!<br>R: Adaptive Strike<br>changes with each tier</div>
            <div class="character-price">FREE</div>
            <button class="info-btn" onclick="event.stopPropagation();showCharInfo('default')">INFO</button>
        </div>
        <div class="character-card" onclick="selectCharacter('goldhoarder')" id="goldhoarderCharacter">
            <div class="character-preview" style="background:linear-gradient(135deg,#ca8a04,#713f12);box-shadow:0 0 20px rgba(234,179,8,.9);"></div>
            <div class="character-name">Gold Hoarder</div>
            <div class="character-ability">5x GOLD from everything!<br>R: Gold Rush ‚Äî converts<br>enemies to coins<br>Terrible at combat</div>
            <div class="character-price">FREE</div>
            <button class="info-btn" onclick="event.stopPropagation();showCharInfo('goldhoarder')">INFO</button>
        </div>
        <div class="character-card" onclick="selectCharacter('vampire')" id="vampireCharacter">
            <div class="character-preview" style="background:linear-gradient(135deg,#7f1d1d,#450a0a);box-shadow:0 0 20px rgba(185,28,28,.8);"></div>
            <div class="character-name">Vampire</div>
            <div class="character-ability">PASSIVE: Heal 8 HP<br>on every kill<br>No special ability</div>
            <div class="character-price">$100</div>
            <button class="info-btn" onclick="event.stopPropagation();showCharInfo('vampire')">INFO</button>
        </div>
        <div class="character-card" onclick="selectCharacter('builder')" id="builderCharacter">
            <div class="character-preview" style="background:linear-gradient(135deg,#8b5a2b,#d2691e);box-shadow:0 0 20px rgba(160,82,45,.9);"></div>
            <div class="character-name">The Builder</div>
            <div class="character-ability">E: Move nearby walls!<br>Shift+Click: Build new<br>walls for defense<br>R: Reinforce ‚Äî strengthen walls</div>
            <div class="character-price">$100</div>
            <button class="info-btn" onclick="event.stopPropagation();showCharInfo('builder')">INFO</button>
        </div>
        <div class="character-card" onclick="selectCharacter('phantom')" id="phantomCharacter">
            <div class="character-preview" style="background:linear-gradient(135deg,#0ea5e9,#1e1b4b);box-shadow:0 0 22px rgba(125,211,252,.8);"></div>
            <div class="character-name">Phantom</div>
            <div class="character-ability">PASSIVE: Ethereal shots<br>pierce through walls!<br>R: Ghost Walk ‚Äî phase<br>through walls + speed</div>
            <div class="character-price">$250</div>
            <button class="info-btn" onclick="event.stopPropagation();showCharInfo('phantom')">INFO</button>
        </div>
        <div class="character-card" onclick="selectCharacter('boxer')" id="boxerCharacter">
            <div class="character-preview" style="background:linear-gradient(135deg,#dc2626,#7f1d1d);box-shadow:0 0 20px rgba(220,38,38,.9);"></div>
            <div class="character-name">Boxer</div>
            <div class="character-ability">High damage up close!<br>R: Power Dash ‚Äî dash<br>into enemies with damage</div>
            <div class="character-price">$500</div>
            <button class="info-btn" onclick="event.stopPropagation();showCharInfo('boxer')">INFO</button>
        </div>
        <div class="character-card" onclick="selectCharacter('fire')" id="fireCharacter">
            <div class="character-preview" style="background:linear-gradient(135deg,#ff4500,#7f1d1d);box-shadow:0 0 20px rgba(255,69,0,.9);"></div>
            <div class="character-name">Fire Ball</div>
            <div class="character-ability">Shots leave BURNING<br>ground! R: Inferno ‚Äî<br>ignites all enemies</div>
            <div class="character-price">$500</div>
            <button class="info-btn" onclick="event.stopPropagation();showCharInfo('fire')">INFO</button>
        </div>
        <div class="character-card" onclick="selectCharacter('druid')" id="druidCharacter">
            <div class="character-preview" style="background:linear-gradient(135deg,#15803d,#052e16);box-shadow:0 0 22px rgba(74,222,128,.8);"></div>
            <div class="character-name">Druid</div>
            <div class="character-ability">Shots ROOT enemies<br>in place for 1.5s!<br>R: Heal Mushrooms ‚Äî<br>spawn HP recovery pods</div>
            <div class="character-price">$750</div>
            <button class="info-btn" onclick="event.stopPropagation();showCharInfo('druid')">INFO</button>
        </div>
        <div class="character-card" onclick="selectCharacter('ice')" id="iceCharacter">
            <div class="character-preview" style="background:linear-gradient(135deg,#e0f7ff,#06b6d4);box-shadow:0 0 20px rgba(103,232,249,.9);"></div>
            <div class="character-name">Ice Ball</div>
            <div class="character-ability">Fast pierce shots!<br>SHATTER frozen enemies<br>R: Blizzard ‚Äî freeze+slow</div>
            <div class="character-price">$1000</div>
            <button class="info-btn" onclick="event.stopPropagation();showCharInfo('ice')">INFO</button>
        </div>
        <div class="character-card" onclick="selectCharacter('pyromancer')" id="pyromancerCharacter">
            <div class="character-preview" style="background:linear-gradient(135deg,#c2410c,#431407);box-shadow:0 0 22px rgba(251,146,60,.9);"></div>
            <div class="character-name">Pyromancer</div>
            <div class="character-ability">Hold FIRE to charge<br>bigger shots! More<br>charge = more dmg!<br>R: Meteor Strike</div>
            <div class="character-price">$1500</div>
            <button class="info-btn" onclick="event.stopPropagation();showCharInfo('pyromancer')">INFO</button>
        </div>
        <div class="character-card" onclick="selectCharacter('electric')" id="electricCharacter">
            <div class="character-preview" style="background:linear-gradient(135deg,#facc15,#7c3aed);box-shadow:0 0 20px rgba(168,85,247,.9);"></div>
            <div class="character-name">Tesla</div>
            <div class="character-ability">Shots auto-chain to<br>nearby enemies!<br>R: Overload ‚Äî next 8<br>shots hit EVERYTHING</div>
            <div class="character-price">$2500</div>
            <button class="info-btn" onclick="event.stopPropagation();showCharInfo('electric')">INFO</button>
        </div>
        <div class="character-card" onclick="selectCharacter('cyborg')" id="cyborgCharacter">
            <div class="character-preview" style="background:linear-gradient(135deg,#0ea5e9,#4c1d95);box-shadow:0 0 22px rgba(14,165,233,.9);"></div>
            <div class="character-name">Cyborg</div>
            <div class="character-ability">E: Toggle RAPID mode<br>(fast weak) vs HEAVY<br>(slow powerful)<br>R: 360¬∞ Laser Sweep</div>
            <div class="character-price">$3000</div>
            <button class="info-btn" onclick="event.stopPropagation();showCharInfo('cyborg')">INFO</button>
        </div>
        <div class="character-card" onclick="selectCharacter('timewizard')" id="timewizardCharacter">
            <div class="character-preview" style="background:linear-gradient(135deg,#7c3aed,#1e1b4b);box-shadow:0 0 22px rgba(216,180,254,.9);"></div>
            <div class="character-name">Time Wizard</div>
            <div class="character-ability">PASSIVE: Every shot<br>echoes ‚Äî hits twice!<br>R: Rewind ‚Äî restore HP<br>to 5s ago (5s CD)</div>
            <div class="character-price">$4500</div>
            <button class="info-btn" onclick="event.stopPropagation();showCharInfo('timewizard')">INFO</button>
        </div>
        <div class="character-card" onclick="selectCharacter('wemmbu')" id="wemmbuCharacter">
            <div class="character-preview">
                <img src="https://minotar.net/helm/8af6c50833d54861b5c2dce1c16c6fae/512.png" width="64" height="64" referrerpolicy="no-referrer" onerror="this.style.display='none';this.parentNode.style.background='#a855f7'" style="object-fit:cover;border-radius:4px;" />
            </div>
            <div class="character-name">Wemmbu</div>
            <div class="character-ability">R: INSTANT Slam<br>35 mana ‚Ä¢ 3s CD</div>
            <div class="character-price">$5000</div>
            <button class="info-btn" onclick="event.stopPropagation();showCharInfo('wemmbu')">INFO</button>
        </div>
        <div class="character-card" onclick="selectCharacter('eggchan')" id="eggchanCharacter">
            <div class="character-preview">
                <img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSU8qswuWvs5n8CSTMft-2QFR9Y54APiJ3q1g&s" width="64" height="64" referrerpolicy="no-referrer" onerror="this.style.display='none';this.parentNode.style.background='#f9a8d4'" style="object-fit:cover;border-radius:4px;" />
            </div>
            <div class="character-name">Eggchan</div>
            <div class="character-ability">R: MC Bow Shot<br>1 mana ‚Ä¢ spammable</div>
            <div class="character-price">$5000</div>
            <button class="info-btn" onclick="event.stopPropagation();showCharInfo('eggchan')">INFO</button>
        </div>
        <div class="character-card" onclick="selectCharacter('dream')" id="dreamCharacter">
            <div class="character-preview">
                <img src="https://www.reddit.com/media?url=https%3A%2F%2Fpreview.redd.it%2For0519g00aj51.jpg%3Fwidth%3D256%26format%3Dpjpg%26auto%3Dwebp%26s%3De6698fcbd023cb5aa3cef7b634b795d218e0e564" width="64" height="64" referrerpolicy="no-referrer" onerror="this.style.display='none';this.parentNode.style.background='#22c55e'" style="object-fit:cover;border-radius:4px;" />
            </div>
            <div class="character-name">Dream</div>
            <div class="character-ability">PASSIVE: Kill to<br>earn better armor!<br>Leather‚ÜíNetherite</div>
            <div class="character-price">$5000</div>
            <button class="info-btn" onclick="event.stopPropagation();showCharInfo('dream')">INFO</button>
        </div>
        <div class="character-card" onclick="selectCharacter('technoblade')" id="technobladeCharacter">
            <div class="character-preview">
                <img src="https://static.wikia.nocookie.net/qsmp/images/d/d7/Techno.Icon.png/revision/latest/scale-to-width-down/250?cb=20230607213749" width="64" height="64" referrerpolicy="no-referrer" onerror="this.style.display='none';this.parentNode.style.background='#7c3aed'" style="object-fit:cover;border-radius:4px;" />
            </div>
            <div class="character-name">Technoblade</div>
            <div class="character-ability">R: BLOOD FOR THE<br>BLOOD GOD ‚Äî kills ALL<br>150 mana + armor passive</div>
            <div class="character-price">$50000</div>
            <button class="info-btn" onclick="event.stopPropagation();showCharInfo('technoblade')">INFO</button>
        </div>
        <div class="character-card" onclick="selectCharacter('admin')" id="adminCharacter">
            <div class="character-preview" style="background:linear-gradient(135deg,#7c3aed,#1e1b4b);box-shadow:0 0 20px rgba(124,58,237,.8);"></div>
            <div class="character-name">THE ADMIN</div>
            <div class="character-ability">1-9: ALL abilities!<br>ALL passives active!<br>Rainbow power!</div>
            <div class="character-price">$1,000,000,000</div>
            <button class="info-btn" onclick="event.stopPropagation();showCharInfo('admin')">INFO</button>
        </div>
        <div class="character-card limited-card" onclick="selectCharacter('dice')" id="diceCharacter">
            <div class="character-preview" style="background:linear-gradient(135deg,#f97316,#ea580c);box-shadow:0 0 20px rgba(249,115,22,.9);"></div>
            <div class="character-name">Dice</div>
            <div class="character-ability">Random damage (10-150)!<br>Random stats each run!<br>R: Random Special ability</div>
            <div class="character-price">$2345</div>
            <div class="limited-timer" id="diceTimer"></div>
            <button class="info-btn" onclick="event.stopPropagation();showCharInfo('dice')">INFO</button>
        </div>
        <div class="character-card limited-card" onclick="selectCharacter('hakari_v2')" id="hakariCharacter">
            <div class="character-preview" style="background:linear-gradient(135deg,#ec4899,#7c3aed);box-shadow:0 0 20px rgba(236,72,153,.9);"></div>
            <div class="character-name">Hakari</div>
            <div class="character-ability">R: Domain Expansion<br>0 mana ‚Ä¢ Safe zone<br>Roll for JACKPOT ‚Üí 4:11 immortality</div>
            <div class="character-price">$35000</div>
            <div class="limited-timer" id="hakariTimer"></div>
            <button class="info-btn" onclick="event.stopPropagation();showCharInfo('hakari_v2')">INFO</button>
        </div>
        <div class="character-card limited-card" onclick="selectCharacter('yuji_itadori')" id="yujiCharacter">
            <div class="character-preview" style="background:linear-gradient(135deg,#e84d4d,#7f1d1d);box-shadow:0 0 20px rgba(232,77,77,.9);"></div>
            <div class="character-name">Yuji Itadori</div>
            <div class="character-ability">Enemies drop Sukuna Fingers<br>At 20 fingers ‚Üí Transform to Sukuna<br>R: Malevolent Shrine</div>
            <div class="character-price">$28000</div>
            <div class="limited-timer" id="yujiTimer"></div>
            <button class="info-btn" onclick="event.stopPropagation();showCharInfo('yuji_itadori')">INFO</button>
        </div>
        <div class="character-card limited-card" onclick="selectCharacter('toji')" id="tojiCharacter">
            <div class="character-preview" style="background:linear-gradient(135deg,#6b4423,#3d2817);box-shadow:0 0 20px rgba(107,68,35,.9);"></div>
            <div class="character-name">Toji Fushiguro</div>
            <div class="character-ability">R: Tool Swap<br>Switch between weapons for<br>increased damage & speed</div>
            <div class="character-price">$20000</div>
            <div class="limited-timer" id="tojiTimer"></div>
            <button class="info-btn" onclick="event.stopPropagation();showCharInfo('toji')">INFO</button>
        </div>
    </div>
    <div style="text-align: center; margin-top: 20px;">
        <button id="charShopBackBtn" onclick="backToMenu()">‚Üê Back</button>
    </div>
</div>


<div id="infoModal" onclick="if(event.target===this)closeCharInfo()">
    <div id="infoBox">
        <button class="close-info" onclick="closeCharInfo()">‚úï</button>
        <div class="info-header">
            <div class="info-icon" id="infoIcon"></div>
            <div>
                <h3 id="infoName"></h3>
                <div class="info-tag" id="infoTag"></div>
            </div>
        </div>
        <div class="info-section">
            <div class="info-section-title">Stats</div>
            <div id="infoStats"></div>
        </div>
        <div class="info-section">
            <div class="info-section-title">Abilities</div>
            <div class="info-desc" id="infoAbilities"></div>
        </div>
        <div class="info-section">
            <div class="info-section-title">Playstyle</div>
            <div class="info-desc" id="infoPlaystyle"></div>
        </div>
        <div class="info-tip" id="infoTip"></div>
    </div>
</div>

<div id="gameContainer">
    <div id="gameWrapper">
        <canvas id="gameCanvas" width="1100" height="700"></canvas>
        <img id="playerSkinOverlay" width="40" height="40" referrerpolicy="no-referrer" alt="" />
        <div id="deathFeed"></div>
        <div id="adminKeys"></div>
    </div>
    <div id="bossHealthBar" style="display:none;position:absolute;top:10px;left:50%;transform:translateX(-50%);width:400px;background:rgba(0,0,0,0.8);border:3px solid #dc2626;border-radius:8px;padding:8px;z-index:100;">
        <div style="color:#fbbf24;font-weight:bold;font-size:14px;margin-bottom:4px;">üëπ THE FIRST TRIANGLE</div>
        <div style="background:rgba(0,0,0,0.5);border-radius:4px;height:20px;overflow:hidden;border:1px solid #dc2626;">
            <div id="bossHealthFill" style="background:linear-gradient(90deg,#ef4444,#dc2626);height:100%;width:100%;transition:width 0.1s;"></div>
        </div>
        <div style="color:#fca5a5;font-size:11px;margin-top:4px;text-align:center;" id="bossHealthText">1000/1000</div>
    </div>
    <div id="hud">
        <div class="stat-box"><div class="stat-label">LEVEL</div><div class="stat-value" id="level">1</div></div>
        <div class="stat-box" style="flex:2;">
            <div class="stat-label">HEALTH</div><div class="stat-value" id="health">100/100</div>
            <div class="progress-bar"><div class="progress-fill health-bar" id="healthBar" style="width:100%"></div></div>
        </div>
        <div class="stat-box" style="flex:2;">
            <div class="stat-label">MANA</div><div class="stat-value" id="mana">50/50</div>
            <div class="progress-bar"><div class="progress-fill mana-bar" id="manaBar" style="width:100%"></div></div>
        </div>
        <div class="stat-box" style="flex:2;">
            <div class="stat-label">EXP</div><div class="stat-value" id="exp">0/100</div>
            <div class="progress-bar"><div class="progress-fill exp-bar" id="expBar" style="width:0%"></div></div>
        </div>
        <div class="stat-box"><div class="stat-label">KILLS</div><div class="stat-value" id="kills">0</div></div>
        <div class="stat-box">
            <div class="stat-label" id="rLabel">R KEY</div>
            <div class="stat-value" id="rReady" style="font-size:8px;color:#22c55e;">READY</div>
            <div class="progress-bar" id="armorBar" style="display:none;">
                <div id="armorBarFill" style="height:100%;width:0%;transition:width 0.4s,background 0.4s;background:#22c55e;"></div>
            </div>
        </div>
        <div class="stat-box"><div class="stat-label">GOLD</div><div class="stat-value" id="hudMoney" style="color:#fbbf24;">0</div></div>
    </div>
    <div id="controls">WASD: Move | SPACE: Dash | Click: Shoot | R: Special | F11: Fullscreen | Shop opens every 25 waves!</div>
    <div id="statsPanel">
        <h3>üìä STATS (Press TAB to hide)</h3>
        <div class="stat-row"><div class="stat-label">Biome:</div><div class="stat-value" id="statBiome">üå≤ Forest</div></div>
        <div class="stat-row"><div class="stat-label">Effect:</div><div class="stat-value" id="statBiomeEffect">Normal</div></div>
        <div class="stat-row"><div class="stat-label">Health:</div><div class="stat-value" id="statHealth">100/100</div></div>
        <div class="stat-row"><div class="stat-label">Damage:</div><div class="stat-value" id="statDamage">20</div></div>
        <div class="stat-row"><div class="stat-label">Speed:</div><div class="stat-value" id="statSpeed">5</div></div>
        <div class="stat-row"><div class="stat-label">Level:</div><div class="stat-value" id="statLevel">1</div></div>
        <div class="stat-row"><div class="stat-label">Kills:</div><div class="stat-value" id="statKills">0</div></div>
        <div class="stat-row"><div class="stat-label">Wave:</div><div class="stat-value" id="statWave">0</div></div>
        <div class="stat-row"><div class="stat-label">Armor Reduction:</div><div class="stat-value" id="statArmor">0%</div></div>
        <div class="stat-row"><div class="stat-label">Lifesteal:</div><div class="stat-value" id="statLifesteal">0%</div></div>
    </div>
    <div id="biomeIndicator" style="display:none;">
        <div class="biome-name" id="biomeName">üå≤ Forest</div>
        <div class="biome-effect" id="biomeEffect">Normal conditions</div>
    </div>
</div>

<div id="tutorialOverlay">
    <div id="tutorialPanel">
        <div id="tutorialTitle"></div>
        <div id="tutorialBody"></div>
        <div id="tutorialHint"></div>
        <div id="tutorialButtons">
            <button class="tutorial-btn ghost" onclick="skipTutorial()">Skip tutorial</button>
            <button class="tutorial-btn primary" onclick="nextTutorialStep()">Next</button>
        </div>
    </div>
</div>

<div id="levelUpNotice">
    <h2>LEVEL UP!</h2>
    <p style="font-size:9px;margin-bottom:18px;">Choose an upgrade:</p>
    <button class="upgrade-btn" onclick="upgrade('health')">‚ù§Ô∏è +30 Max Health</button>
    <button class="upgrade-btn" id="damageUpgradeBtn" onclick="upgrade('damage')">‚öîÔ∏è +5 Damage</button>
    <button class="upgrade-btn" onclick="upgrade('speed')">üí® +1 Speed</button>
    <button class="upgrade-btn" onclick="upgrade('mana')">üíß +20 Max Mana</button>
</div>

<div id="gameOver">
    <h2>GAME OVER</h2>
    <p>Level: <span id="finalLevel">1</span></p>
    <p>Kills: <span id="finalKills">0</span></p>
    <p>Wave: <span id="finalWave">0</span></p>
    <p style="color:#fbbf24;margin-top:10px;">üí∞ Earned: $<span id="moneyEarned">0</span></p>
    <button class="restart-btn" onclick="restartGame()">Play Again</button>
    <button class="restart-btn" onclick="backToMainMenu()" style="background:#6b7280;border-bottom:4px solid #374151;">Main Menu</button>
</div>

<div id="moneyPopup">
    <h3 id="popupTitle">üí∞ Bonus!</h3>
    <p id="popupMsg"></p>
    <button class="menu-btn" onclick="closeMoneyPopup()" style="margin-top:14px;min-width:120px;padding:10px;">OK!</button>
</div>

<div id="streakDisplay"></div>

<div id="waveShop">
    <h2>üõí WAVE SHOP</h2>
    <div class="shop-subtitle" id="shopWaveLabel">You survived wave 50! Spend your gold wisely.</div>
    <div class="shop-gold">üí∞ Gold: <span id="shopGoldDisplay">0</span></div>
    <div class="shop-section-label">‚öîÔ∏è ABILITIES</div>
    <div class="shop-grid" id="shopAbilities"></div>
    <div class="shop-section-label">üõ°Ô∏è PASSIVES</div>
    <div class="shop-grid" id="shopPassives"></div>
    <div style="margin-top:6px;">
        <button class="shop-reroll-btn" id="shopRerollBtn" onclick="rerollShop()">üé≤ Reroll ($<span id="rerollCost">30</span>)</button>
        <button class="shop-skip-btn" onclick="closeWaveShop()">Skip ‚Üí</button>
    </div>
</div>

<div id="pauseOverlay" onclick="resumeGame()"></div>

<div id="pauseMenu">
    <h2>‚è∏ PAUSED</h2>
    <div class="pause-sub">Press ESC or P to resume</div>
    <button class="pause-btn" onclick="resumeGame()">‚ñ∂Ô∏è Resume</button>
    <button class="pause-btn" onclick="openSettingsFromPause()">‚öôÔ∏è Settings</button>
    <button class="pause-btn danger" onclick="pauseToMainMenu()">üè† Main Menu</button>
</div>

<div id="settingsMenu">
    <h2>‚öôÔ∏è SETTINGS</h2>

    <div class="settings-section">
        <h3>üéÆ Keybinds</h3>
        <div id="keybindRows"></div>
    </div>

    <div class="settings-section">
        <h3>üîä Audio & Visual</h3>
        <div class="settings-toggle-row">
            <span class="settings-toggle-label">Screen Shake</span>
            <label class="toggle-switch">
                <input type="checkbox" id="toggleShake" checked onchange="settings.screenShake=this.checked;saveSettings()">
                <span class="toggle-slider"></span>
            </label>
        </div>
        <div class="settings-toggle-row">
            <span class="settings-toggle-label">Particle Effects</span>
            <label class="toggle-switch">
                <input type="checkbox" id="toggleParticles" checked onchange="settings.particles=this.checked;saveSettings()">
                <span class="toggle-slider"></span>
            </label>
        </div>
        <div class="settings-toggle-row">
            <span class="settings-toggle-label">Show Death Feed</span>
            <label class="toggle-switch">
                <input type="checkbox" id="toggleDeathFeed" checked onchange="settings.deathFeed=this.checked;saveSettings();document.getElementById('deathFeed').style.display=this.checked?'flex':'none'">
                <span class="toggle-slider"></span>
            </label>
        </div>
        <div class="settings-toggle-row">
            <span class="settings-toggle-label">Show Nav Debug</span>
            <label class="toggle-switch">
                <input type="checkbox" id="toggleNavDebug" onchange="settings.navDebug=this.checked;saveSettings()">
                <span class="toggle-slider"></span>
            </label>
        </div>
        <div class="slider-row">
            <label>Game Speed</label>
            <input type="range" id="sliderSpeed" min="0.5" max="2" step="0.1" value="1"
                oninput="settings.gameSpeed=parseFloat(this.value);document.getElementById('speedVal').textContent=this.value+'x';saveSettings()">
            <span id="speedVal">1x</span>
        </div>
    </div>

    <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap;">
        <button class="settings-reset-btn" onclick="resetKeybinds()">‚Ü∫ Reset Keybinds</button>
        <button class="settings-reset-btn" onclick="resetAllProgress()">üîÑ Reset Progress</button>
        <button class="menu-btn" id="settingsBackBtn" onclick="closeSettings()" style="min-width:120px;padding:10px 20px;font-size:13px;">Back</button>
    </div>
</div>

<script>
// ========== EASY EDIT: DAILY CODE (Change this to your code) ==========
const DAILY_CODE = 'freegold';  // <-- EDIT THIS! Change to whatever daily code you want
const DAILY_CODE_REWARD = 10000; // Gold reward when code is claimed (default: $10,000)
// =========================================================================

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const skinOverlay = document.getElementById('playerSkinOverlay');

// Daily code variables
let dailyCodeWave = 0;
let dailyCodeRevealed = false;

function scheduleDailyCodeWave() {
    dailyCodeWave = 3 + Math.floor(Math.random() * 8);
    dailyCodeRevealed = false;
}

function revealDailyCode() {
    if(dailyCodeRevealed || !DAILY_CODE) return;
    dailyCodeRevealed = true;
    floatMoneyText('üéÅ Daily Code Claimed: ' + DAILY_CODE);
    alert('Daily Code Claimed: ' + DAILY_CODE);
    
    // Add daily code to CODES system and auto-submit
    CODES[DAILY_CODE] = { reward: 'money', amount: DAILY_CODE_REWARD, message: 'üéÅ Daily Code: +$' + DAILY_CODE_REWARD + '!' };
    
    // Auto-submit the daily code
    const codeInput = document.getElementById('codeInput');
    if(codeInput) codeInput.value = DAILY_CODE;
    
    // Process the reward
    totalMoney += DAILY_CODE_REWARD;
    usedCodes.push(DAILY_CODE);
    savePersistentData();
    updateMoneyDisplay();
    alert('‚ú® Reward Claimed: +$' + DAILY_CODE_REWARD + '!');
}

let totalMoney = parseInt(localStorage.getItem('ballRPGMoney')) || 0;
let unlockedCharacters = JSON.parse(localStorage.getItem('ballRPGCharacters')) || ['default', 'goldhoarder'];
let currentCharacter = localStorage.getItem('ballRPGCurrentCharacter') || 'default';

// Remove beta tester free Hakari unlock
if (unlockedCharacters.includes('hakari')) {
    unlockedCharacters = unlockedCharacters.filter(c => c !== 'hakari');
}

// Limited character timer (Feb 27 2026 12 PM CST)
const LIMITED_CHARACTERS = ['dice', 'hakari_v2', 'yuji_itadori', 'toji'];
const LIMITED_CARD_IDS = {
    'dice': 'diceCharacter',
    'hakari_v2': 'hakariCharacter',
    'yuji_itadori': 'yujiCharacter',
    'toji': 'tojiCharacter'
};
const LIMITED_EXPIRY = {
    'dice': new Date(2026, 1, 27, 12, 0, 0),
    'hakari_v2': new Date(2026, 1, 27, 12, 0, 0),
    'yuji_itadori': new Date(2026, 1, 27, 12, 0, 0),
    'toji': new Date(2026, 1, 28, 12, 0, 0)
};

function updateLimitedTimers() {
    const now = new Date();
    
    LIMITED_CHARACTERS.forEach(char => {
        const cardId = LIMITED_CARD_IDS[char];
        const cardEl = document.getElementById(cardId);
        if (!cardEl) return;
        
        const limitDate = LIMITED_EXPIRY[char];
        const timeLeft = limitDate - now;
        
        if (timeLeft <= 0) {
            cardEl.classList.add('expired');
            const timerEl = cardEl.querySelector('.limited-timer');
            if (timerEl) timerEl.textContent = 'EXPIRED';
            // Remove onclick to prevent selection
            cardEl.style.pointerEvents = 'none';
            cardEl.onclick = null;
        } else {
            cardEl.classList.remove('expired');
            cardEl.style.pointerEvents = 'auto';
            const days = Math.floor(timeLeft / (1000 * 60 * 60 * 24));
            const hours = Math.floor((timeLeft % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const mins = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
            
            const timerText = `${days}d ${hours}h ${mins}m`;
            const timerEl = cardEl.querySelector('.limited-timer');
            if (timerEl) timerEl.textContent = timerText;
        }
    });
}

// Update timers immediately and every minute
updateLimitedTimers();
setInterval(updateLimitedTimers, 60000);

let gameRunning = false, keys = {}, mousePos = { x: 0, y: 0 };

const ADMIN_ABILITIES = [
    { key:'1', name:'BURST',      icon:'üí•', fn:'admin_burst',    mana:0  },
    // ... rest of ADMIN_ABILITIES ...
    { key:'9', name:'TELEPORT',   icon:'üåÄ', fn:'admin_teleport',  mana:0  },
];
let adminCooldowns = [0,0,0,0,0,0,0,0,0];
const ADMIN_CDS    = [60,90,120,100,180,20,300,600,45];

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CHARACTER DEFINITIONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const CHARACTERS = {
    default:     { name:'Veteran',      color:'#3b82f6', shadow:'#1e3a8a', projColor:'#60a5fa', ability:'veteran',        manaCost:20, cdMax:0, messageNormal:'was eliminated', msgSpecial:'was obliterated',   isVeteran:true,  useImg:false },
    goldhoarder: { name:'GoldHoarder',  color:'#fbbf24', shadow:'#ca8a04', projColor:'#fbbf24', ability:'goldRush',       manaCost:40, cdMax:0, isGoldHoarder:true, useImg:false },
    vampire:     { name:'Vampire',      color:'#ef4444', shadow:'#7f1d1d', projColor:'#ef4444', ability:null,             manaCost:0,  cdMax:0, isVampire:true,     useImg:false },
    builder:     { name:'Builder',      color:'#d2691e', shadow:'#8b5a2b', projColor:'#a0522d', ability:'reinforce',      manaCost:30, cdMax:0, useImg:false },
    phantom:     { name:'Phantom',      color:'#7dd3fc', shadow:'#0369a1', projColor:'#7dd3fc', ability:'ghostwalk',      manaCost:20, cdMax:180, isPhantom:true,   useImg:false },
    pyromancer:  { name:'Pyromancer',   color:'#fb923c', shadow:'#c2410c', projColor:'#fb923c', ability:'meteor',         manaCost:45, cdMax:0, isPyromancer:true, useImg:false },
    druid:       { name:'Druid',        color:'#4ade80', shadow:'#16a34a', projColor:'#4ade80', ability:'mushrooms',      manaCost:35, cdMax:0, isDruid:true,      useImg:false },
    cyborg:      { name:'Cyborg',       color:'#38bdf8', shadow:'#0284c7', projColor:'#38bdf8', ability:'lasersweep',     manaCost:30, cdMax:0, isCyborg:true,     useImg:false },
    timewizard:  { name:'TimeWizard',   color:'#d8b4fe', shadow:'#7c3aed', projColor:'#d8b4fe', ability:'rewindtime',     manaCost:60, cdMax:300, isTimeWizard:true, useImg:false },
    fire:        { name:'FireBall',     color:'#ff4500', shadow:'#c2410c', projColor:'#ff4500', ability:'inferno',        manaCost:25, cdMax:0, useImg:false },
    ice:         { name:'IceBall',      color:'#67e8f9', shadow:'#0891b2', projColor:'#67e8f9', ability:'blizzard',       manaCost:30, cdMax:0, useImg:false },
    electric:    { name:'Tesla',        color:'#facc15', shadow:'#a855f7', projColor:'#facc15', ability:'overload',       manaCost:35, cdMax:0, isElectric:true,   useImg:false },
    boxer:       { name:'Boxer',        color:'#fca5a5', shadow:'#dc2626', projColor:'#fca5a5', ability:'dashpunch',      manaCost:25, cdMax:0, useImg:false },
    wemmbu:      { name:'Wemmbu',       color:'#a855f7', shadow:'#6d28d9', projColor:'#c084fc', ability:'groundslam',     manaCost:35, cdMax:0, useImg:true, msgNormal:'was slammed', msgSpecial:'was obliterated by a slam' },
    eggchan:     { name:'Eggchan',      color:'#ec4899', shadow:'#db2777', projColor:'#f472b6', ability:'bowshot',        manaCost:1,  cdMax:0, isMachineGun:true, useImg:true, msgNormal:'was shot down', msgSpecial:'was riddled with arrows' },
    dream:       { name:'Dream',        color:'#22c55e', shadow:'#15803d', projColor:'#4ade80', ability:null,             manaCost:0,  cdMax:0, useImg:true, msgNormal:'was eliminated', msgSpecial:'had a fall' },
    technoblade: { name:'Technoblade',  color:'#7c3aed', shadow:'#5b21b6', projColor:'#a78bfa', ability:'bloodgod',       manaCost:150, cdMax:0, useImg:true, msgNormal:'was destroyed', msgSpecial:'got destroyed by Blood God' },
    admin:       { name:'Admin',        color:'#ffffff', shadow:'#ffffff', projColor:'#ffffff', ability:'admin',          manaCost:0,  cdMax:0, isAdmin:true,      useImg:false },
    dice:        { name:'Dice',         color:'#f97316', shadow:'#ea580c', projColor:'#f97316', ability:'randomspecial',  manaCost:0,  cdMax:0, isDice:true,       useImg:false },
    hakari_v2:   { name:'Hakari',       color:'#ec4899', shadow:'#be185d', projColor:'#f472b6', ability:'domainexpansion', manaCost:60, cdMax:0, useImg:false },
    yuji_itadori: { name:'Yuji',        color:'#e84d4d', shadow:'#991b1b', projColor:'#e84d4d', ability:'cursedslash',   manaCost:0,  cdMax:0, isYuji:true,       useImg:false },
    toji:         { name:'Toji',        color:'#6b4423', shadow:'#3d2817', projColor:'#f59e0b', ability:'toolswap',       manaCost:40, cdMax:120, isToji:true,       useImg:false },
};

const SKIN_URLS = {
    wemmbu: 'https://minotar.net/helm/8af6c50833d54861b5c2dce1c16c6fae/512.png',
    eggchan: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSU8qswuWvs5n8CSTMft-2QFR9Y54APiJ3q1g&s',
    dream: 'https://www.reddit.com/media?url=https%3A%2F%2Fpreview.redd.it%2For0519g00aj51.jpg%3Fwidth%3D256%26format%3Dpjpg%26auto%3Dwebp%26s%3De6698fcbd023cb5aa3cef7b634b795d218e0e564',
    technoblade: 'https://static.wikia.nocookie.net/qsmp/images/d/d7/Techno.Icon.png/revision/latest/scale-to-width-down/250?cb=20230607213749',
};

let currentRound = 0, roundTimer = 0, killStreak = 0, sessionMoney = 0;

const PRICES = {
    default:0, goldhoarder:0, vampire:100, builder:100,
    phantom:250, druid:750, pyromancer:1500, cyborg:3000, timewizard:4500,
    fire:500, ice:1000, electric:2500, boxer:500,
    wemmbu:5000, eggchan:5000, dream:5000, technoblade:50000, admin:1000000000, dice:2345, hakari_v2:35000, yuji_itadori:28000, toji:20000
};

const CHARACTER_ORDER = Object.keys(PRICES).sort((a, b) => PRICES[a] - PRICES[b]);

// Validate currentCharacter exists and is in unlocked characters, default to 'default' if not
if (!unlockedCharacters.includes(currentCharacter) || !CHARACTERS[currentCharacter]) {
    currentCharacter = 'default';
}

const GH_DAMAGE = 15;
const GH_FIRE_INTERVAL = 700;
const GH_SPREAD = 0.55;
const GH_GOLD_MULT = 6.25;
const GH_SPEED_MULT = 0.6875;

const DREAM_ARMOR_TIERS = [
    { name:'No Armor',          kills:0,   defense:0,    glow:'#22c55e', ringColor:null },
    { name:'Leather',           kills:5,   defense:0.10, glow:'#b45309', ringColor:'#b45309' },
    { name:'Chainmail',         kills:15,  defense:0.20, glow:'#6b7280', ringColor:'#9ca3af' },
    { name:'Iron',              kills:30,  defense:0.30, glow:'#9ca3af', ringColor:'#e5e7eb' },
    { name:'Diamond',           kills:55,  defense:0.45, glow:'#06b6d4', ringColor:'#22d3ee' },
    { name:'Netherite',         kills:90,  defense:0.60, glow:'#6b7280', ringColor:'#374151' },
    { name:'Netherite Prot IV', kills:140, defense:0.80, glow:'#a855f7', ringColor:'#7c3aed' },
];

function getDreamArmorTier() {
    if (currentCharacter !== 'dream' && currentCharacter !== 'technoblade' && currentCharacter !== 'admin') return DREAM_ARMOR_TIERS[0];
    let tier = DREAM_ARMOR_TIERS[0];
    for (const t of DREAM_ARMOR_TIERS) { if (player.kills >= t.kills) tier = t; }
    return tier;
}
function applyDreamArmor(dmg) {
    if (currentCharacter !== 'dream' && currentCharacter !== 'technoblade' && currentCharacter !== 'admin') return dmg;
    return dmg * (1 - getDreamArmorTier().defense);
}

function getRainbowColor(t) {
    const h = (t * 0.001) % 1;
    return `hsl(${Math.floor(h*360)},100%,60%)`;
}

const ENEMY_NAMES = ['Skeleton','Zombie','Creeper','Spider','Enderman','Witch','Blaze','Slime','Ghast','Phantom','Piglin','Ravager','Vindicator','Pillager','Evoker','Drowned','Husk','Strider'];

let player = resetPlayerObj();
function resetPlayerObj() {
    return { x:canvas.width/2, y:canvas.height/2, radius:20, speed:5,
             health:100, maxHealth:100, mana:100, maxMana:100,
             exp:0, level:1, damage:20, kills:0,
             dashCooldown:0, manaRegen:0, invulnerable:0, specialCooldown:0 };
}

function getProjectileDamage() {
    if (CHARACTERS[currentCharacter].isMachineGun) return 1;
    if (CHARACTERS[currentCharacter].isGoldHoarder) return GH_DAMAGE;
    if (CHARACTERS[currentCharacter].isBoxer) return player.damage * 2;
    if (CHARACTERS[currentCharacter].isDice) {
        // Random damage between 10 and 150 ‚Äî rolled EACH SHOT
        return Math.floor(10 + Math.random() * 140);
    }
    return player.damage;
}

let expToNextLevel=100, projectiles=[], enemies=[], particles=[], items=[];
let lastEnemySpawn=0, autoFireEnabled=true, specialInProgress=false;
let dreamArmorAnnounce=null, lastDreamTierIdx=-1, bloodGodAnnounce=null;
let mgLastShot = 0;
let autoFireLastShot = 0;
let adminHue = 0;

let veteranTier = 0;
let veteranTimer = 0;
const VETERAN_TIERS = [
    { name:'Rookie',    color:'#3b82f6', shadow:'#3b82f6', projColor:'#60a5fa', dmgMult:1.0, speedBonus:0,   label:'Burst' },
    { name:'Soldier',   color:'#22c55e', shadow:'#16a34a', projColor:'#86efac', dmgMult:1.4, speedBonus:0.5, label:'Volley' },
    { name:'Elite',     color:'#f97316', shadow:'#ea580c', projColor:'#fdba74', dmgMult:2.0, speedBonus:1.0, label:'Nova' },
    { name:'Commander', color:'#a855f7', shadow:'#7c3aed', projColor:'#d8b4fe', dmgMult:2.8, speedBonus:1.5, label:'Shockwave' },
    { name:'Legend',    color:'#fbbf24', shadow:'#f59e0b', projColor:'#fef08a', dmgMult:4.0, speedBonus:2.5, label:'Annihilate' },
];

let firePatches = [];

let overloadCharges = 0;



let runGold = 0;
let shopRerollCost = 30;
let shopOpen = false;
let lastShopWave = 0;

let activeAbilities = [];
let activePassives = [];

const SHOP_ABILITIES = [
    { id:'turret',    name:'Auto Turret',    icon:'üîß', desc:'Spawns a turret that auto-shoots nearby enemies for 15s.', cost:50,  tier:'mid',      maxStack:3, onBuy: ()=>spawnTurret() },
    { id:'shockwave', name:'Shockwave',       icon:'üí•', desc:'Instantly blasts all nearby enemies back & deals 50 dmg.', cost:40,  tier:'cheap',    maxStack:99, onBuy: ()=>doShockwave() },
    { id:'airstrike', name:'Airstrike',       icon:'‚úàÔ∏è', desc:'3 bombs drop on random enemies dealing massive damage.', cost:80,  tier:'pricey',   maxStack:99, onBuy: ()=>doAirstrike() },
    { id:'blackhole', name:'Black Hole',      icon:'üåë', desc:'Sucks all enemies to center then nukes them. 10s.', cost:150, tier:'pricey',   maxStack:99, onBuy: ()=>doBlackhole() },
    { id:'timeslow',  name:'Time Warp',       icon:'‚è≥', desc:'Slows ALL enemies by 80% for 8 seconds.', cost:120, tier:'pricey',   maxStack:99, onBuy: ()=>doTimeSlow() },
    { id:'trishot',   name:'Triple Shot',     icon:'üèπ', desc:'Your shots split into 3 for 20 seconds.', cost:60,  tier:'mid',      maxStack:3, stackDesc:'Adds 1 extra bullet per stack.' },
    { id:'homingshot',name:'Homing Upgrade',  icon:'üéØ', desc:'Your bullets home toward enemies for 15s.', cost:90,  tier:'mid',      maxStack:2 },
    { id:'novaleak',  name:'Nova Leak',       icon:'üîÆ', desc:'Every 5th shot explodes on impact for 3x area.', cost:70,  tier:'mid',      maxStack:2 },
    { id:'fullheal',  name:'Full Heal',       icon:'‚ù§Ô∏è‚Äçüî•', desc:'Instantly restore all HP.', cost:30,  tier:'cheap',    maxStack:99, onBuy: ()=>{ player.health=player.maxHealth; updateHUD(); } },
    { id:'fullmana',  name:'Full Mana',       icon:'üíß', desc:'Instantly restore all Mana.', cost:20,  tier:'cheap',    maxStack:99, onBuy: ()=>{ player.mana=player.maxMana; updateHUD(); } },
    { id:'megaburst', name:'Mega Burst',      icon:'üåü', desc:'Fire 24 bullets in all directions RIGHT NOW.', cost:50,  tier:'mid',      maxStack:99, onBuy: ()=>doMegaBurst() },
    { id:'berserker', name:'Berserker Rush',  icon:'üò§', desc:'2x damage & 1.5x speed for 12 seconds.', cost:100, tier:'pricey',   maxStack:99, onBuy: ()=>doBerserker() },
];

const SHOP_PASSIVES = [
    { id:'lifesteal',  name:'Lifesteal',       icon:'ü©∏', desc:'Heal 5 HP on every kill.', cost:60,  tier:'mid',      maxStack:3, stackDesc:'+5 HP per kill per stack.' },
    { id:'thorns',     name:'Thorns',          icon:'üåµ', desc:'Enemies that touch you take 20 dmg back.', cost:50,  tier:'mid',      maxStack:3, stackDesc:'+20 dmg per stack.' },
    { id:'regen',      name:'Regeneration',    icon:'üíö', desc:'Passively heal 1 HP every 2 seconds.', cost:40,  tier:'cheap',    maxStack:4, stackDesc:'Each stack adds +1 HP/2s.' },
    { id:'manaflow',   name:'Mana Flow',       icon:'üåä', desc:'+2 mana regen per second.', cost:30,  tier:'cheap',    maxStack:5 },
    { id:'armor',      name:'Iron Skin',       icon:'üõ°Ô∏è', desc:'Reduce all damage taken by 15%.', cost:80,  tier:'pricey',   maxStack:4, stackDesc:'+15% reduction per stack (max 60%).' },
    { id:'magnet',     name:'Item Magnet',     icon:'üß≤', desc:'Pickups are attracted from 3x range.', cost:25,  tier:'cheap',    maxStack:2 },
    { id:'explosive',  name:'Explosive Rounds',icon:'üí£', desc:'Every bullet has a 20% chance to explode.', cost:90,  tier:'pricey',   maxStack:3, stackDesc:'+20% chance per stack.' },
    { id:'crit',       name:'Critical Hit',    icon:'‚ö°', desc:'10% chance to deal 3x damage.', cost:70,  tier:'mid',      maxStack:4, stackDesc:'+10% crit per stack.' },
    { id:'multishot',  name:'Multishot',       icon:'üî±', desc:'Fire an extra bullet at a slight angle.', cost:100, tier:'pricey',   maxStack:3, stackDesc:'Each stack adds another bullet.' },
    { id:'ghostly',    name:'Ghost Form',      icon:'üëª', desc:'20% chance to dodge any hit completely.', cost:120, tier:'pricey',   maxStack:3, stackDesc:'+20% dodge per stack (max 60%).' },
    { id:'goldmag',    name:'Gold Magnet',     icon:'üí∞', desc:'Earn +$1 extra per wave.', cost:20,  tier:'cheap',    maxStack:10 },
    { id:'overclock',  name:'Overclock',       icon:'‚öôÔ∏è', desc:'Fire 25% faster permanently.', cost:150, tier:'expensive', maxStack:3, stackDesc:'+25% fire rate per stack.' },
];

let passiveState = {
    lifesteal: 0, thorns: 0, regen: 0, manaflow: 0, armor: 0,
    magnet: 0, explosive: 0, crit: 0, multishot: 0, ghostly: 0,
    goldmag: 0, overclock: 0, trishot: 0, homingshot: 0, novaleak: 0,
    aimassist: 0,
    berserkerActive: false, berserkerTimer: 0,
    timeslowActive: false, timeslowTimer: 0,
    regenTimer: 0,
};

// Biome system - changes every 50 waves
const BIOMES = [
    { name: 'üå≤ Forest', effect: 'none', damageBonus: 0, speedBonus: 0, description: 'Normal conditions', gridColor: 'rgba(59,130,246,0.07)', playerGlow: '#3b82f6', uiColor: '#3b82f6', bgOverlay: 'rgba(0,0,0,0)' },
    { name: '‚ùÑÔ∏è Blizzard', effect: 'freeze', damageBonus: 0, speedBonus: -0.5, description: '-50% movement speed', gridColor: 'rgba(96,165,250,0.1)', playerGlow: '#06b6d4', uiColor: '#0891b2', bgOverlay: 'rgba(135, 206, 250, 0.08)' },
    { name: 'üî• Lava Fields', effect: 'burn', damageBonus: 0.3, speedBonus: 0, description: '+30% damage, enemies burn', gridColor: 'rgba(255,100,0,0.12)', playerGlow: '#ff4500', uiColor: '#ea580c', bgOverlay: 'rgba(255, 100, 0, 0.06)' },
    { name: '‚ö° Storm', effect: 'electric', damageBonus: 0.2, speedBonus: 0.2, description: '+20% damage & speed', gridColor: 'rgba(250,204,21,0.12)', playerGlow: '#facc15', uiColor: '#a855f7', bgOverlay: 'rgba(255, 255, 0, 0.04)' },
    { name: 'üåô Twilight', effect: 'dark', damageBonus: 0, speedBonus: 0.3, description: '+30% attack speed', gridColor: 'rgba(168,85,247,0.08)', playerGlow: '#7c3aed', uiColor: '#d8b4fe', bgOverlay: 'rgba(100, 100, 150, 0.12)' },
    { name: 'üåä Flooded', effect: 'water', damageBonus: -0.15, speedBonus: -0.3, description: '-15% damage, -30% speed', gridColor: 'rgba(96,165,250,0.12)', playerGlow: '#0ea5e9', uiColor: '#0284c7', bgOverlay: 'rgba(100, 150, 200, 0.08)' },
];

function getBiomeColors() {
    return {
        gridColor: currentBiome.gridColor || 'rgba(59,130,246,0.07)',
        playerGlow: currentBiome.playerGlow || '#3b82f6',
        uiColor: currentBiome.uiColor || '#3b82f6',
        bgOverlay: currentBiome.bgOverlay || 'rgba(0,0,0,0)'
    };
}

let currentBiome = BIOMES[0];
let biomeDamageBonus = 0;
let biomeSpeedBonus = 0;
let statsDisplayOpen = false;
let statsUpdateTimer = 0;
let nextBiomeChangeWave = 5 + Math.floor(Math.random() * 10); // Random biome change between waves 5-15

let turrets = [];
let shopCurrentOffer = { abilities: [], passives: [] };

function getStackCount(id) {
    return activePassives.filter(x=>x===id).length + activeAbilities.filter(x=>x===id).length;
}

function getShopCostClass(cost) {
    if(cost<=25) return 'cheap';
    if(cost<=60) return 'mid';
    if(cost<=120) return 'pricey';
    return 'expensive';
}

function buildShopOffer() {
    const shuffle = arr => [...arr].sort(()=>Math.random()-0.5);
    shopCurrentOffer.abilities = shuffle(SHOP_ABILITIES).slice(0,3);
    shopCurrentOffer.passives  = shuffle(SHOP_PASSIVES).slice(0,4);
}

function renderShop() {
    document.getElementById('shopGoldDisplay').textContent = runGold;
    document.getElementById('rerollCost').textContent = shopRerollCost;
    const rb = document.getElementById('shopRerollBtn');
    rb.disabled = runGold < shopRerollCost;

    function renderGrid(items, containerId, isAbility) {
        const grid = document.getElementById(containerId);
        grid.innerHTML = '';
        items.forEach(item => {
            const stack = getStackCount(item.id);
            const maxed = stack >= item.maxStack;
            const cantAfford = runGold < item.cost;
            const div = document.createElement('div');
            div.className = 'shop-item' + (maxed?' shop-item-maxed':'') + (!maxed && cantAfford?' shop-item-cantafford':'');
            const costClass = getShopCostClass(item.cost);
            div.innerHTML = `
                ${stack>0?`<div class="shop-item-stack">x${stack}</div>`:''}
                <div class="shop-item-icon">${item.icon}</div>
                <div class="shop-item-name">${item.name}</div>
                <div class="shop-item-desc">${maxed?'<span style="color:#a855f7">MAXED OUT!</span>':item.desc}${item.stackDesc&&stack>0&&!maxed?`<br><span style="color:#c084fc">${item.stackDesc}</span>`:''}</div>
                <div class="shop-item-cost ${costClass}">${maxed?'‚úÖ MAX':'üí∞ $'+item.cost}</div>
            `;
            if(!maxed) div.onclick = () => buyShopItem(item, isAbility);
            grid.appendChild(div);
        });
    }

    renderGrid(shopCurrentOffer.abilities, 'shopAbilities', true);
    renderGrid(shopCurrentOffer.passives,  'shopPassives',  false);
}

function openWaveShop(wave) {
    shopOpen = true;
    gameRunning = false;
    shopRerollCost = 30;
    buildShopOffer();
    document.getElementById('shopWaveLabel').textContent = `Wave ${wave} survived! Spend your run gold wisely.`;
    const el = document.getElementById('waveShop');
    el.style.display = 'block';
    renderShop();
    setTimeout(()=>el.classList.add('show'), 10);
}

function closeWaveShop() {
    const el = document.getElementById('waveShop');
    el.classList.remove('show');
    setTimeout(()=>{ el.style.display='none'; shopOpen=false;
    walls=[]; generateWalls();
    gameRunning=true; requestAnimationFrame(gameLoop); }, 200);
}

function rerollShop() {
    if(runGold < shopRerollCost) return;
    runGold -= shopRerollCost;
    shopRerollCost = Math.floor(shopRerollCost * 1.8);
    buildShopOffer();
    renderShop();
}

function buyShopItem(item, isAbility) {
    if(runGold < item.cost) return;
    const stack = getStackCount(item.id);
    if(stack >= item.maxStack) return;
    runGold -= item.cost;
    document.getElementById('shopGoldDisplay').textContent = runGold;
    if(isAbility) activeAbilities.push(item.id);
    else activePassives.push(item.id);
    applyPassiveOnBuy(item.id, isAbility);
    if(item.onBuy) item.onBuy();
    floatMoneyText('Bought: ' + item.name + '!');
    renderShop();
}

function applyPassiveOnBuy(id, isAbility) {
    switch(id) {
        case 'lifesteal': passiveState.lifesteal += 5; break;
        case 'thorns':    passiveState.thorns += 20; break;
        case 'regen':     passiveState.regen += 1; break;
        case 'manaflow':  passiveState.manaflow += 2; break;
        case 'armor':     passiveState.armor = Math.min(passiveState.armor + 0.15, 0.60); break;
        case 'magnet':    passiveState.magnet += 1; break;
        case 'explosive': passiveState.explosive += 0.20; break;
        case 'crit':      passiveState.crit += 0.10; break;
        case 'multishot': passiveState.multishot += 1; break;
        case 'ghostly':   passiveState.ghostly = Math.min(passiveState.ghostly + 0.20, 0.60); break;
        case 'goldmag':   passiveState.goldmag += 1; break;
        case 'overclock': passiveState.overclock += 1; break;
        case 'trishot':   passiveState.trishot += 1; passiveState.trishotTimer += 20*60; break;
        case 'homingshot':passiveState.homingshot += 1; passiveState.homingTimer += 15*60; break;
        case 'novaleak':  passiveState.novaleak += 1; break;
    }
}

function doShockwave() {
    const rad = 220;
    enemies.forEach(e => {
        const dx=e.x-player.x, dy=e.y-player.y, dist=Math.sqrt(dx*dx+dy*dy);
        if(dist < rad) {
            e.health -= 50;
            const push = (rad - dist) / rad * 80;
            e.x += (dx/dist)*push; e.y += (dy/dist)*push;
            if(e.health<=0){e.alive=false;player.kills++;gainExp(e.expValue);handleKill(e);}
        }
    });
    for(let r=20;r<rad;r+=18) for(let a=0;a<Math.PI*2;a+=0.2) particles.push(new Particle(player.x+Math.cos(a)*r, player.y+Math.sin(a)*r, '#fbbf24'));
}

let pendingAirstrikes = [];
function doAirstrike() {
    const targets = [...enemies].sort(()=>Math.random()-0.5).slice(0,3);
    targets.forEach((e,i) => {
        pendingAirstrikes.push({ tx:e.x, ty:e.y, delay: i*18 });
    });
}
function tickAirstrikes(dt) {
    pendingAirstrikes = pendingAirstrikes.filter(a => {
        a.delay -= dt;
        if(a.delay <= 0) {
            const {tx,ty} = a;
            for(let i=0;i<40;i++) particles.push(new Particle(tx,ty,'#ef4444'));
            for(let i=0;i<20;i++) particles.push(new Particle(tx,ty,'#fbbf24'));
            enemies.forEach(en=>{
                const d=Math.hypot(en.x-tx,en.y-ty);
                if(d<80){ en.health-=player.damage*5; if(en.health<=0){en.alive=false;player.kills++;gainExp(en.expValue);handleKill(en);} }
            });
            return false;
        }
        return true;
    });
}

function doBlackhole() {
    passiveState.blackholeActive = true;
    passiveState.blackholeTimer = 180;
}

function doTimeSlow() {
    passiveState.timeslowActive = true;
    passiveState.timeslowTimer = 8 * 60;
}

function doMegaBurst() {
    for(let i=0;i<24;i++){
        const a=(Math.PI*2/24)*i;
        const p=new Projectile(player.x,player.y,a,player.damage*2,CHARACTERS[currentCharacter].projColor,true);
        projectiles.push(p);
    }
    for(let i=0;i<40;i++) particles.push(new Particle(player.x,player.y,CHARACTERS[currentCharacter].color));
}

function doBerserker() {
    passiveState.berserkerActive = true;
    passiveState.berserkerTimer = 12 * 60;
    for(let i=0;i<30;i++) particles.push(new Particle(player.x,player.y,'#ef4444'));
}

class Turret {
    constructor(x,y){ this.x=x; this.y=y; this.life=15*60; this.shootTimer=0; this.radius=10; }
    update(dt){
        this.life-=dt; this.shootTimer-=dt;
        if(this.shootTimer<=0){
            this.shootTimer=45;
            let nearest=null, nDist=Infinity;
            enemies.forEach(e=>{ const d=Math.hypot(e.x-this.x,e.y-this.y); if(d<200&&d<nDist){nDist=d;nearest=e;} });
            if(nearest){
                const a=Math.atan2(nearest.y-this.y,nearest.x-this.x);
                const p=new Projectile(this.x,this.y,a,player.damage*0.8,'#22c55e');
                projectiles.push(p);
            }
        }
    }
    draw(){
        ctx.save();
        ctx.fillStyle='#22c55e'; ctx.shadowBlur=12; ctx.shadowColor='#22c55e';
        ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#fff'; ctx.font='10px Arial'; ctx.textAlign='center';
        ctx.fillText('‚öôÔ∏è',this.x,this.y+4);
        const bw=24, bh=3, bx=this.x-12, by=this.y-this.radius-6;
        ctx.fillStyle='rgba(0,0,0,.5)'; ctx.fillRect(bx,by,bw,bh);
        ctx.fillStyle='#22c55e'; ctx.fillRect(bx,by,bw*(this.life/(15*60)),bh);
        ctx.restore();
    }
}

function spawnTurret(){
    const angle = Math.random()*Math.PI*2;
    const tx = Math.max(20, Math.min(canvas.width-20, player.x+Math.cos(angle)*60));
    const ty = Math.max(20, Math.min(canvas.height-20, player.y+Math.sin(angle)*60));
    turrets.push(new Turret(tx,ty));
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// NEW CHARACTER STATE & SYSTEMS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let phantomPhasing = false;       // ghost walk active
let phantomPhaseTimer = 0;        // frames remaining for phase
let druidRoots = [];              // {x,y,radius,timer,enemy} ‚Äî rooted enemy positions
let pyroChargeTimer = 0;          // frames held for charge shot
let pyroCharging = false;
let cyborgMode = 'rapid';         // 'rapid' or 'heavy'
let timeWizardSnapshot = null;    // {health, ts} ‚Äî last saved HP snapshot
let timeWizardSnapshotTimer = 0;  // counts up to 5s (300f) to save new snapshot
let druidShrooms = [];            // {x,y,timer,radius} ‚Äî healing mushrooms
let lastNewCharShot = 0;          // for custom fire rate on new chars
let builderWalls = [];            // {x,y,w,h,hp,maxHp,reinforced} ‚Äî walls for builder
let builderMoveMode = false;      // builder is in move mode (E key)
let builderSelectedWall = null;   // builder selected wall to move

// ‚îÄ‚îÄ HAKARI domain state ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let hakariDomainActive = false;   // domain expansion is active
let hakariDomainTimer = 0;        // frames remaining in domain (60 frames = 1 sec, so 3600 = 60 sec)
let hakariRollTimer = 0;          // animation counter for rolling
let hakariRollCount = 0;          // number of rolls so far
let hakariJackpotTimer = 0;       // 4m 11s immortality (15060 frames at 60fps)
let hakariJackpotActive = false;  // jackpot mode active (one-shot everything)
let hakariJackpotCooldown = 0;    // cooldown after jackpot before domain can be released

// ‚îÄ‚îÄ YUJI ITADORI state ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let yujiSukunaFingers = 0;        // number of sukuna fingers collected (0-20)
let yujiIsSukuna = false;         // true when transformed to sukuna at 20 fingers
let yujiFingerParticles = [];     // visual particles for sukuna fingers
let sukunaMalevolentActive = false; // malevolent shrine active (continuous damage enabled)
let sukunaMalevolentTimer = 0;    // frames remaining in malevolent shrine effect display
let sukunaMalevolentCooldown = 0; // cooldown before shrine can be used again (300 frames = 5 seconds)

// Toji Fushiguro variables
let tojiToolMode = 'sharp';       // 'sharp' or 'heavy'
let tojiSharpModeTimer = 0;       // frames remaining in sharp mode (+30% dmg)
let tojiHeavyModeTimer = 0;       // frames remaining in heavy mode (+20% dmg, 50% slow)

function tickNewCharacters(ts, dt) {
    const skin = currentCharacter;

    // ‚îÄ‚îÄ TOJI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if (skin === 'toji') {
        if(tojiSharpModeTimer > 0) tojiSharpModeTimer -= dt;
        if(tojiHeavyModeTimer > 0) tojiHeavyModeTimer -= dt;
    }

    // ‚îÄ‚îÄ PHANTOM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if (skin === 'phantom') {
        if (phantomPhasing) {
            phantomPhaseTimer -= dt;
            if (phantomPhaseTimer <= 0) {
                phantomPhasing = false;
                floatMoneyText('üëª Ghost Walk ended');
            }
            // Phase glow ring
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(ts * 0.008);
            ctx.strokeStyle = `rgba(125,211,252,${0.4 + 0.3*Math.sin(ts*0.03)})`;
            ctx.lineWidth = 3;
            ctx.setLineDash([5,4]);
            ctx.beginPath(); ctx.arc(0,0,player.radius+10,0,Math.PI*2); ctx.stroke();
            ctx.restore();
        }
    }

    // ‚îÄ‚îÄ DRUID mushrooms ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    druidShrooms = druidShrooms.filter(s => {
        s.timer -= dt;
        if (s.timer <= 0) return false;
        const alpha = s.timer < 60 ? s.timer / 60 : 1;
        ctx.save(); ctx.globalAlpha = alpha;
        ctx.shadowBlur = 20; ctx.shadowColor = '#4ade80';
        ctx.font = '22px Arial'; ctx.textAlign = 'center';
        ctx.fillText('üçÑ', s.x, s.y + 8);
        // Healing radius ring
        ctx.strokeStyle = 'rgba(74,222,128,0.3)'; ctx.lineWidth = 2;
        ctx.setLineDash([4,4]);
        ctx.beginPath(); ctx.arc(s.x, s.y, s.radius, 0, Math.PI*2); ctx.stroke();
        ctx.restore();
        // Heal player if inside
        const d = Math.hypot(player.x - s.x, player.y - s.y);
        if (d < s.radius) {
            player.health = Math.min(player.health + 0.05*dt, player.maxHealth);
            updateHUD();
            if (Math.random() < 0.05) for(let i=0;i<3;i++) particles.push(new Particle(player.x, player.y, '#4ade80'));
        }
        return true;
    });

    // ‚îÄ‚îÄ PYROMANCER charge ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if (skin === 'pyromancer' && pyroCharging) {
        pyroChargeTimer += dt;
        const maxCharge = 180; // 3s max
        const pct = Math.min(pyroChargeTimer / maxCharge, 1);
        // Draw charge indicator
        const r = player.radius + 5 + pct * 18;
        ctx.save();
        ctx.translate(player.x, player.y); ctx.rotate(ts * 0.01);
        const grad = ctx.createRadialGradient(0,0,player.radius,0,0,r+5);
        grad.addColorStop(0, `rgba(251,146,60,${0.3+pct*0.5})`);
        grad.addColorStop(1, 'rgba(194,65,12,0)');
        ctx.beginPath(); ctx.arc(0,0,r+5,0,Math.PI*2); ctx.fillStyle=grad; ctx.fill();
        ctx.strokeStyle = `rgba(251,146,60,${0.6+pct*0.4})`; ctx.lineWidth = 2+pct*4;
        ctx.setLineDash([]);
        ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.stroke();
        ctx.restore();
        // Charge label
        ctx.save();
        ctx.font = 'bold 10px Arial'; ctx.textAlign = 'center'; ctx.fillStyle = '#fed7aa';
        ctx.shadowBlur = 10; ctx.shadowColor = '#c2410c';
        ctx.fillText(`${Math.round(pct*100)}% CHARGE`, player.x, player.y - player.radius - 8);
        ctx.restore();
    }

    // ‚îÄ‚îÄ CYBORG mode indicator ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if (skin === 'cyborg') {
        ctx.save();
        ctx.font = 'bold 9px Arial'; ctx.textAlign = 'center';
        if (cyborgMode === 'rapid') {
            ctx.fillStyle = '#38bdf8'; ctx.shadowBlur=8; ctx.shadowColor='#0ea5e9';
            ctx.fillText('RAPID ‚ö°', player.x, player.y - player.radius - 7);
        } else {
            ctx.fillStyle = '#c084fc'; ctx.shadowBlur=8; ctx.shadowColor='#7c3aed';
            ctx.fillText('HEAVY üí•', player.x, player.y - player.radius - 7);
        }
        ctx.restore();
    }

    // ‚îÄ‚îÄ TIME WIZARD snapshot ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if (skin === 'timewizard') {
        timeWizardSnapshotTimer += dt;
        if (timeWizardSnapshotTimer >= 300) { // every 5s
            timeWizardSnapshotTimer = 0;
            timeWizardSnapshot = { health: player.health };
        }
        // Faint time echo ring
        ctx.save();
        ctx.translate(player.x, player.y);
        const pulse = 0.3 + 0.2*Math.sin(ts * 0.005);
        ctx.strokeStyle = `rgba(216,180,254,${pulse})`;
        ctx.lineWidth = 1.5; ctx.setLineDash([3,5]);
        ctx.rotate(-ts*0.003);
        ctx.beginPath(); ctx.arc(0,0,player.radius+14,0,Math.PI*2); ctx.stroke();
        ctx.restore();
    }
}

function tickNewCharAutoFire(ts, dt) {
    const skin = currentCharacter;
    const sk = CHARACTERS[skin];
    if (!sk.isPhantom && !sk.isDruid && !sk.isPyromancer && !sk.isCyborg && !sk.isTimeWizard) return false;

    if (sk.isPyromancer) return true; // pyromancer handled by mouse hold

    let interval = 250;
    if (sk.isCyborg) interval = cyborgMode === 'rapid' ? 110 : 550;
    if (sk.isPhantom) interval = 180; // medium fast
    if (sk.isDruid)   interval = 350; // medium
    if (sk.isTimeWizard) interval = 300; // slightly slower but echo doubles hits

    const overclockMult = 1 - Math.min(passiveState.overclock * 0.25, 0.75);
    if (ts - lastNewCharShot > interval * overclockMult) {
        lastNewCharShot = ts;
        shootNewChar(ts);
    }
    return true;
}

function shootNewChar(ts) {
    const angle = Math.atan2(mousePos.y - player.y, mousePos.x - player.x);
    const sk = CHARACTERS[currentCharacter];
    let dmg = applyPassiveDamageBoost(player.damage);

    if (sk.isPhantom) {
        // Ethereal shot ‚Äî pierce walls
        const p = new Projectile(player.x, player.y, angle, dmg * 1.1, sk.projColor, true);
        p.isPhantom = true; // skip wall collision
        projectiles.push(p);
        if (passiveState.multishot > 0 || passiveState.trishot > 0) {
            const sAngles = [angle - 0.25, angle + 0.25];
            sAngles.forEach(a => {
                const p2 = new Projectile(player.x, player.y, a, dmg * 0.7, sk.projColor, true);
                p2.isPhantom = true;
                projectiles.push(p2);
            });
        }
    }

    if (sk.isDruid) {
        // Vine shot ‚Äî roots enemies
        const p = new Projectile(player.x, player.y, angle, dmg, sk.projColor, false);
        p.isDruidVine = true;
        projectiles.push(p);
    }

    if (sk.isCyborg) {
        if (cyborgMode === 'rapid') {
            const spread = (Math.random()-0.5)*0.12;
            const p = new Projectile(player.x, player.y, angle+spread, dmg*0.65, sk.projColor, false);
            projectiles.push(p);
        } else {
            // Heavy: big slow shot
            const p = new Projectile(player.x, player.y, angle, dmg*2.8, '#c084fc', true);
            p.radius = 11;
            projectiles.push(p);
        }
    }

    if (sk.isTimeWizard) {
        // Fire shot + delayed echo
        const p = new Projectile(player.x, player.y, angle, dmg, sk.projColor, false);
        projectiles.push(p);
        // Echo shot spawns 0.3s later
        setTimeout(() => {
            if (!gameRunning) return;
            const echo = new Projectile(player.x, player.y, angle, dmg * 0.6, '#c4b5fd', false);
            echo.isTimeEcho = true;
            projectiles.push(echo);
            for(let i=0;i<5;i++) particles.push(new Particle(player.x, player.y, '#a78bfa'));
        }, 300);
    }
}

function applyPassiveDamageBoost(baseDmg) {
    let dmg = baseDmg;
    if(passiveState.crit > 0 && Math.random() < passiveState.crit) { dmg *= 3; }
    if(passiveState.berserkerActive) dmg *= 2;
    return dmg;
}

function applyPassiveIncomingDamage(dmg) {
    if(passiveState.ghostly > 0 && Math.random() < passiveState.ghostly) { floatMoneyText('DODGED!'); return 0; }
    dmg = dmg * (1 - passiveState.armor);
    return dmg;
}

function tickPassives(dt) {
    if(passiveState.regen > 0) {
        passiveState.regenTimer += dt;
        if(passiveState.regenTimer >= 120) {
            player.health = Math.min(player.health + passiveState.regen, player.maxHealth);
            passiveState.regenTimer = 0;
            updateHUD();
        }
    }
    if(passiveState.trishotTimer > 0) {
        passiveState.trishotTimer -= dt;
        if(passiveState.trishotTimer <= 0) { passiveState.trishotTimer=0; passiveState.trishot=0; floatMoneyText('Triple Shot expired'); }
    }
    if(passiveState.homingTimer > 0) {
        passiveState.homingTimer -= dt;
        if(passiveState.homingTimer <= 0) { passiveState.homingTimer=0; passiveState.homingshot=0; floatMoneyText('Homing expired'); }
    }
    if(passiveState.berserkerActive) {
        passiveState.berserkerTimer -= dt;
        if(passiveState.berserkerTimer <= 0) { passiveState.berserkerActive=false; }
    }
    if(passiveState.timeslowActive) {
        passiveState.timeslowTimer -= dt;
        if(passiveState.timeslowTimer <= 0) passiveState.timeslowActive=false;
    }
}

function fireWithPassives(baseAngle) {
    const sk = CHARACTERS[currentCharacter];
    const col = sk.isAdmin ? `hsl(${adminHue},100%,60%)` : sk.projColor;
    const angles = [baseAngle];
    const total = 1 + passiveState.multishot + passiveState.trishot;
    for(let i=1;i<total;i++) { angles.push(baseAngle + (i%2===0?1:-1)*0.18*Math.ceil(i/2)); }
    angles.forEach(a=>{
        let finalAngle = a;
        if(passiveState.aimassist >= 1 && Math.random() < 0.25 && enemies.length > 0) {
            let nearest = null, nDist = Infinity;
            enemies.forEach(e => {
                const d = Math.hypot(e.x - player.x, e.y - player.y);
                if(d < nDist && d < 400) {
                    nDist = d;
                    nearest = e;
                }
            });
            if(nearest) {
                finalAngle = Math.atan2(nearest.y - player.y, nearest.x - player.x);
            }
        }
        let dmg = applyPassiveDamageBoost(getProjectileDamage());
        // Apply biome damage bonus
        dmg *= (1 + biomeDamageBonus);
        // Apply Toji mode bonuses
        if(sk.isToji) {
            if(tojiSharpModeTimer > 0) dmg *= 1.30; // +30% damage in sharp mode
            if(tojiHeavyModeTimer > 0) dmg *= 1.20; // +20% damage in heavy mode
        }
        const p = new Projectile(player.x,player.y,finalAngle,dmg,col,false,false,sk.isMachineGun);
        if(sk.isAdmin) { p.isAdmin=true; p.hue=adminHue; }
        if(passiveState.homingshot>0) p.homing=true;
        projectiles.push(p);
    });
}

function earnRunGold(amount) {
    const mult = CHARACTERS[currentCharacter].isGoldHoarder ? GH_GOLD_MULT : 1;
    runGold += (amount + passiveState.goldmag) * mult;
    document.getElementById('hudMoney').textContent = 'üí∞' + runGold + ' (gold)';
}

function earnMoney(amount, reason) {
    const mult = CHARACTERS[currentCharacter].isGoldHoarder ? GH_GOLD_MULT : 1;
    const actual = amount * mult;
    totalMoney += actual;
    sessionMoney += actual;
    savePersistentData();
    updateMoneyDisplay();
    document.getElementById('hudMoney').textContent = 'üí∞' + runGold + ' (gold)';
    floatMoneyText('+$' + actual + (reason ? ' (' + reason + ')' : ''));
}

let floatingTexts = [];
let notificationQueue = [];
let currentNotification = null;
let notificationTimer = 0;

function floatMoneyText(text) {
    // Replace queue instead of pushing ‚Äî only show latest notification
    notificationQueue = [text];
    currentNotification = text;
    notificationTimer = 180; // 3 seconds at 60 FPS
}

function processNotificationQueue() {
    // Keep current notification alive, don't queue up
    if(notificationTimer <= 0) {
        currentNotification = null;
    }
}

function toggleStatsDisplay() {
    statsDisplayOpen = !statsDisplayOpen;
    const panel = document.getElementById('statsPanel');
    if(statsDisplayOpen) { panel.classList.add('show'); statsUpdateTimer = 0; updateStatsDisplay(); }
    else { panel.classList.remove('show'); }
}

function updateStatsDisplay() {
    if(!statsDisplayOpen) return;
    const totalArmor = Math.min(passiveState.armor * 15, 60);
    const lifestealPct = passiveState.lifesteal * 5;
    document.getElementById('statBiome').textContent = currentBiome.name;
    document.getElementById('statBiomeEffect').textContent = currentBiome.description;
    document.getElementById('statHealth').textContent = `${Math.floor(player.health)}/${player.maxHealth}`;
    document.getElementById('statDamage').textContent = Math.floor(getProjectileDamage() + (getProjectileDamage() * biomeDamageBonus));
    document.getElementById('statSpeed').textContent = (player.speed + biomeSpeedBonus).toFixed(2);
    document.getElementById('statLevel').textContent = player.level;
    document.getElementById('statKills').textContent = player.kills;
    document.getElementById('statWave').textContent = currentRound;
    document.getElementById('statArmor').textContent = totalArmor + '%';
    document.getElementById('statLifesteal').textContent = lifestealPct + '%';
}

function updateBiome() {
    // Randomly change biome at scheduled waves
    if(currentRound >= nextBiomeChangeWave) {
        let randomIndex = Math.floor(Math.random() * BIOMES.length);
        // Avoid picking the same biome twice in a row
        while(BIOMES[randomIndex].name === currentBiome.name) {
            randomIndex = Math.floor(Math.random() * BIOMES.length);
        }
        currentBiome = BIOMES[randomIndex];
        biomeDamageBonus = currentBiome.damageBonus;
        biomeSpeedBonus = currentBiome.speedBonus;
        floatMoneyText(`üåç BIOME CHANGED: ${currentBiome.name}`);
        // Schedule next biome change at random interval (8-15 waves from now for frequent changes)
        nextBiomeChangeWave = currentRound + 8 + Math.floor(Math.random() * 8);
        
        // Update HUD colors based on biome
        updateBiomeColors();
    }
    document.getElementById('biomeName').textContent = currentBiome.name;
    document.getElementById('biomeEffect').textContent = currentBiome.description;
}

function updateBiomeColors() {
    const colors = getBiomeColors();
    const hud = document.getElementById('hud');
    const statsPanel = document.getElementById('statsPanel');
    const biomeIndicator = document.getElementById('biomeIndicator');
    
    // Update HUD border and accent colors
    if(hud) {
        hud.style.setProperty('--biome-color', colors.uiColor);
        const statBoxes = hud.querySelectorAll('.stat-box');
        statBoxes.forEach(box => {
            box.style.borderColor = colors.uiColor;
        });
        const progressBars = hud.querySelectorAll('.progress-fill');
        progressBars.forEach(bar => {
            if(!bar.classList.contains('health-bar') && !bar.classList.contains('mana-bar') && !bar.classList.contains('exp-bar')) {
                bar.style.background = colors.uiColor;
            }
        });
    }
    
    // Update stats panel
    if(statsPanel) {
        statsPanel.style.borderColor = colors.uiColor;
        const title = statsPanel.querySelector('h3');
        if(title) title.style.color = colors.uiColor;
    }
    
    // Update biome indicator
    if(biomeIndicator) {
        biomeIndicator.style.borderColor = colors.uiColor;
        const biomeName = biomeIndicator.querySelector('.biome-name');
        if(biomeName) biomeName.style.color = colors.uiColor;
    }
}

function showBiomeIndicator() {
    const indicator = document.getElementById('biomeIndicator');
    if(document.getElementById('gameContainer').style.display === 'block') {
        indicator.style.display = 'block';
    }
}

function showDeathMsg(victim, action) {
    const feed = document.getElementById('deathFeed');
    const el = document.createElement('div');
    el.className = 'death-msg';
    el.innerHTML = `<span class="victim">${victim}</span> ${action}`;
    feed.appendChild(el);
    while (feed.children.length > 5) feed.removeChild(feed.firstChild);
    setTimeout(() => { el.style.opacity='0'; setTimeout(()=>el.remove(), 600); }, 3200);
}
function randName() { return ENEMY_NAMES[Math.floor(Math.random()*ENEMY_NAMES.length)]; }

function showPopup(title, msg) {
    document.getElementById('popupTitle').textContent = title;
    document.getElementById('popupMsg').textContent = msg;
    document.getElementById('moneyPopup').classList.add('show');
}
function closeMoneyPopup() {
    document.getElementById('moneyPopup').classList.remove('show');
}

function toggleFullscreen() {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(()=>{});
    } else {
        document.exitFullscreen();
    }
}
document.addEventListener('keydown', e => {
    if (e.key === 'F11') { e.preventDefault(); toggleFullscreen(); }
});

class Projectile {
    constructor(x,y,angle,dmg,color,isSpecial=false,isBow=false,isMG=false) {
        this.x=x; this.y=y;
        this.speed=isBow?18:isMG?14:12;
        this.vx=Math.cos(angle)*this.speed; this.vy=Math.sin(angle)*this.speed;
        this.radius=isMG?2.5:isBow?4:6;
        this.damage=dmg; this.color=color;
        this.alive=true; this.isSpecial=isSpecial; this.isBow=isBow; this.isMG=isMG; this.angle=angle;
        this.isAdmin = false;
        this.hue = 0;
    }
    update(dt=1) {
        if(this.homing && enemies.length>0){
            let nearest=null,nDist=Infinity;
            enemies.forEach(e=>{ const d=Math.hypot(e.x-this.x,e.y-this.y); if(d<nDist){nDist=d;nearest=e;} });
            if(nearest){
                const ta=Math.atan2(nearest.y-this.y,nearest.x-this.x);
                const ca=Math.atan2(this.vy,this.vx);
                let diff=ta-ca; while(diff>Math.PI)diff-=Math.PI*2; while(diff<-Math.PI)diff+=Math.PI*2;
                const turn=Math.min(Math.abs(diff),0.06)*Math.sign(diff);
                const na=ca+turn; const sp=Math.hypot(this.vx,this.vy);
                this.vx=Math.cos(na)*sp; this.vy=Math.sin(na)*sp;
            }
        }
        this.x+=this.vx*dt; this.y+=this.vy*dt;
        this.hue = (this.hue + 5*dt) % 360;
        if(this.x<-20||this.x>canvas.width+20||this.y<-20||this.y>canvas.height+20) this.alive=false;
    }
    draw() {
        ctx.save();
        if (this.isBow) {
            ctx.translate(this.x,this.y); ctx.rotate(this.angle);
            ctx.strokeStyle='#8B6914'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(-10,0); ctx.lineTo(10,0); ctx.stroke();
            ctx.fillStyle='#c0c0c0'; ctx.beginPath(); ctx.moveTo(10,0); ctx.lineTo(5,-3); ctx.lineTo(5,3); ctx.closePath(); ctx.fill();
            ctx.strokeStyle='#ef4444'; ctx.lineWidth=1.5; ctx.beginPath(); ctx.moveTo(-8,0); ctx.lineTo(-13,-3); ctx.moveTo(-8,0); ctx.lineTo(-13,3); ctx.stroke();
        } else if (this.isMG) {
            ctx.shadowBlur=6; ctx.shadowColor='#e5e7eb';
            ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.fillStyle='#f9fafb'; ctx.fill();
        } else if (this.isAdmin) {
            const col = `hsl(${this.hue},100%,60%)`;
            ctx.shadowBlur=20; ctx.shadowColor=col;
            ctx.beginPath(); ctx.arc(this.x,this.y,this.radius+2,0,Math.PI*2); ctx.fillStyle=col; ctx.fill();
        } else {
            ctx.shadowBlur=15; ctx.shadowColor=this.color;
            ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.fillStyle=this.color; ctx.fill();
        }
        ctx.restore();
    }
}

class Enemy {
    constructor(x,y,type='normal') {
        this.x=x; this.y=y; this.type=type; 
        this.radius=type==='boss'?30:(type==='triangle'?12:15);
        this.speed=type==='boss'?1.5:(type==='triangle'?3.5:2+Math.random()); 
        this.health=type==='boss'?10000:(type==='triangle'?150:200);
        this.maxHealth=this.health; 
        this.damage=type==='boss'?20:(type==='triangle'?12:10);
        this.expValue=type==='boss'?50:(type==='triangle'?15:10); 
        this.color=type==='boss'?'#dc2626':(type==='triangle'?'#7c3aed':'#ef4444');
        this.alive=true; this.frozen=0; this.name=randName();
        this.isBoss = type==='boss';
        this.isTriangle = type==='triangle';
        this.rotation = Math.random() * Math.PI * 2;
    }
    update(dt=1) {
        if(this.frozen>0){this.frozen-=dt;return;}
        
        // Apply Toji heavy mode slow
        let effectiveSlowMult = 1;
        if(this.slowTimer !== undefined && this.slowTimer > 0) {
            this.slowTimer -= dt;
            effectiveSlowMult = 1 - this.slowAmount;
        }
        
        const slowMult = passiveState.timeslowActive ? 0.2 : 1;

        if (!this.path) this.path = [];
        if (this.pathTimer === undefined) this.pathTimer = Math.random() * 30;
        this.pathTimer -= dt;

        const distToPlayer = Math.hypot(player.x - this.x, player.y - this.y);
        const hasLOS = !navRayBlocked(this.x, this.y, player.x, player.y);

        if (hasLOS) {
            this.path = [];
            this.pathTimer = 30;
        } else if (this.pathTimer <= 0 || this.path.length === 0) {
            this.path = navFindPath(this.x, this.y, player.x, player.y) || [];
            this.pathTimer = 35 + Math.random() * 20;
        }

        let tx, ty;
        if (this.path.length > 0) {
            const wp = this.path[0];
            tx = wp.wx; ty = wp.wy;
            if (Math.hypot(this.x - tx, this.y - ty) < NAV_CELL * 0.8) {
                this.path.shift();
            }
        } else {
            tx = player.x; ty = player.y;
        }

        const ddx = tx - this.x, ddy = ty - this.y, ddist = Math.sqrt(ddx*ddx + ddy*ddy);
        if(ddist > 0) {
            this.x += (ddx/ddist) * this.speed * dt * slowMult * effectiveSlowMult;
            this.y += (ddy/ddist) * this.speed * dt * slowMult * effectiveSlowMult;
        }

        const eRes = resolveCircleWall(this.x, this.y, this.radius);
        this.x = eRes.x; this.y = eRes.y;

        if(distToPlayer < this.radius+player.radius && player.invulnerable<=0){
            let inDmg = applyDreamArmor(this.damage);
            inDmg = applyPassiveIncomingDamage(inDmg);
            if(passiveState.thorns>0){ this.health-=passiveState.thorns; if(this.health<=0){this.alive=false;player.kills++;gainExp(this.expValue);handleKill(this);} }
            player.health-=inDmg; player.invulnerable=30; updateHUD();
            if(player.health<=0) endGame();
            this.alive=false;
            for(let i=0;i<20;i++) particles.push(new Particle(this.x,this.y,this.color));
        }
        // Builder walls take damage from nearby enemies
        for(let w of builderWalls) {
            const dwDist = Math.hypot(this.x - (w.x + w.w/2), this.y - (w.y + w.h/2));
            if(dwDist < this.radius + Math.max(w.w, w.h)/2) {
                w.hp -= 1;
                if(w.hp <= 0) builderWalls = builderWalls.filter(bw => bw !== w);
            }
        }
    }
    draw() {
        ctx.save(); ctx.shadowBlur=20;
        if(this.frozen>0){
            // Custom frozen colors per character
            if(CHARACTERS[currentCharacter].isGoldHoarder){ctx.shadowColor='#b8860b';ctx.fillStyle='#daa520';}
            else{ctx.shadowColor='#06b6d4';ctx.fillStyle='#67e8f9';}
        }
        else{ctx.shadowColor=this.color;ctx.fillStyle=this.color;}
        
        if (this.isTriangle) {
            // Draw triangle enemy
            this.rotation += 0.05;
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            ctx.beginPath();
            const s = this.radius;
            ctx.moveTo(0, -s);
            ctx.lineTo(s * 0.866, s * 0.5);
            ctx.lineTo(-s * 0.866, s * 0.5);
            ctx.closePath();
            ctx.fill();
        } else {
            ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.fill();
        }
        
        if (this.isBoss) {
            ctx.fillStyle='#fbbf24'; ctx.font='bold 10px Arial'; ctx.textAlign='center';
            ctx.fillText('BOSS',this.x,this.y-this.radius-4);
        }
        ctx.restore();
        
        // Draw HP bar in screen space (not affected by transforms)
        if(this.health<this.maxHealth){
            const bw=this.radius*2,bh=4,bx=this.x-this.radius,by=this.y-this.radius-10;
            ctx.fillStyle='rgba(0,0,0,.5)'; ctx.fillRect(bx,by,bw,bh);
            ctx.fillStyle='#22c55e'; ctx.fillRect(bx,by,bw*(this.health/this.maxHealth),bh);
        }
    }
}

class Boss {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.health = 1000;
        this.maxHealth = 1000;
        this.radius = 35;
        this.rotation = 0;
        this.alive = true;
        this.lastAttackTime = 0;
        this.vertexAttackCooldown = 3000; // 3 seconds in ms
        this.dashAttackCooldown = 0;
        this.summonCooldown = 0;
        this.dashInProgress = false;
        this.dashTargetX = 0;
        this.dashTargetY = 0;
    }
    
    update(dt = 1) {
        const ts = Date.now();
        
        // Always spin counter-clockwise
        this.rotation -= 0.03 * dt;
        
        // Update attack cooldowns
        this.lastAttackTime += dt;
        if (this.dashAttackCooldown > 0) this.dashAttackCooldown -= dt;
        if (this.summonCooldown > 0) this.summonCooldown -= dt;
        
        // Vertex attack every 3 seconds (all tiers)
        if (this.lastAttackTime > this.vertexAttackCooldown / 16.67) {
            this.fireVertexAttack();
            this.lastAttackTime = 0;
        }
        
        // Dash attack below 750 HP
        if (this.health < 750 && this.dashAttackCooldown <= 0 && !this.dashInProgress) {
            this.dashAttackCooldown = 4000; // 4 second cooldown
            this.startDashAttack();
        }
        
        // Handle dash movement
        if (this.dashInProgress) {
            const dx = this.dashTargetX - this.x;
            const dy = this.dashTargetY - this.y;
            const dist = Math.hypot(dx, dy);
            if (dist < 15) {
                this.dashInProgress = false;
                // Deal damage on impact
                enemies.forEach(e => {
                    if (!e.isBoss && !e.isTriangleMini) {
                        const d = Math.hypot(e.x - this.x, e.y - this.y);
                        if (d < 60) {
                            e.health -= 25;
                            if (e.health <= 0 && e.alive) { e.alive = false; player.kills++; gainExp(e.expValue); handleKill(e); }
                        }
                    }
                });
                if (Math.hypot(player.x - this.x, player.y - this.y) < 60 && player.invulnerable <= 0) {
                    player.health -= 25;
                    player.invulnerable = 30;
                    updateHUD();
                    if (player.health <= 0) endGame();
                }
            } else {
                this.x += (dx / dist) * 5 * dt;
                this.y += (dy / dist) * 5 * dt;
                for (let i = 0; i < 2; i++) particles.push(new Particle(this.x + (Math.random() - 0.5) * 40, this.y + (Math.random() - 0.5) * 40, '#dc2626'));
            }
        }
        
        // Summon attack below 300 HP
        if (this.health < 300 && this.summonCooldown <= 0) {
            this.summonCooldown = 5000; // 5 second cooldown
            this.spawnMiniTriangles();
        }
    }
    
    fireVertexAttack() {
        // Fire 3 bullets from each vertex of the spinning triangle
        for (let i = 0; i < 3; i++) {
            const angle = this.rotation + (Math.PI * 2 / 3) * i;
            const vx = this.x + Math.cos(angle) * this.radius;
            const vy = this.y + Math.sin(angle) * this.radius;
            
            const bulletAngle = Math.atan2(player.y - vy, player.x - vx);
            const bulletVx = Math.cos(bulletAngle) * 4;
            const bulletVy = Math.sin(bulletAngle) * 4;
            
            bossBullets.push({
                x: vx, y: vy, vx: bulletVx, vy: bulletVy, damage: 15, radius: 8, alive: true
            });
        }
        for (let i = 0; i < 20; i++) {
            particles.push(new Particle(this.x + (Math.random() - 0.5) * 80, this.y + (Math.random() - 0.5) * 80, '#dc2626'));
        }
    }
    
    startDashAttack() {
        this.dashInProgress = true;
        this.dashTargetX = player.x;
        this.dashTargetY = player.y;
    }
    
    spawnMiniTriangles() {
        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI * 2 / 6) * i;
            const x = this.x + Math.cos(angle) * 80;
            const y = this.y + Math.sin(angle) * 80;
            miniTriangles.push({
                x: x, y: y, vx: Math.cos(angle) * 4, vy: Math.sin(angle) * 4,
                rotation: 0, alive: true, radius: 10, health: 1
            });
        }
        for (let i = 0; i < 40; i++) {
            particles.push(new Particle(this.x, this.y, '#fca5a5'));
        }
    }
    
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        
        // Draw triangle
        ctx.fillStyle = '#dc2626';
        ctx.shadowBlur = 30;
        ctx.shadowColor = '#dc2626';
        ctx.beginPath();
        const size = this.radius;
        ctx.moveTo(0, -size);
        ctx.lineTo(size * 0.866, size * 0.5);
        ctx.lineTo(-size * 0.866, size * 0.5);
        ctx.closePath();
        ctx.fill();
        
        // Inner highlight
        ctx.fillStyle = '#ef4444';
        ctx.globalAlpha = 0.6;
        ctx.beginPath();
        ctx.moveTo(0, -size * 0.6);
        ctx.lineTo(size * 0.52, size * 0.3);
        ctx.lineTo(-size * 0.52, size * 0.3);
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
    }
}

class Particle {
    constructor(x,y,color){
        if(settings && !settings.particles){this.life=0;this.decay=1;this.x=x;this.y=y;this.radius=0;this.color=color;this.vx=0;this.vy=0;return;}this.x=x;this.y=y;this.vx=(Math.random()-.5)*10;this.vy=(Math.random()-.5)*10;this.radius=Math.random()*4+2;this.color=color;this.life=1;this.decay=Math.random()*.02+.02;}
    update(dt=1){this.x+=this.vx*dt;this.y+=this.vy*dt;this.vx*=Math.pow(.98,dt);this.vy*=Math.pow(.98,dt);this.life-=this.decay*dt;}
    draw(){ctx.save();ctx.globalAlpha=this.life;ctx.beginPath();ctx.arc(this.x,this.y,this.radius,0,Math.PI*2);ctx.fillStyle=this.color;ctx.fill();ctx.restore();}
}

class Item {
    constructor(x,y,type){this.x=x;this.y=y;this.type=type;this.radius=8;this.alive=true;this.color=type==='health'?'#22c55e':type==='aimassist'?'#fbbf24':'#8b5cf6';this.pulse=0;}
    update(dt=1){
        this.pulse+=0.1*dt;
        const dx=player.x-this.x, dy=player.y-this.y, dist=Math.sqrt(dx*dx+dy*dy);
        const magnetRange = (player.radius + this.radius) * (1 + passiveState.magnet * 3);
        if(passiveState.magnet>0 && dist < magnetRange && dist > player.radius+this.radius){
            const pullSpeed = 4 * passiveState.magnet * dt;
            this.x += (dx/dist)*pullSpeed; this.y += (dy/dist)*pullSpeed;
        }
        if(dist < this.radius+player.radius){
            if(this.type==='health')player.health=Math.min(player.health+30,player.maxHealth);
            else if(this.type==='aimassist'){
                if(passiveState.aimassist < 1) {
                    passiveState.aimassist = 1;
                    floatMoneyText('üéØ AIM ASSIST ACTIVATED!');
                    for(let i=0;i<30;i++)particles.push(new Particle(this.x,this.y,'#fbbf24'));
                }
            } else player.mana=Math.min(player.mana+20,player.maxMana);
            this.alive=false;updateHUD();
        }
    }
    draw(){const ps=Math.sin(this.pulse)*3;ctx.save();ctx.shadowBlur=20;ctx.shadowColor=this.color;ctx.beginPath();ctx.arc(this.x,this.y,this.radius+ps,0,Math.PI*2);ctx.fillStyle=this.color;ctx.fill();ctx.restore();}
}

function getDifficulty(){return Math.floor(currentRound/50);}
function getSpawnCount(){
    if(currentRound>=500 && currentRound<600) return 50; // 50 enemies total in final waves
    // Gradual difficulty from wave 50-499: scales from 1 to 8 enemies
    if(currentRound>=50 && currentRound<500) {
        const progress = (currentRound - 50) / 450; // 0 to 1 over waves 50-499
        return Math.min(1 + Math.floor(progress * 7), 8); // 1 to 8
    }
    return Math.min(1+getDifficulty(),8);
}
function getSpawnInterval(){
    if(currentRound>=500 && currentRound<600) return Math.max(600-Math.floor((currentRound-500)/5),120); // spawn every 0.6-2s in final waves
    // Gradual spawn rate increase from wave 50-499
    if(currentRound>=50 && currentRound<500) {
        const progress = (currentRound - 50) / 450; // 0 to 1
        return Math.max(1500 - progress * 1200, 300); // 1500ms down to 300ms
    }
    return Math.max(1500-getDifficulty()*80,300);
}
function getEnemyStats(type){
    const d=getDifficulty();
    if(type==='boss')return{health:10000+d*2000,speed:1.5+d*0.1,damage:20+d*5};
    if(type==='triangle')return{health:150,speed:3.5,damage:12};
    
    // Gradual enemy stat scaling from wave 50-499
    let healthMult = 1, speedMult = 1, damageMult = 1;
    if(currentRound>=50 && currentRound<500) {
        const progress = (currentRound - 50) / 450; // 0 to 1
        healthMult = 1 + progress * 0.5; // 1x to 1.5x
        speedMult = 1 + progress * 0.25; // 1x to 1.25x
        damageMult = 1 + progress * 0.33; // 1x to 1.33x
    }
    // Endgame scaling (waves 500-600)
    else if(currentRound>=500 && currentRound<600) {
        healthMult = 1.5;
        speedMult = 1.5;
        damageMult = 1.5;
    }
    
    return{
        health:(200+d*80)*healthMult, 
        speed:Math.min(2+Math.random()+d*0.15,6)*speedMult, 
        damage:(10+d*3)*damageMult
    };
}

function spawnWave(){
    // Spawn mini-bosses every 15 waves
    if(currentRound > 0 && currentRound % 15 === 0 && currentRound % 50 !== 0) {
        spawnMiniBosse();
        return;
    }
    
    // Check if we should spawn the main triangle boss every 50 waves
    if(currentRound > 0 && currentRound % 50 === 0) {
        spawnTheBoss();
        return;
    }
    
    const count=getSpawnCount();
    for(let i=0;i<count;i++){
        setTimeout(()=>{
            if(!gameRunning)return;
            const side=Math.floor(Math.random()*4);let x,y;
            if(side===0){x=Math.random()*canvas.width;y=-30;}
            else if(side===1){x=canvas.width+30;y=Math.random()*canvas.height;}
            else if(side===2){x=Math.random()*canvas.width;y=canvas.height+30;}
            else{x=-30;y=Math.random()*canvas.height;}
            
            // Spawn triangle enemies if boss was defeated
            const type = (triangleEnemyUnlocked && Math.random() < 0.3) ? 'triangle' : 'normal';
            const e=new Enemy(x,y,type);const stats=getEnemyStats(type);
            e.health=stats.health;e.maxHealth=stats.health;e.speed=stats.speed;e.damage=stats.damage;
            enemies.push(e);
        },i*120);
    }
}

function spawnMiniBosse() {
    // Spawn a mini-boss (tougher enemy) every 15 waves
    const side=Math.floor(Math.random()*4);let x,y;
    if(side===0){x=Math.random()*canvas.width;y=-30;}
    else if(side===1){x=canvas.width+30;y=Math.random()*canvas.height;}
    else if(side===2){x=Math.random()*canvas.width;y=canvas.height+30;}
    else{x=-30;y=Math.random()*canvas.height;}
    
    const miniBoss = new Enemy(x, y, 'normal');
    const difficulty = getDifficulty();
    miniBoss.health = 600 + difficulty * 300;
    miniBoss.maxHealth = miniBoss.health;
    miniBoss.speed = 2.5 + difficulty * 0.2;
    miniBoss.damage = 20 + difficulty * 5;
    miniBoss.radius = 22;
    miniBoss.color = '#ff6b6b';
    miniBoss.isMiniBoss = true;
    miniBoss.name = '‚öîÔ∏è Mini Boss';
    enemies.push(miniBoss);
    floatMoneyText(`‚öîÔ∏è MINI-BOSS SPAWNED!`);
}

function spawnTheBoss() {
    if(currentBoss) return;
    bossSpawned = true;
    const bossNumber = Math.floor(currentRound / 50);
    const healthMult = 1 + (bossNumber - 1) * 0.5; // 1x, 1.5x, 2x, etc.
    const speedMult = 1 + (bossNumber - 1) * 0.2;
    const damageMult = 1 + (bossNumber - 1) * 0.4;
    
    currentBoss = new Boss(canvas.width / 2, canvas.height / 2);
    currentBoss.health = Math.round(5000 * healthMult);
    currentBoss.maxHealth = currentBoss.health;
    // Increase attack frequency at higher difficulties
    currentBoss.vertexAttackCooldown = Math.max(1500, 3000 - bossNumber * 300);
    
    floatMoneyText(`üëπ THE TRIANGLE #${bossNumber} APPEARS! (${Math.round(healthMult*100)}% HP)`);
    for(let i=0;i<100;i++) particles.push(new Particle(currentBoss.x + (Math.random()-0.5)*100, currentBoss.y + (Math.random()-0.5)*100, '#dc2626'));
}

function shootProjectile(isAdmin=false){
    const angle=Math.atan2(mousePos.y-player.y,mousePos.x-player.x);
    const sk = CHARACTERS[currentCharacter];
    if (sk.isGoldHoarder) {
        const spread = (Math.random() - 0.5) * GH_SPREAD;
        const proj = new Projectile(player.x,player.y,angle+spread,GH_DAMAGE,sk.projColor,false,false,false);
        proj.isGoldHoarder = true;
        projectiles.push(proj);
    } else {
        fireWithPassives(angle);
    }
}

function doAdminAbility(idx) {
    if (!gameRunning) return;
    if (adminCooldowns[idx] > 0) return;
    adminCooldowns[idx] = ADMIN_CDS[idx];
    const ab = ADMIN_ABILITIES[idx];

    const mkParticle = (x,y,col) => { for(let i=0;i<25;i++) particles.push(new Particle(x,y,col)); };
    const rainCol = () => `hsl(${Math.random()*360},100%,60%)`;

    switch(ab.fn) {
        case 'admin_burst':
            for(let i=0;i<12;i++){
                const a=(Math.PI*2/12)*i;
                const p=new Projectile(player.x,player.y,a,player.damage*2,'#ffffff',true);
                p.isAdmin=true;p.hue=adminHue;projectiles.push(p);
            }
            mkParticle(player.x,player.y,'#ffffff'); break;

        case 'admin_explosion':
            for(let i=0;i<16;i++){const a=(Math.PI*2/16)*i;const p=new Projectile(player.x,player.y,a,player.damage*3,'#f97316',true);p.isAdmin=true;p.hue=adminHue;projectiles.push(p);}
            enemies.forEach(e=>{const dx=e.x-player.x,dy=e.y-player.y;if(Math.sqrt(dx*dx+dy*dy)<200)e.health-=player.damage*2;});
            mkParticle(player.x,player.y,'#ef4444'); break;

        case 'admin_freeze':
            enemies.forEach(e=>{e.frozen=180;mkParticle(e.x,e.y,'#67e8f9');});
            mkParticle(player.x,player.y,'#06b6d4'); break;

        case 'admin_chain':
            enemies.forEach(e=>{e.health-=player.damage*4;mkParticle(e.x,e.y,'#fbbf24');});
            mkParticle(player.x,player.y,'#eab308'); break;

        case 'admin_slam':
            enemies.forEach(e=>{const dx=e.x-player.x,dy=e.y-player.y;if(Math.sqrt(dx*dx+dy*dy)<350){e.alive=false;player.kills++;gainExp(e.expValue);handleKill(e);mkParticle(e.x,e.y,e.color);}});
            for(let i=0;i<300;i++)particles.push(new Particle(player.x,player.y,rainCol())); break;

        case 'admin_bow':
            for(let i=-2;i<=2;i++){const ang=Math.atan2(mousePos.y-player.y,mousePos.x-player.x)+i*0.15;const p=new Projectile(player.x,player.y,ang,player.damage*3,rainCol(),true,true);p.isAdmin=true;projectiles.push(p);}
            break;

        case 'admin_bloodgod':
            enemies.forEach(e=>{e.alive=false;player.kills++;gainExp(e.expValue);handleKill(e);for(let i=0;i<20;i++)particles.push(new Particle(e.x,e.y,'#ef4444'));});
            for(let i=0;i<400;i++)particles.push(new Particle(player.x,player.y,rainCol()));
            bloodGodAnnounce={timer:240}; break;

        case 'admin_nuke':
            enemies.forEach(e=>{e.alive=false;player.kills++;gainExp(e.expValue);handleKill(e);for(let i=0;i<30;i++)particles.push(new Particle(e.x,e.y,rainCol()));});
            player.health=player.maxHealth; player.mana=player.maxMana;
            for(let i=0;i<600;i++)particles.push(new Particle(Math.random()*canvas.width,Math.random()*canvas.height,rainCol()));
            floatMoneyText('‚ò¢Ô∏è ADMIN NUKE!');
            break;

        case 'admin_teleport':
            const oldX=player.x, oldY=player.y;
            player.x=Math.max(player.radius,Math.min(canvas.width-player.radius,mousePos.x));
            player.y=Math.max(player.radius,Math.min(canvas.height-player.radius,mousePos.y));
            player.invulnerable=30;
            for(let i=0;i<30;i++)particles.push(new Particle(oldX,oldY,rainCol()));
            for(let i=0;i<30;i++)particles.push(new Particle(player.x,player.y,rainCol()));
            break;
    }
    updateHUD();
}

function doGoldRush() {
    const sk = CHARACTERS[currentCharacter];
    if (player.mana < sk.manaCost) return;
    if (specialInProgress) return;
    player.mana -= sk.manaCost;
    specialInProgress = true;
    autoFireEnabled = false;
    const rad = 180;
    let converted = 0;
    enemies.forEach(e => {
        const dx = e.x - player.x, dy = e.y - player.y;
        if (Math.sqrt(dx*dx + dy*dy) < rad) {
            e.isGoldForm = true;
            e.originalColor = e.color;
            e.originalHealth = e.health;
            e.originalMaxHealth = e.maxHealth;
            e.color = '#fbbf24';
            e.health = e.maxHealth * 0.25; // 25% health
            e.frozen = 120; // freeze for 2 seconds
            e.goldFormTimer = 120; // 2 seconds
            converted++;
            for(let i=0;i<20;i++) particles.push(new Particle(e.x, e.y, '#fbbf24'));
            for(let i=0;i<10;i++) particles.push(new Particle(e.x, e.y, '#ca8a04'));
        }
    });
    for(let r=30;r<rad;r+=22) {
        for(let a=0;a<Math.PI*2;a+=0.18) {
            particles.push(new Particle(player.x+Math.cos(a)*r, player.y+Math.sin(a)*r, '#fbbf24'));
        }
    }
    if (converted > 0) floatMoneyText(`üí∞ ${converted} enemies turned to gold!`);
    else floatMoneyText('üí∏ Nothing in range...');
    updateHUD();
    setTimeout(()=>{ specialInProgress=false; autoFireEnabled=true; }, 600);
}

function specialAttack(){
    const sk=CHARACTERS[currentCharacter];
    if(sk.isMachineGun) return;
    if(sk.isGoldHoarder) { doGoldRush(); return; }
    if(sk.isAdmin) { doAdminAbility(0); return; }
    // YUJI: Dynamically change ability based on Sukuna transformation
    if(sk.isYuji && yujiIsSukuna) { sk.ability = 'malevolentshrine'; sk.manaCost = 0; }
    if(player.mana<sk.manaCost)return;
    if(sk.cdMax>0&&player.specialCooldown>0)return;
    if(specialInProgress&&sk.ability!=='bowshot')return;
    if(sk.ability==='domainexpansion'||sk.ability==='cursedslash'||sk.ability==='malevolentshrine'){player.mana=0;}else{player.mana-=sk.manaCost;}
    if(sk.cdMax>0)player.specialCooldown=sk.cdMax;
    switch(sk.ability){
        // ‚îÄ‚îÄ PHANTOM ‚Äî Ghost Walk ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        case 'ghostwalk': {
            phantomPhasing = true;
            phantomPhaseTimer = 240; // 4 seconds
            player.invulnerable = 240;
            player.speed *= 1.8;
            setTimeout(() => { player.speed /= 1.8; }, 4000);
            for(let i=0;i<40;i++) particles.push(new Particle(player.x, player.y, '#7dd3fc'));
            for(let r=20;r<120;r+=25) for(let a=0;a<Math.PI*2;a+=0.4) particles.push(new Particle(player.x+Math.cos(a)*r,player.y+Math.sin(a)*r,'#e0f2fe'));
            floatMoneyText('üëª GHOST WALK! 4s phasing!');
            break;
        }
        // ‚îÄ‚îÄ DRUID ‚Äî Mushroom Ring ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        case 'mushrooms': {
            const count = 5;
            for(let i=0;i<count;i++) {
                const a = (Math.PI*2/count)*i;
                const dist = 80;
                druidShrooms.push({ x: player.x+Math.cos(a)*dist, y: player.y+Math.sin(a)*dist, timer: 480, radius: 55 });
            }
            for(let i=0;i<60;i++) particles.push(new Particle(player.x, player.y, '#4ade80'));
            floatMoneyText('üçÑ Healing mushroom ring!');
            break;
        }
        // ‚îÄ‚îÄ PYROMANCER ‚Äî Meteor Strike ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        case 'meteor': {
            specialInProgress = true; autoFireEnabled = false;
            const tx = mousePos.x, ty = mousePos.y;
            // Visual telegraph: warning circle
            let countdown = 0;
            const warnDraw = setInterval(() => {
                ctx.save();
                ctx.strokeStyle = `rgba(251,146,60,${0.4+0.4*Math.sin(countdown*0.3)})`;
                ctx.lineWidth = 4; ctx.setLineDash([8,6]);
                ctx.beginPath(); ctx.arc(tx,ty,80,0,Math.PI*2); ctx.stroke();
                ctx.restore();
                countdown++;
            }, 16);
            setTimeout(() => {
                clearInterval(warnDraw);
                if (!gameRunning) { specialInProgress=false; autoFireEnabled=true; return; }
                // Impact!
                enemies.forEach(e => {
                    const d = Math.hypot(e.x-tx, e.y-ty);
                    if (d < 120) {
                        const falloff = 1 - (d/120)*0.4;
                        e.health -= player.damage * 8 * falloff;
                        if(e.burning !== undefined) e.burning = (e.burning||0)+120;
                        if(e.health<=0&&e.alive){e.alive=false;player.kills++;gainExp(e.expValue);handleKill(e);}
                    }
                });
                for(let i=0;i<120;i++) particles.push(new Particle(tx+(Math.random()-.5)*100,ty+(Math.random()-.5)*100,'#fb923c'));
                for(let i=0;i<60;i++)  particles.push(new Particle(tx+(Math.random()-.5)*80,ty+(Math.random()-.5)*80,'#fbbf24'));
                for(let i=0;i<40;i++)  particles.push(new Particle(tx,ty,'#c2410c'));
                floatMoneyText('‚òÑÔ∏è METEOR! 8x DMG!');
                specialInProgress=false; autoFireEnabled=true;
            }, 800);
            break;
        }
        // ‚îÄ‚îÄ CYBORG ‚Äî 360¬∞ Laser Sweep ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        case 'lasersweep': {
            specialInProgress = true; autoFireEnabled = false;
            let angle = 0;
            const sweepDmg = player.damage * 3.5;
            const sweepInterval = setInterval(() => {
                if (!gameRunning) { clearInterval(sweepInterval); return; }
                // Laser beam in current direction
                const bx2 = player.x + Math.cos(angle)*500, by2 = player.y + Math.sin(angle)*500;
                ctx.save();
                ctx.strokeStyle = `rgba(192,132,252,0.9)`; ctx.lineWidth = 6;
                ctx.shadowBlur = 24; ctx.shadowColor = '#7c3aed';
                ctx.beginPath(); ctx.moveTo(player.x,player.y); ctx.lineTo(bx2,by2); ctx.stroke();
                ctx.restore();
                enemies.forEach(e => {
                    // Point-to-line distance
                    const dx2 = bx2-player.x, dy2 = by2-player.y;
                    const t2 = Math.max(0,Math.min(1,((e.x-player.x)*dx2+(e.y-player.y)*dy2)/(dx2*dx2+dy2*dy2)));
                    const closestX = player.x+t2*dx2, closestY = player.y+t2*dy2;
                    if(Math.hypot(e.x-closestX,e.y-closestY) < e.radius+8) {
                        e.health -= sweepDmg * 0.04; // per frame of sweep
                        if(e.health<=0&&e.alive){e.alive=false;player.kills++;gainExp(e.expValue);handleKill(e);}
                    }
                });
                angle += 0.06;
            }, 16);
            setTimeout(() => {
                clearInterval(sweepInterval);
                for(let i=0;i<60;i++) particles.push(new Particle(player.x, player.y, '#7c3aed'));
                floatMoneyText('ü§ñ LASER SWEEP!');
                specialInProgress=false; autoFireEnabled=true;
            }, 1400);
            break;
        }
        // ‚îÄ‚îÄ TIME WIZARD ‚Äî Rewind HP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        case 'rewindtime': {
            if (timeWizardSnapshot && timeWizardSnapshot.health > player.health) {
                const healed = timeWizardSnapshot.health - player.health;
                player.health = timeWizardSnapshot.health;
                updateHUD();
                for(let i=0;i<80;i++) particles.push(new Particle(player.x+(Math.random()-.5)*60, player.y+(Math.random()-.5)*60, '#d8b4fe'));
                floatMoneyText(`‚è≥ REWIND! +${Math.round(healed)} HP!`);
            } else if (timeWizardSnapshot) {
                floatMoneyText('‚è≥ No damage to rewind!');
            } else {
                floatMoneyText('‚è≥ Wait 5s for snapshot...');
            }
            break;
        }
        case 'veteran': {
            specialInProgress=true; autoFireEnabled=false;
            const t = VETERAN_TIERS[veteranTier];
            const count = [8, 12, 16, 20, 32][veteranTier];
            const dmg = player.damage * t.dmgMult;
            for(let i=0;i<count;i++) {
                const p = new Projectile(player.x,player.y,(Math.PI*2/count)*i,dmg,t.projColor,true);
                projectiles.push(p);
            }
            if(veteranTier >= 2) enemies.forEach(e=>{const d=Math.hypot(e.x-player.x,e.y-player.y);if(d<160)e.health-=dmg*0.5;});
            if(veteranTier >= 3) enemies.forEach(e=>{const d=Math.hypot(e.x-player.x,e.y-player.y);if(d<250)e.frozen=90;});
            if(veteranTier >= 4) enemies.forEach(e=>{const d=Math.hypot(e.x-player.x,e.y-player.y);if(d<350)e.health-=dmg*2;});
            for(let i=0;i<30+veteranTier*20;i++) particles.push(new Particle(player.x,player.y,t.color));
            floatMoneyText(`‚öîÔ∏è ${t.name}: ${t.label}!`);
            setTimeout(()=>{specialInProgress=false;autoFireEnabled=true;},500); break;
        }
        case 'reinforce': {
            if (!builderWalls.length) {
                floatMoneyText('üèóÔ∏è No walls to reinforce!');
                break;
            }
            let nearest = null, nDist = Infinity;
            builderWalls.forEach(w => {
                const d = Math.hypot(w.x + w.w/2 - player.x, w.y + w.h/2 - player.y);
                if (d < nDist) { nDist = d; nearest = w; }
            });
            if (nearest) {
                nearest.reinforced = true;
                nearest.maxHp *= 2;
                nearest.hp = nearest.maxHp;
                for(let i=0;i<40;i++) particles.push(new Particle(nearest.x + nearest.w/2, nearest.y + nearest.h/2, '#d2691e'));
                floatMoneyText('üèóÔ∏è Wall reinforced!');
            }
            break;
        }
        case 'inferno': {
            specialInProgress=true; autoFireEnabled=false;
            enemies.forEach(e=>{
                e.burning = (e.burning||0) + 180;
                e.burnDmg = player.damage * 0.4;
                for(let i=0;i<15;i++) particles.push(new Particle(e.x,e.y,'#ff4500'));
                for(let i=0;i<8;i++)  particles.push(new Particle(e.x,e.y,'#fbbf24'));
            });
            for(let i=0;i<16;i++) {
                const p = new Projectile(player.x,player.y,(Math.PI*2/16)*i,player.damage*2.5,'#ff4500',true);
                p.isFire=true; projectiles.push(p);
            }
            for(let r=30;r<220;r+=35) for(let a=0;a<Math.PI*2;a+=0.2) particles.push(new Particle(player.x+Math.cos(a)*r,player.y+Math.sin(a)*r,'#ff4500'));
            floatMoneyText('üî• INFERNO!');
            setTimeout(()=>{specialInProgress=false;autoFireEnabled=true;},800); break;
        }
        case 'dashpunch': {
            specialInProgress=true; autoFireEnabled=false;
            const dx = mousePos.x - player.x;
            const dy = mousePos.y - player.y;
            const dist = Math.hypot(dx, dy);
            const angle = dist > 0 ? Math.atan2(dy, dx) : 0;
            const dashDist = 150;
            const dashX = player.x + Math.cos(angle) * dashDist;
            const dashY = player.y + Math.sin(angle) * dashDist;
            const punchDmg = player.damage * 1.5;
            
            // Damage enemies in the path
            enemies.forEach(e => {
                const d = Math.hypot(e.x - player.x, e.y - player.y);
                if (d < dashDist + e.radius) {
                    e.health -= punchDmg;
                    if (e.health <= 0 && e.alive) { e.alive = false; player.kills++; gainExp(e.expValue); handleKill(e); }
                    for(let i=0;i<12;i++) particles.push(new Particle(e.x, e.y, '#fca5a5'));
                }
            });
            
            // Dash animation
            let dashProgress = 0;
            const dashInterval = setInterval(() => {
                if (!gameRunning) { clearInterval(dashInterval); return; }
                dashProgress += 0.1;
                if (dashProgress >= 1) {
                    clearInterval(dashInterval);
                    player.x = dashX;
                    player.y = dashY;
                    for(let i=0;i<40;i++) particles.push(new Particle(player.x, player.y, '#dc2626'));
                    floatMoneyText('üí™ POWER DASH!');
                    specialInProgress = false; autoFireEnabled = true;
                    return;
                }
                player.x = player.x + (dashX - player.x) * 0.15;
                player.y = player.y + (dashY - player.y) * 0.15;
                for(let i=0;i<5;i++) particles.push(new Particle(player.x + (Math.random()-0.5)*40, player.y + (Math.random()-0.5)*40, '#fca5a5'));
            }, 16);
            break;
        }
        case 'blizzard': {
            specialInProgress=true; autoFireEnabled=false;
            enemies.forEach(e=>{
                const d=Math.hypot(e.x-player.x,e.y-player.y);
                if(d<350){ e.frozen=240; for(let i=0;i<20;i++) particles.push(new Particle(e.x,e.y,'#e0f7ff')); }
            });
            firePatches.push({x:player.x,y:player.y,radius:140,timer:300,maxTimer:300,isBlizzard:true,dmgPerTick:player.damage*0.3});
            for(let i=0;i<80;i++) particles.push(new Particle(player.x,player.y,'#67e8f9'));
            for(let r=20;r<200;r+=30) for(let a=0;a<Math.PI*2;a+=0.25) particles.push(new Particle(player.x+Math.cos(a)*r,player.y+Math.sin(a)*r,'#e0f7ff'));
            floatMoneyText('‚ùÑÔ∏è BLIZZARD!');
            setTimeout(()=>{specialInProgress=false;autoFireEnabled=true;},600); break;
        }
        case 'overload': {
            overloadCharges = 8;
            for(let i=0;i<60;i++) particles.push(new Particle(player.x,player.y,'#facc15'));
            for(let i=0;i<40;i++) particles.push(new Particle(player.x,player.y,'#a855f7'));
            floatMoneyText('‚ö° OVERLOAD x8!');
            break;
        }
        case 'groundslam':
            specialInProgress=true;autoFireEnabled=false;
            const slamR=280;
            enemies.forEach(e=>{const dx=e.x-player.x,dy=e.y-player.y;if(Math.sqrt(dx*dx+dy*dy)<slamR){e.alive=false;player.kills++;gainExp(e.expValue);handleKill(e);showDeathMsg(e.name,sk.msgSpecial);for(let i=0;i<20;i++)particles.push(new Particle(e.x,e.y,e.color));}});
            for(let i=0;i<200;i++)particles.push(new Particle(player.x,player.y,'#a855f7'));
            for(let r=60;r<slamR;r+=50)for(let a=0;a<Math.PI*2;a+=0.15)particles.push(new Particle(player.x+Math.cos(a)*r,player.y+Math.sin(a)*r,'#c084fc'));
            setTimeout(()=>{specialInProgress=false;autoFireEnabled=true;},700);break;
        case 'bowshot':
            const bAngle=Math.atan2(mousePos.y-player.y,mousePos.x-player.x);
            projectiles.push(new Projectile(player.x,player.y,bAngle,player.damage*2,sk.projColor,true,true));break;
        case 'bloodgod':
            specialInProgress=true;autoFireEnabled=false;
            enemies.forEach(e=>{e.alive=false;player.kills++;gainExp(e.expValue);handleKill(e);showDeathMsg(e.name,sk.msgSpecial);for(let i=0;i<25;i++)particles.push(new Particle(e.x,e.y,'#ef4444'));for(let i=0;i<10;i++)particles.push(new Particle(e.x,e.y,'#7c3aed'));});
            for(let i=0;i<300;i++)particles.push(new Particle(player.x,player.y,'#ef4444'));
            for(let i=0;i<100;i++)particles.push(new Particle(player.x,player.y,'#991b1b'));
            for(let i=0;i<80;i++)particles.push(new Particle(player.x,player.y,'#7c3aed'));
            bloodGodAnnounce={timer:240};
            setTimeout(()=>{specialInProgress=false;autoFireEnabled=true;},800);break;
        case 'randomspecial': {
            // Dice random special ‚Äî pick a random ability (exclude ones that need specific passives/setups)
            // Excluded: ghostwalk (needs phantom phasing), rewindtime (needs snapshots), reinforce (builder walls), bowshot (eggchan only)
            const validAbilities = [
                'mushrooms', 'meteor', 'lasersweep',
                'inferno', 'dashpunch', 'blizzard', 'overload', 'groundslam', 'bloodgod', 'veteran'
            ];
            
            // Random mana cost (1 to current maxMana)
            const randomManaCost = 1 + Math.floor(Math.random() * player.maxMana);
            // Random cooldown (1 to 120 frames, roughly 1-2 seconds)
            const randomCooldown = 1 + Math.floor(Math.random() * 120);
            
            if(player.mana < randomManaCost) {
                floatMoneyText(`üé≤ Not enough mana! Need ${randomManaCost}/${player.maxMana}`);
                break;
            }
            
            player.mana -= randomManaCost;
            player.specialCooldown = randomCooldown;
            
            const randomAbility = validAbilities[Math.floor(Math.random() * validAbilities.length)];
            floatMoneyText(`üé≤ Dice rolled: ${randomAbility}! (${randomManaCost} mana, ${(randomCooldown/60).toFixed(1)}s CD)`);
            // Trigger that ability
            sk.ability = randomAbility;
            specialAttack();
            sk.ability = 'randomspecial'; // restore original
            break;
        }
        case 'domainexpansion': {
            // HAKARI DOMAIN EXPANSION
            if (hakariDomainActive) {
                floatMoneyText('Domain already active!');
                break;
            }
            if (hakariJackpotActive) {
                floatMoneyText('Cannot pop domain during jackpot!');
                break;
            }
            if (hakariJackpotCooldown > 0) {
                floatMoneyText(`Domain cooldown: ${Math.ceil(hakariJackpotCooldown/60)}s`);
                break;
            }
            
            hakariDomainActive = true;
            hakariDomainTimer = 3600; // 60 seconds = 3600 frames at 60fps
            hakariRollCount = 0;
            hakariRollTimer = 0;
            
            floatMoneyText('üé∞ DOMAIN EXPANSION!');
            for(let i=0;i<100;i++) particles.push(new Particle(player.x, player.y, '#ec4899'));
            for(let r=30;r<200;r+=40) for(let a=0;a<Math.PI*2;a+=0.3) particles.push(new Particle(player.x+Math.cos(a)*r, player.y+Math.sin(a)*r, '#7c3aed'));
            
            break;
        }
        case 'toolswap': {
            // TOJI FUSHIGURO ‚Äî Tool Swap between modes
            if(!tojiToolMode) tojiToolMode = 'sharp';
            if(tojiToolMode === 'sharp') {
                // Switch to Heavy mode
                tojiToolMode = 'heavy';
                player.speedBoost = 0;
                tojiHeavyModeTimer = 120; // 2 seconds
                floatMoneyText('ü™µ HEAVY MODE: +20% DMG, 50% SLOW');
                for(let i=0;i<30;i++) particles.push(new Particle(player.x + (Math.random()-0.5)*60, player.y + (Math.random()-0.5)*60, '#8b6914'));
                // Slow nearby enemies
                enemies.forEach(e => {
                    if(Math.hypot(e.x - player.x, e.y - player.y) < 300) {
                        e.slowTimer = 120;
                        e.slowAmount = 0.5;
                    }
                });
            } else {
                // Switch to Sharp mode
                tojiToolMode = 'sharp';
                tojiSharpModeTimer = 180; // 3 seconds
                floatMoneyText('‚öîÔ∏è SHARP MODE: +30% DMG');
                for(let i=0;i<30;i++) particles.push(new Particle(player.x + (Math.random()-0.5)*60, player.y + (Math.random()-0.5)*60, '#f59e0b'));
            }
            break;
        }
        case 'cursedslash': {
            // YUJI ITADORI normal attack (before Sukuna transformation)
            for(let a=0;a<Math.PI*2;a+=0.4) {
                const p = new Projectile(player.x, player.y, a, player.damage, '#e84d4d', true);
                projectiles.push(p);
            }
            for(let i=0;i<20;i++) particles.push(new Particle(player.x, player.y, '#e84d4d'));
            break;
        }
        case 'malevolentshrine': {
            // SUKUNA MALEVOLENT SHRINE - activate continuous damage effect
            if(sukunaMalevolentCooldown > 0) {
                floatMoneyText('Malevolent Shrine on cooldown!');
                break;
            }
            
            sukunaMalevolentActive = true;
            sukunaMalevolentTimer = 180; // visual effect for 3 seconds
            sukunaMalevolentCooldown = 300; // 5 second cooldown (300 frames at 60fps)
            
            floatMoneyText('MALEVOLENT SHRINE');
            for(let i=0;i<100;i++) particles.push(new Particle(player.x + (Math.random()-0.5)*300, player.y + (Math.random()-0.5)*300, '#8b0000'));
            break;
        }
    }
    for(let i=0;i<15;i++)particles.push(new Particle(player.x,player.y,sk.color));
    updateHUD();
}

function dash(){
    if(player.dashCooldown>0)return;
    const sk = CHARACTERS[currentCharacter];
    if(sk.isVampire || sk.isAdmin || sk.isDice){
        const oldX=player.x, oldY=player.y;
        player.x=Math.max(player.radius,Math.min(canvas.width-player.radius,mousePos.x));
        player.y=Math.max(player.radius,Math.min(canvas.height-player.radius,mousePos.y));
        player.dashCooldown=sk.isAdmin?30:60; player.invulnerable=15;
        for(let i=0;i<25;i++)particles.push(new Particle(oldX,oldY,sk.isAdmin?`hsl(${Math.random()*360},100%,60%)`:sk.isDice?'#f97316':'#7f1d1d'));
        for(let i=0;i<25;i++)particles.push(new Particle(player.x,player.y,sk.isAdmin?`hsl(${Math.random()*360},100%,60%)`:sk.isDice?'#ea580c':'#ef4444'));
    } else {
        const angle=Math.atan2(mousePos.y-player.y,mousePos.x-player.x);
        player.x+=Math.cos(angle)*80;player.y+=Math.sin(angle)*80;
        player.dashCooldown=60;player.invulnerable=10;
        for(let i=0;i<20;i++)particles.push(new Particle(player.x,player.y,CHARACTERS[currentCharacter].color));
    }
}

function handleKill(e) {
    if(Math.random()<0.3)items.push(new Item(e.x,e.y,Math.random()<0.5?'health':'mana'));
    if(passiveState.aimassist < 1 && Math.random() < 0.25) {
        items.push(new Item(e.x, e.y, 'aimassist'));
    }
    if(CHARACTERS[currentCharacter].isVampire){ player.health=Math.min(player.health+8,player.maxHealth); for(let i=0;i<8;i++)particles.push(new Particle(e.x,e.y,'#ef4444')); }
    
    // YUJI ITADORI: 5% chance to drop Sukuna Finger
    if(currentCharacter === 'yuji_itadori' && Math.random() < 0.05 && yujiSukunaFingers < 20) {
        yujiSukunaFingers++;
        floatMoneyText(`ü©∏ Sukuna Finger ${yujiSukunaFingers}/20`);
        for(let i=0;i<15;i++) particles.push(new Particle(e.x, e.y, '#8b0000'));
        // Check if transformed to Sukuna at 20 fingers
        if(yujiSukunaFingers >= 20 && !yujiIsSukuna) {
            yujiIsSukuna = true;
            floatMoneyText('SUKUNA AWAKENED!');
            for(let i=0;i<100;i++) particles.push(new Particle(player.x + (Math.random()-0.5)*200, player.y + (Math.random()-0.5)*200, '#8b0000'));
        }
    }
    
    if(passiveState.lifesteal>0){ player.health=Math.min(player.health+passiveState.lifesteal,player.maxHealth); updateHUD(); }
    // Gold enemy bonus: 10x money
    if(e.isGoldForm) { earnRunGold(10); earnMoney(10, 'gold enemy'); }
    else { earnRunGold(1); }
    if(e.isBoss) { earnMoney(5, 'boss kill'); }
    killStreak++;
    if(killStreak % 10 === 0) {
        earnMoney(2, `${killStreak} kill streak!`);
        const sd = document.getElementById('streakDisplay');
        sd.textContent = `üî• ${killStreak} KILL STREAK! +$2`;
        sd.style.opacity='1';
        clearTimeout(sd._to);
        sd._to = setTimeout(()=>sd.style.opacity='0', 2000);
    }
    updateHUD();
}

function gainExp(amount){
    player.exp+=amount;
    if(player.exp>=expToNextLevel){
        player.level++;player.exp-=expToNextLevel;expToNextLevel=Math.floor(expToNextLevel*1.5);
        earnMoney(10, `level ${player.level}!`);
        if(player.level===10) earnMoney(50, 'Level 10 milestone!');
        showLevelUp();
    }
    updateHUD();
}

function showLevelUp(){
    gameRunning=false;
    const dmgBtn = document.getElementById('damageUpgradeBtn');
    const manaBtn = document.querySelector('.upgrade-btn[onclick*="mana"]');
    const isDice = currentCharacter === 'dice';
    const isMG = CHARACTERS[currentCharacter].isMachineGun;
    
    if (isMG || isDice) {
        dmgBtn.classList.add('disabled-upgrade');
        dmgBtn.textContent = isDice ? 'üé≤ Damage Locked (Dice!)' : 'üîí Damage Locked (MG)';
        dmgBtn.onclick = () => {};
    } else {
        dmgBtn.classList.remove('disabled-upgrade');
        dmgBtn.textContent = '‚öîÔ∏è +5 Damage';
        dmgBtn.onclick = () => upgrade('damage');
    }
    
    if (isDice) {
        manaBtn.classList.add('disabled-upgrade');
        manaBtn.textContent = 'üé≤ Mana Locked (Dice!)';
        manaBtn.onclick = () => {};
    } else {
        manaBtn.classList.remove('disabled-upgrade');
        manaBtn.textContent = 'üíß +20 Max Mana';
        manaBtn.onclick = () => upgrade('mana');
    }
    
    document.getElementById('levelUpNotice').classList.add('show');
}

function upgrade(type){
    if(type==='health'){player.maxHealth+=30;player.health=player.maxHealth;}
    else if(type==='damage'){if(!CHARACTERS[currentCharacter].isMachineGun)player.damage+=5;}
    else if(type==='speed')player.speed+=1;
    else if(type==='mana'){player.maxMana+=20;player.mana=player.maxMana;}
    document.getElementById('levelUpNotice').classList.remove('show');
    gameRunning=true;updateHUD();requestAnimationFrame(gameLoop);
}

function updateAdminKeys() {
    const cont = document.getElementById('adminKeys');
    if(currentCharacter !== 'admin') { cont.style.display='none'; return; }
    cont.style.display='flex';
    cont.innerHTML = '';
    ADMIN_ABILITIES.forEach((ab,i) => {
        const cd = adminCooldowns[i];
        const el = document.createElement('div');
        el.className = 'admin-key';
        const hue = (i/9)*360;
        el.style.borderColor = `hsl(${hue},100%,60%)`;
        el.style.color = cd>0 ? '#666' : `hsl(${hue},100%,60%)`;
        el.innerHTML = `[${ab.key}] ${ab.icon}<br>${ab.name}<br>${cd>0?Math.ceil(cd/60)+'s':'RDY'}`;
        cont.appendChild(el);
    });
}

function updateHUD(){
    document.getElementById('level').textContent=player.level;
    document.getElementById('health').textContent=`${Math.max(0,Math.floor(player.health))}/${player.maxHealth}`;
    document.getElementById('mana').textContent=`${Math.floor(player.mana)}/${player.maxMana}`;
    document.getElementById('exp').textContent=`${player.exp}/${expToNextLevel}`;
    document.getElementById('kills').textContent=player.kills;
    document.getElementById('hudMoney').textContent='üí∞'+runGold+' (gold)';
    document.getElementById('healthBar').style.width=(player.health/player.maxHealth*100)+'%';
    document.getElementById('manaBar').style.width=(player.mana/player.maxMana*100)+'%';
    document.getElementById('expBar').style.width=(player.exp/expToNextLevel*100)+'%';
    
    // Boss health bar
    if (currentBoss && currentBoss.alive) {
        document.getElementById('bossHealthBar').style.display='block';
        const bossPercent = (currentBoss.health / currentBoss.maxHealth) * 100;
        document.getElementById('bossHealthFill').style.width = bossPercent + '%';
        document.getElementById('bossHealthText').textContent = Math.ceil(currentBoss.health) + '/' + currentBoss.maxHealth;
    } else {
        document.getElementById('bossHealthBar').style.display='none';
    }
    
    const sk=CHARACTERS[currentCharacter],rEl=document.getElementById('rReady'),rLabel=document.getElementById('rLabel');
    if(!sk){currentCharacter='default';savePersistentData();return;}
    if(currentCharacter==='dream'||currentCharacter==='technoblade'||currentCharacter==='admin'){
        const tier=getDreamArmorTier(),nextTier=DREAM_ARMOR_TIERS[DREAM_ARMOR_TIERS.indexOf(tier)+1];
        if(rLabel)rLabel.textContent='ARMOR';rEl.style.fontSize='7px';rEl.style.color=tier.glow;rEl.textContent=tier.name;
        const ab=document.getElementById('armorBar'),af=document.getElementById('armorBarFill');
        if(ab)ab.style.display='block';
        if(af){const pct=nextTier?Math.min(((player.kills-tier.kills)/(nextTier.kills-tier.kills))*100,100):100;af.style.width=pct+'%';af.style.background=tier.glow;}
    } else if(sk.isVeteran){
        if(rLabel)rLabel.textContent='EVOLVE';const ab=document.getElementById('armorBar'),af=document.getElementById('armorBarFill');
        const t=VETERAN_TIERS[veteranTier];
        rEl.style.fontSize='7px';rEl.style.color=t.color;
        rEl.textContent=player.mana<sk.manaCost?'LOW':t.name;
        if(ab)ab.style.display='block';
        if(af){const pct=veteranTier>=VETERAN_TIERS.length-1?100:Math.min((veteranTimer/1800)*100,100);af.style.width=pct+'%';af.style.background=t.color;}
    } else if(sk.isPhantom){
        if(rLabel)rLabel.textContent='GHOST'; const ab=document.getElementById('armorBar');if(ab)ab.style.display='none';
        rEl.style.fontSize='7px';
        if(phantomPhasing){rEl.style.color='#7dd3fc';rEl.textContent='PHASINGüëª';}
        else if(sk.cdMax>0&&player.specialCooldown>0){rEl.style.color='#ef4444';rEl.textContent=(player.specialCooldown/60).toFixed(1)+'s';}
        else if(player.mana<sk.manaCost){rEl.style.color='#6b7280';rEl.textContent='LOW';}
        else{rEl.style.color='#38bdf8';rEl.textContent='READYüëª';}
    } else if(sk.isDruid){
        if(rLabel)rLabel.textContent='MUSHROOM'; const ab2=document.getElementById('armorBar');if(ab2)ab2.style.display='none';
        rEl.style.fontSize='7px';
        if(player.mana<sk.manaCost){rEl.style.color='#6b7280';rEl.textContent='LOW MANA';}
        else{rEl.style.color='#4ade80';rEl.textContent=`üçÑ x${druidShrooms.length}`;}
    } else if(sk.isPyromancer){
        if(rLabel)rLabel.textContent='METEOR'; const ab3=document.getElementById('armorBar');if(ab3)ab3.style.display='none';
        rEl.style.fontSize='7px';
        if(pyroCharging){const pct=Math.min(pyroChargeTimer/180,1);rEl.style.color=`rgb(${Math.round(251-pct*51)},${Math.round(146-pct*100)},60)`;rEl.textContent=`${Math.round(pct*100)}%üîÆ`;}
        else if(player.mana<sk.manaCost){rEl.style.color='#6b7280';rEl.textContent='LOW';}
        else{rEl.style.color='#fb923c';rEl.textContent='‚òÑÔ∏è READY';}
    } else if(sk.isCyborg){
        if(rLabel)rLabel.textContent='LASER'; const ab4=document.getElementById('armorBar');if(ab4)ab4.style.display='none';
        rEl.style.fontSize='7px';
        if(player.mana<sk.manaCost){rEl.style.color='#6b7280';rEl.textContent='LOW';}
        else{rEl.style.color=cyborgMode==='rapid'?'#38bdf8':'#c084fc';rEl.textContent=cyborgMode==='rapid'?'‚ö° RAPID':'üí• HEAVY';}
    } else if(sk.isTimeWizard){
        if(rLabel)rLabel.textContent='REWIND'; const ab5=document.getElementById('armorBar');if(ab5)ab5.style.display='none';
        rEl.style.fontSize='7px';
        if(sk.cdMax>0&&player.specialCooldown>0){rEl.style.color='#ef4444';rEl.textContent=(player.specialCooldown/60).toFixed(1)+'s';}
        else if(player.mana<sk.manaCost){rEl.style.color='#6b7280';rEl.textContent='LOW';}
        else if(!timeWizardSnapshot){rEl.style.color='#9ca3af';rEl.textContent='‚è≥ WAIT...';}
        else{rEl.style.color='#d8b4fe';rEl.textContent='‚è≥ READY';}
    } else if(sk.isElectric){
        if(rLabel)rLabel.textContent='OVERLOAD';const ab=document.getElementById('armorBar');if(ab)ab.style.display='none';
        if(overloadCharges>0){rEl.style.fontSize='7px';rEl.style.color='#facc15';rEl.textContent=`‚ö°x${overloadCharges}`;}
        else if(player.mana<sk.manaCost){rEl.style.fontSize='7px';rEl.style.color='#6b7280';rEl.textContent='LOW';}
        else{rEl.style.fontSize='7px';rEl.style.color='#a855f7';rEl.textContent='READY ‚ö°';}
    } else if(sk.isGoldHoarder){
        if(rLabel)rLabel.textContent='GOLD RUSH';const ab=document.getElementById('armorBar');if(ab)ab.style.display='none';
        if(player.mana<sk.manaCost){rEl.style.fontSize='7px';rEl.style.color='#6b7280';rEl.textContent='LOW MANA';}
        else{rEl.style.fontSize='7px';rEl.style.color='#fbbf24';rEl.textContent='READY ü™ô';}
    } else if(sk.isMachineGun){
        if(rLabel)rLabel.textContent='FIRE';const ab=document.getElementById('armorBar');if(ab)ab.style.display='none';
        rEl.style.fontSize='7px';rEl.style.color='#9ca3af';rEl.textContent='1 DMG';
    } else if(sk.isVampire){
        if(rLabel)rLabel.textContent='PASSIVE';const ab=document.getElementById('armorBar');if(ab)ab.style.display='none';
        rEl.style.fontSize='7px';rEl.style.color='#ef4444';rEl.textContent='+8 HP/kill';
    } else {
        if(rLabel)rLabel.textContent='R KEY';rEl.style.fontSize='';const ab=document.getElementById('armorBar');if(ab)ab.style.display='none';
        if(sk.cdMax>0&&player.specialCooldown>0){rEl.textContent=(player.specialCooldown/60).toFixed(1)+'s';rEl.style.color='#ef4444';}
        else if(player.mana<sk.manaCost){rEl.textContent='LOW';rEl.style.color='#6b7280';}
        else{rEl.textContent='READY';rEl.style.color='#22c55e';}
    }
    updateAdminKeys();
}

function updateSkinOverlay(ts) {
    const sk = CHARACTERS[currentCharacter];
    if (!sk || !sk.useImg || sk.isAdmin) { skinOverlay.style.display='none'; return; }
    const r = player.radius;
    skinOverlay.style.display = 'block';
    skinOverlay.style.left  = (player.x - r) + 'px';
    skinOverlay.style.top   = (player.y - r) + 'px';
    skinOverlay.style.width  = (r*2) + 'px';
    skinOverlay.style.height = (r*2) + 'px';
    if (skinOverlay.getAttribute('data-skin') !== currentCharacter) {
        skinOverlay.src = SKIN_URLS[currentCharacter] || '';
        skinOverlay.setAttribute('data-skin', currentCharacter);
    }
    skinOverlay.style.opacity = (player.invulnerable>0 && Math.floor(ts/100)%2===0) ? '0.4' : '1';
    let glowColor = sk.shadow;
    if (currentCharacter==='dream'||currentCharacter==='technoblade') glowColor = getDreamArmorTier().glow || sk.shadow;
    skinOverlay.style.boxShadow = `0 0 16px 6px ${glowColor}`;
    skinOverlay.style.border    = `2px solid ${glowColor}`;
}

function endGame(){
    gameRunning=false; skinOverlay.style.display='none';
    const milestoneBonus = Math.floor(currentRound/50)*25;
    const roundBonus = currentRound;
    const total = roundBonus + milestoneBonus;
    if(milestoneBonus > 0) floatMoneyText(`+$${milestoneBonus} milestone bonus!`);
    totalMoney += total; sessionMoney += total; savePersistentData();
    document.getElementById('gameOver').style.display='block';
    document.getElementById('finalLevel').textContent=player.level;
    document.getElementById('finalKills').textContent=player.kills;
    document.getElementById('finalWave').textContent=currentRound;
    document.getElementById('moneyEarned').textContent=sessionMoney;
}
function restartGame(){document.getElementById('gameOver').style.display='none';resetGame();gameRunning=true;requestAnimationFrame(gameLoop);}



const NAV_CELL = 20;
let navGrid = null;
let navCols = 0, navRows = 0;

function navBuild() {
    const W = canvas.width, H = canvas.height;
    navCols = Math.ceil(W / NAV_CELL);
    navRows = Math.ceil(H / NAV_CELL);
    navGrid = [];
    for (let r = 0; r < navRows; r++) {
        navGrid[r] = [];
        for (let c = 0; c < navCols; c++) {
            const wx = c * NAV_CELL + NAV_CELL / 2;
            const wy = r * NAV_CELL + NAV_CELL / 2;
            const margin = 30;
            let blocked = false;
            for (const w of walls) {
                if (wx + margin > w.x && wx - margin < w.x + w.w &&
                    wy + margin > w.y && wy - margin < w.y + w.h) {
                    blocked = true; break;
                }
            }
            navGrid[r][c] = !blocked;
        }
    }
}

function navWorldToCell(wx, wy) {
    return {
        c: Math.max(0, Math.min(navCols - 1, Math.floor(wx / NAV_CELL))),
        r: Math.max(0, Math.min(navRows - 1, Math.floor(wy / NAV_CELL)))
    };
}
function navCellToWorld(c, r) {
    return { wx: c * NAV_CELL + NAV_CELL / 2, wy: r * NAV_CELL + NAV_CELL / 2 };
}

function navRayBlocked(x1, y1, x2, y2) {
    if (!navGrid) return false;
    const steps = Math.ceil(Math.hypot(x2 - x1, y2 - y1) / (NAV_CELL * 0.5));
    for (let i = 1; i < steps; i++) {
        const t = i / steps;
        const wx = x1 + (x2 - x1) * t, wy = y1 + (y2 - y1) * t;
        const { c, r } = navWorldToCell(wx, wy);
        if (!navGrid[r] || !navGrid[r][c]) return true;
    }
    return false;
}

function navFindPath(sx, sy, ex, ey) {
    if (!navGrid) return null;
    const start = navWorldToCell(sx, sy);
    const end   = navWorldToCell(ex, ey);

    if (start.c === end.c && start.r === end.r) return null;

    const key = (c, r) => r * navCols + c;
    const h   = (c, r) => Math.hypot(c - end.c, r - end.r);

    const open   = new Map();
    const closed = new Set();
    const gScore = new Map();
    const fScore = new Map();
    const cameFrom = new Map();

    const sk = key(start.c, start.r);
    gScore.set(sk, 0);
    fScore.set(sk, h(start.c, start.r));
    open.set(sk, { c: start.c, r: start.r });

    const DIRS = [
        [1,0],[-1,0],[0,1],[0,-1],
        [1,1],[1,-1],[-1,1],[-1,-1]
    ];

    let iterations = 0;
    while (open.size > 0 && iterations++ < 1200) {
        let bestKey = null, bestF = Infinity;
        for (const [k] of open) {
            const f = fScore.get(k) ?? Infinity;
            if (f < bestF) { bestF = f; bestKey = k; }
        }
        const cur = open.get(bestKey);
        open.delete(bestKey);

        if (cur.c === end.c && cur.r === end.r) {
            const path = [];
            let k = bestKey;
            while (cameFrom.has(k)) {
                const node = cameFrom.get(k);
                path.unshift(navCellToWorld(node.c, node.r));
                k = key(node.c, node.r);
            }
            path.push(navCellToWorld(end.c, end.r));
            return navStringPull(path, sx, sy);
        }

        closed.add(bestKey);

        for (const [dc, dr] of DIRS) {
            const nc = cur.c + dc, nr = cur.r + dr;
            if (nc < 0 || nc >= navCols || nr < 0 || nr >= navRows) continue;
            if (!navGrid[nr][nc]) continue;
            if (dc !== 0 && dr !== 0) {
                if (!navGrid[cur.r + dr] || !navGrid[cur.r + dr][cur.c]) continue;
                if (!navGrid[cur.r]      || !navGrid[cur.r][cur.c + dc]) continue;
            }
            const nk = key(nc, nr);
            if (closed.has(nk)) continue;
            const moveCost = (dc !== 0 && dr !== 0) ? 1.414 : 1;
            const tentG = (gScore.get(bestKey) ?? Infinity) + moveCost;
            if (tentG < (gScore.get(nk) ?? Infinity)) {
                cameFrom.set(nk, cur);
                gScore.set(nk, tentG);
                fScore.set(nk, tentG + h(nc, nr));
                open.set(nk, { c: nc, r: nr });
            }
        }
    }
    return null;
}

function navStringPull(waypoints, startX, startY) {
    if (!waypoints || waypoints.length === 0) return waypoints;
    const result = [];
    let cx = startX, cy = startY;
    let i = 0;
    while (i < waypoints.length) {
        let furthest = i;
        for (let j = i + 1; j < waypoints.length; j++) {
            if (!navRayBlocked(cx, cy, waypoints[j].wx, waypoints[j].wy)) furthest = j;
            else break;
        }
        result.push(waypoints[furthest]);
        cx = waypoints[furthest].wx;
        cy = waypoints[furthest].wy;
        i = furthest + 1;
    }
    return result;
}

let walls = [];

const WALL_THICKNESS = 14;
const SAFE_RADIUS = 120;

function generateWalls() {
    walls = [];
    const W = canvas.width, H = canvas.height;
    const PAD = 30;
    const GAP = 8;
    const SAFE_R = SAFE_RADIUS;

    function overlapsExisting(x, y, w, h) {
        for (const wl of walls) {
            if (x - GAP < wl.x + wl.w && x + w + GAP > wl.x &&
                y - GAP < wl.y + wl.h && y + h + GAP > wl.y) return true;
        }
        return false;
    }

    function tryAdd(x, y, w, h) {
        x = Math.round(x); y = Math.round(y);
        if (x < PAD) x = PAD;
        if (y < PAD) y = PAD;
        if (x + w > W - PAD) x = W - PAD - w;
        if (y + h > H - PAD) y = H - PAD - h;
        if (w <= 0 || h <= 0) return false;
        const cx = x + w/2, cy = y + h/2;
        if (Math.hypot(cx - W/2, cy - H/2) < SAFE_R) return false;
        if (overlapsExisting(x, y, w, h)) return false;
        walls.push({ x, y, w, h });
        return true;
    }

    function scatterRandom(count, minLen, maxLen) {
        let placed = 0, attempts = 0;
        while (placed < count && attempts < count * 12) {
            attempts++;
            const horiz = Math.random() > 0.5;
            const len = minLen + Math.random() * (maxLen - minLen);
            const wx = PAD + Math.random() * (W - PAD*2 - (horiz ? len : WALL_THICKNESS));
            const wy = PAD + Math.random() * (H - PAD*2 - (horiz ? WALL_THICKNESS : len));
            if (tryAdd(wx, wy, horiz ? len : WALL_THICKNESS, horiz ? WALL_THICKNESS : len)) placed++;
        }
    }

    const layout = Math.floor(Math.random() * 5);

    if (layout === 0) {
        scatterRandom(22, 55, 160);
    } else if (layout === 1) {
        const hLen = 120, vLen = 90;
        [0.22, 0.78].forEach(fx => [0.22, 0.78].forEach(fy => {
            tryAdd(W*fx - hLen/2, H*fy - WALL_THICKNESS/2, hLen, WALL_THICKNESS);
            tryAdd(W*fx - WALL_THICKNESS/2, H*fy - vLen/2, WALL_THICKNESS, vLen);
        }));
        tryAdd(W*0.5 - 60, H*0.18, 120, WALL_THICKNESS);
        tryAdd(W*0.5 - 60, H*0.82 - WALL_THICKNESS, 120, WALL_THICKNESS);
        tryAdd(W*0.12, H*0.5 - 45, WALL_THICKNESS, 90);
        tryAdd(W*0.88 - WALL_THICKNESS, H*0.5 - 45, WALL_THICKNESS, 90);
        scatterRandom(10, 50, 110);
    } else if (layout === 2) {
        const g1 = H * 0.35, g2 = H * 0.65;
        const longLen = 280;
        tryAdd(PAD+20, g1 - 80, longLen, WALL_THICKNESS);
        tryAdd(PAD+20, g1 + 80, longLen, WALL_THICKNESS);
        tryAdd(W - PAD - 20 - longLen, g2 - 80, longLen, WALL_THICKNESS);
        tryAdd(W - PAD - 20 - longLen, g2 + 80, longLen, WALL_THICKNESS);
        tryAdd(W*0.5 - 8, H*0.1,  WALL_THICKNESS, H*0.25);
        tryAdd(W*0.5 - 8, H*0.65, WALL_THICKNESS, H*0.25);
        scatterRandom(12, 50, 100);
    } else if (layout === 3) {
        const corners = [[PAD+10, PAD+10], [W-PAD-130, PAD+10], [PAD+10, H-PAD-100], [W-PAD-130, H-PAD-100]];
        corners.forEach(([cx, cy]) => {
            tryAdd(cx,      cy,      120, WALL_THICKNESS);
            tryAdd(cx,      cy,      WALL_THICKNESS, 90);
        });
        const bx = W*0.3, by = H*0.25, bw = W*0.4, bh = H*0.5;
        const seg = 80;
        tryAdd(bx, by, seg, WALL_THICKNESS);
        tryAdd(bx+bw-seg, by, seg, WALL_THICKNESS);
        tryAdd(bx, by+bh, seg, WALL_THICKNESS);
        tryAdd(bx+bw-seg, by+bh, seg, WALL_THICKNESS);
        tryAdd(bx, by+seg, WALL_THICKNESS, bh-seg*2);
        tryAdd(bx+bw, by+seg, WALL_THICKNESS, bh-seg*2);
        scatterRandom(10, 50, 100);
    } else {
        const cols = 5, rows = 4;
        const cw = (W - PAD*2) / cols, ch = (H - PAD*2) / rows;
        for (let col = 0; col < cols; col++) {
            for (let row = 0; row < rows; row++) {
                if (Math.random() > 0.45) {
                    const horiz = Math.random() > 0.5;
                    const len = 70 + Math.random() * 90;
                    const wx = PAD + col * cw + 10 + Math.random() * Math.max(0, cw - len - 20);
                    const wy = PAD + row * ch + 10 + Math.random() * Math.max(0, ch - WALL_THICKNESS - 20);
                    tryAdd(wx, wy, horiz ? len : WALL_THICKNESS, horiz ? WALL_THICKNESS : len);
                }
            }
        }
        scatterRandom(6, 50, 90);
    }
    navBuild();
}

function drawWalls() {
    walls.forEach(w => {
        ctx.save();
        ctx.shadowBlur = 12;
        ctx.shadowColor = 'rgba(100,180,255,0.35)';
        ctx.fillStyle = '#1e3a5f';
        ctx.fillRect(w.x, w.y, w.w, w.h);
        ctx.fillStyle = 'rgba(100,180,255,0.25)';
        ctx.fillRect(w.x, w.y, w.w, 2);
        ctx.fillRect(w.x, w.y, 2, w.h);
        ctx.fillStyle = 'rgba(0,0,0,0.4)';
        ctx.fillRect(w.x, w.y + w.h - 2, w.w, 2);
        ctx.fillRect(w.x + w.w - 2, w.y, 2, w.h);
        ctx.restore();
    });
    // Draw builder walls
    builderWalls.forEach(w => {
        ctx.save();
        ctx.shadowBlur = 12;
        ctx.shadowColor = w.reinforced ? 'rgba(210,105,30,0.6)' : 'rgba(160,82,45,0.5)';
        ctx.fillStyle = w.reinforced ? '#d2691e' : '#a0522d';
        ctx.fillRect(w.x, w.y, w.w, w.h);
        // HP bar
        const barW = w.w;
        const barH = 4;
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(w.x, w.y - 8, barW, barH);
        const hpPct = w.hp / w.maxHp;
        ctx.fillStyle = hpPct > 0.5 ? '#22c55e' : (hpPct > 0.25 ? '#fbbf24' : '#ef4444');
        ctx.fillRect(w.x, w.y - 8, barW * hpPct, barH);
        // Border
        ctx.strokeStyle = w.reinforced ? 'rgba(255,165,0,0.8)' : 'rgba(210,105,30,0.6)';
        ctx.lineWidth = 2;
        ctx.strokeRect(w.x, w.y, w.w, w.h);
        ctx.restore();
    });
}

function resolveCircleWall(cx, cy, radius) {
    let nx = cx, ny = cy;
    walls.forEach(w => {
        const nearX = Math.max(w.x, Math.min(w.x + w.w, nx));
        const nearY = Math.max(w.y, Math.min(w.y + w.h, ny));
        const dx = nx - nearX, dy = ny - nearY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < radius && dist > 0) {
            const overlap = radius - dist;
            nx += (dx / dist) * overlap;
            ny += (dy / dist) * overlap;
        } else if (dist === 0) {
            const overlapX = (nx < w.x + w.w/2) ? (nx - w.x) : (w.x + w.w - nx);
            const overlapY = (ny < w.y + w.h/2) ? (ny - w.y) : (w.y + w.h - ny);
            if (overlapX < overlapY) nx += (nx < w.x + w.w/2) ? -overlapX - radius : overlapX + radius;
            else ny += (ny < w.y + w.h/2) ? -overlapY - radius : overlapY + radius;
        }
    });
    // Builder walls collision
    builderWalls.forEach(w => {
        const nearX = Math.max(w.x, Math.min(w.x + w.w, nx));
        const nearY = Math.max(w.y, Math.min(w.y + w.h, ny));
        const dx = nx - nearX, dy = ny - nearY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < radius && dist > 0) {
            const overlap = radius - dist;
            nx += (dx / dist) * overlap;
            ny += (dy / dist) * overlap;
        } else if (dist === 0) {
            const overlapX = (nx < w.x + w.w/2) ? (nx - w.x) : (w.x + w.w - nx);
            const overlapY = (ny < w.y + w.h/2) ? (ny - w.y) : (w.y + w.h - ny);
            if (overlapX < overlapY) nx += (nx < w.x + w.w/2) ? -overlapX - radius : overlapX + radius;
            else ny += (ny < w.y + w.h/2) ? -overlapY - radius : overlapY + radius;
        }
    });
    return { x: nx, y: ny };
}

function projectileHitsWall(proj) {
    if (proj.isPhantom) return false; // phantom shots phase through walls
    let hit = walls.some(w => {
        const nearX = Math.max(w.x, Math.min(w.x + w.w, proj.x));
        const nearY = Math.max(w.y, Math.min(w.y + w.h, proj.y));
        const dist = Math.hypot(proj.x - nearX, proj.y - nearY);
        return dist < proj.radius + 1;
    });
    // Builder walls collision
    if (!hit) {
        hit = builderWalls.some(w => {
            const nearX = Math.max(w.x, Math.min(w.x + w.w, proj.x));
            const nearY = Math.max(w.y, Math.min(w.y + w.h, proj.y));
            const dist = Math.hypot(proj.x - nearX, proj.y - nearY);
            if (dist < proj.radius + 1) {
                // Wall takes damage from projectile
                w.hp -= 5;
                if (w.hp <= 0) {
                    builderWalls = builderWalls.filter(bw => bw !== w);
                    for(let i=0;i<30;i++) particles.push(new Particle(w.x + w.w/2, w.y + w.h/2, '#d2691e'));
                }
                return true;
            }
            return false;
        });
    }
    return hit;
}

function resetGame(){
    player=resetPlayerObj();
    if(currentCharacter==='technoblade'){player.maxMana=200;player.mana=200;}
    if(currentCharacter==='admin'){player.maxHealth=500;player.health=500;player.maxMana=9999;player.mana=9999;player.damage=100;player.speed=7;}
    if(currentCharacter==='dice'){
        player.speed=3+Math.random()*5; // 3-8 speed
        player.maxHealth=Math.round(80+Math.random()*95); // 80-175 health
        player.health=player.maxHealth;
        player.damage=Math.round(10+Math.random()*140); // 10-150 damage
    }
    expToNextLevel=100;projectiles=[];enemies=[];particles=[];items=[];floatingTexts=[];
    walls=[];generateWalls();
    // Builder spawns initial walls
    if(currentCharacter==='builder'){
        builderWalls=[];
        const positions=[[150,150],[canvas.width-150,150],[150,canvas.height-150],[canvas.width-150,canvas.height-150]];
        positions.forEach(([x,y])=>{
            builderWalls.push({x:x-25,y:y-25,w:50,h:50,hp:50,maxHp:50,reinforced:false});
        });
    } else {
        builderWalls=[];
    }
    lastEnemySpawn=0;roundTimer=0;currentRound=0;killStreak=0;sessionMoney=0;
    scheduleDailyCodeWave();
    autoFireEnabled=true;specialInProgress=false;
    dreamArmorAnnounce=null;lastDreamTierIdx=-1;bloodGodAnnounce=null;
    mgLastShot=0; adminHue=0; adminCooldowns=[0,0,0,0,0,0,0,0,0]; lastTs=0;
    runGold=0; activeAbilities=[]; activePassives=[]; lastShopWave=0; shopRerollCost=30;
    turrets=[]; pendingAirstrikes=[]; firePatches=[]; overloadCharges=0;
    veteranTier=0; veteranTimer=0;
    // new character state
    phantomPhasing=false; phantomPhaseTimer=0;
    druidShrooms=[]; druidRoots=[];
    pyroCharging=false; pyroChargeTimer=0;
    cyborgMode='rapid';
    timeWizardSnapshot=null; timeWizardSnapshotTimer=0;
    lastNewCharShot=0;
    // Boss reset
    currentBoss=null; bossBullets=[]; miniTriangles=[]; bossSpawned=false; triangleEnemyUnlocked=false;
    passiveState={lifesteal:0,thorns:0,regen:0,manaflow:0,armor:0,magnet:0,explosive:0,crit:0,multishot:0,ghostly:0,goldmag:0,overclock:0,trishot:0,homingshot:0,novaleak:0,aimassist:0,novaHitCount:0,berserkerActive:false,berserkerTimer:0,timeslowActive:false,timeslowTimer:0,regenTimer:0,trishotTimer:0,homingTimer:0,blackholeActive:false,blackholeTimer:0};
    // Hakari reset
    hakariDomainActive = false;
    hakariDomainTimer = 0;
    hakariRollTimer = 0;
    hakariRollCount = 0;
    hakariJackpotActive = false;
    hakariJackpotTimer = 0;
    hakariJackpotCooldown = 0;
    // Yuji reset
    yujiSukunaFingers = 0;
    yujiIsSukuna = false;
    sukunaMalevolentActive = false;
    sukunaMalevolentTimer = 0;
    sukunaMalevolentCooldown = 0;
    document.getElementById('deathFeed').innerHTML='';updateHUD();
}

function drawPlayer(ts, dt=1){
    const sk=CHARACTERS[currentCharacter];
    adminHue = (adminHue + 2*dt) % 360;

    if(currentCharacter === 'default') {
        const t = VETERAN_TIERS[veteranTier];
        ctx.save();
        if(player.invulnerable>0&&Math.floor(ts/100)%2===0)ctx.globalAlpha=0.5;
        ctx.shadowBlur=20+veteranTier*8; ctx.shadowColor=t.shadow;
        ctx.beginPath();ctx.arc(player.x,player.y,player.radius,0,Math.PI*2);ctx.fillStyle=t.color;ctx.fill();
        const ang=Math.atan2(mousePos.y-player.y,mousePos.x-player.x);
        ctx.fillStyle='white';ctx.shadowBlur=0;
        ctx.beginPath();ctx.arc(player.x+Math.cos(ang)*8,player.y+Math.sin(ang)*8,5,0,Math.PI*2);ctx.fill();
        if(veteranTier>0){
            ctx.save();ctx.translate(player.x,player.y);ctx.rotate(ts*0.002*(1+veteranTier*0.3));
            ctx.strokeStyle=t.projColor;ctx.lineWidth=2+veteranTier;
            ctx.setLineDash([6,4]);ctx.beginPath();ctx.arc(0,0,player.radius+6+veteranTier*2,0,Math.PI*2);ctx.stroke();
            ctx.restore();
        }
        if(veteranTier>=2){
            ctx.font=`bold 9px Arial`;ctx.textAlign='center';ctx.fillStyle=t.color;
            ctx.fillText(t.name,player.x,player.y-player.radius-6);
        }
        ctx.restore();
        return;
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // PHANTOM
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if(currentCharacter === 'phantom') {
        ctx.save();
        const stealthAlpha = phantomPhasing ? 0.35 : 1;
        if(player.invulnerable>0&&Math.floor(ts/100)%2===0) ctx.globalAlpha=stealthAlpha*0.4;
        else ctx.globalAlpha=stealthAlpha;
        const grad=ctx.createRadialGradient(player.x-4,player.y-5,2,player.x,player.y,player.radius);
        grad.addColorStop(0,'#f0f9ff'); grad.addColorStop(0.5,'#7dd3fc'); grad.addColorStop(1,'#0369a1');
        ctx.shadowBlur=phantomPhasing?35:18; ctx.shadowColor='#38bdf8';
        ctx.beginPath();ctx.arc(player.x,player.y,player.radius,0,Math.PI*2);ctx.fillStyle=grad;ctx.fill();
        ctx.font='13px Arial';ctx.textAlign='center';ctx.fillText('üëª',player.x,player.y+5);
        if(phantomPhasing){
            ctx.globalAlpha=0.5;ctx.save();ctx.translate(player.x,player.y);ctx.rotate(-ts*0.009);
            ctx.strokeStyle='#bae6fd';ctx.lineWidth=2;ctx.setLineDash([4,6]);
            ctx.beginPath();ctx.arc(0,0,player.radius+8,0,Math.PI*2);ctx.stroke();ctx.restore();
        }
        ctx.restore(); return;
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // DRUID
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if(currentCharacter === 'druid') {
        ctx.save();
        if(player.invulnerable>0&&Math.floor(ts/100)%2===0) ctx.globalAlpha=0.5;
        const grad=ctx.createRadialGradient(player.x-4,player.y-4,2,player.x,player.y,player.radius);
        grad.addColorStop(0,'#bbf7d0'); grad.addColorStop(0.5,'#16a34a'); grad.addColorStop(1,'#052e16');
        ctx.shadowBlur=20; ctx.shadowColor='#4ade80';
        ctx.beginPath();ctx.arc(player.x,player.y,player.radius,0,Math.PI*2);ctx.fillStyle=grad;ctx.fill();
        // orbiting leaves
        for(let i=0;i<4;i++){
            const a=(Math.PI*2/4)*i+ts*0.003;
            const ox=Math.cos(a)*(player.radius+10), oy=Math.sin(a)*(player.radius+10);
            ctx.font='10px Arial';ctx.textAlign='center';ctx.fillText(['üçÉ','üåø','üçÄ','üå±'][i],player.x+ox,player.y+oy+4);
        }
        ctx.font='11px Arial';ctx.textAlign='center';ctx.fillText('üåø',player.x,player.y+4);
        ctx.restore(); return;
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // PYROMANCER
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if(currentCharacter === 'pyromancer') {
        ctx.save();
        if(player.invulnerable>0&&Math.floor(ts/100)%2===0) ctx.globalAlpha=0.5;
        const flicker=0.85+0.15*Math.sin(ts*0.025);
        const pct=pyroCharging?Math.min(pyroChargeTimer/180,1):0;
        const grad=ctx.createRadialGradient(player.x-5,player.y-5,2,player.x,player.y,player.radius);
        grad.addColorStop(0,'#fff7ed'); grad.addColorStop(0.4,`rgb(${Math.round(194+pct*61)},65,12)`); grad.addColorStop(1,'#431407');
        ctx.shadowBlur=(20+pct*30)*flicker; ctx.shadowColor='#fb923c';
        ctx.beginPath();ctx.arc(player.x,player.y,player.radius*(1+pct*0.15),0,Math.PI*2);ctx.fillStyle=grad;ctx.fill();
        ctx.font='12px Arial';ctx.textAlign='center';ctx.fillStyle='#fff7ed';ctx.shadowBlur=0;
        ctx.fillText('üîÆ',player.x,player.y+5);
        // charge ring
        if(pyroCharging&&pct>0){
            ctx.save();ctx.translate(player.x,player.y);ctx.rotate(ts*0.01*flicker);
            ctx.strokeStyle=`rgba(251,146,60,${pct})`;ctx.lineWidth=2+pct*5;
            ctx.setLineDash([5,3]);ctx.beginPath();ctx.arc(0,0,player.radius+8+pct*10,0,Math.PI*2);ctx.stroke();
            ctx.restore();
        }
        ctx.restore(); return;
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // CYBORG
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if(currentCharacter === 'cyborg') {
        ctx.save();
        if(player.invulnerable>0&&Math.floor(ts/100)%2===0) ctx.globalAlpha=0.5;
        const isRapid = cyborgMode==='rapid';
        const c1 = isRapid ? '#38bdf8' : '#c084fc';
        const c2 = isRapid ? '#0ea5e9' : '#7c3aed';
        const grad=ctx.createRadialGradient(player.x-4,player.y-4,2,player.x,player.y,player.radius);
        grad.addColorStop(0,isRapid?'#bae6fd':'#ede9fe'); grad.addColorStop(0.5,c1); grad.addColorStop(1,c2);
        ctx.shadowBlur=20; ctx.shadowColor=c1;
        ctx.beginPath();ctx.arc(player.x,player.y,player.radius,0,Math.PI*2);ctx.fillStyle=grad;ctx.fill();
        // rotating circuit ring
        ctx.save();ctx.translate(player.x,player.y);ctx.rotate(ts*(isRapid?0.008:0.003));
        ctx.strokeStyle=c1;ctx.lineWidth=2;
        ctx.setLineDash(isRapid?[2,3]:[8,4]);
        ctx.beginPath();ctx.arc(0,0,player.radius+6,0,Math.PI*2);ctx.stroke();
        ctx.restore();
        ctx.font='12px Arial';ctx.textAlign='center';ctx.fillText('ü§ñ',player.x,player.y+5);
        ctx.restore(); return;
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // TIME WIZARD
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if(currentCharacter === 'timewizard') {
        ctx.save();
        if(player.invulnerable>0&&Math.floor(ts/100)%2===0) ctx.globalAlpha=0.5;
        const grad=ctx.createRadialGradient(player.x-4,player.y-4,2,player.x,player.y,player.radius);
        grad.addColorStop(0,'#faf5ff'); grad.addColorStop(0.5,'#d8b4fe'); grad.addColorStop(1,'#4c1d95');
        ctx.shadowBlur=22; ctx.shadowColor='#a78bfa';
        ctx.beginPath();ctx.arc(player.x,player.y,player.radius,0,Math.PI*2);ctx.fillStyle=grad;ctx.fill();
        // dual rotating rings (clockwise + anticlockwise ‚Äî "time spinning")
        ctx.save();ctx.translate(player.x,player.y);ctx.rotate(ts*0.005);
        ctx.strokeStyle='rgba(167,139,250,0.7)';ctx.lineWidth=2;ctx.setLineDash([6,5]);
        ctx.beginPath();ctx.arc(0,0,player.radius+7,0,Math.PI*2);ctx.stroke();ctx.restore();
        ctx.save();ctx.translate(player.x,player.y);ctx.rotate(-ts*0.004);
        ctx.strokeStyle='rgba(216,180,254,0.4)';ctx.lineWidth=1.5;ctx.setLineDash([3,8]);
        ctx.beginPath();ctx.arc(0,0,player.radius+13,0,Math.PI*2);ctx.stroke();ctx.restore();
        ctx.font='12px Arial';ctx.textAlign='center';ctx.fillText('‚è≥',player.x,player.y+5);
        ctx.restore(); return;
    }

    if(currentCharacter === 'fire') {
        ctx.save();
        if(player.invulnerable>0&&Math.floor(ts/100)%2===0)ctx.globalAlpha=0.5;
        const flicker = 0.85 + 0.15*Math.sin(ts*0.02);
        const grad=ctx.createRadialGradient(player.x-5,player.y-5,2,player.x,player.y,player.radius);
        grad.addColorStop(0,'#fff7ed'); grad.addColorStop(0.4,'#ff4500'); grad.addColorStop(1,'#7f1d1d');
        ctx.shadowBlur=30*flicker; ctx.shadowColor='#ff4500';
        ctx.beginPath();ctx.arc(player.x,player.y,player.radius,0,Math.PI*2);ctx.fillStyle=grad;ctx.fill();
        ctx.save();ctx.translate(player.x,player.y);ctx.rotate(ts*0.004);
        ctx.strokeStyle=`rgba(255,69,0,${0.6*flicker})`;ctx.lineWidth=3;
        ctx.setLineDash([5,3]);ctx.beginPath();ctx.arc(0,0,player.radius+7,0,Math.PI*2);ctx.stroke();
        ctx.restore();
        ctx.restore();
        return;
    }

    if(currentCharacter === 'ice') {
        ctx.save();
        if(player.invulnerable>0&&Math.floor(ts/100)%2===0)ctx.globalAlpha=0.5;
        const grad=ctx.createRadialGradient(player.x-6,player.y-6,2,player.x,player.y,player.radius);
        grad.addColorStop(0,'#f0f9ff'); grad.addColorStop(0.5,'#67e8f9'); grad.addColorStop(1,'#0891b2');
        ctx.shadowBlur=28; ctx.shadowColor='#67e8f9';
        ctx.beginPath();ctx.arc(player.x,player.y,player.radius,0,Math.PI*2);ctx.fillStyle=grad;ctx.fill();
        ctx.save();ctx.translate(player.x,player.y);ctx.rotate(ts*0.0025);
        ctx.strokeStyle='#e0f7ff';ctx.lineWidth=2;
        ctx.setLineDash([3,5]);ctx.beginPath();ctx.arc(0,0,player.radius+8,0,Math.PI*2);ctx.stroke();
        ctx.restore();
        const ang=Math.atan2(mousePos.y-player.y,mousePos.x-player.x);
        ctx.strokeStyle='#e0f7ff';ctx.lineWidth=2;ctx.setLineDash([]);
        ctx.beginPath();ctx.moveTo(player.x+Math.cos(ang)*12,player.y+Math.sin(ang)*12);
        ctx.lineTo(player.x+Math.cos(ang)*22,player.y+Math.sin(ang)*22);ctx.stroke();
        ctx.restore();
        return;
    }

    if(currentCharacter === 'electric') {
        ctx.save();
        if(player.invulnerable>0&&Math.floor(ts/100)%2===0)ctx.globalAlpha=0.5;
        const pulse=0.7+0.3*Math.sin(ts*0.025);
        const grad=ctx.createRadialGradient(player.x,player.y,2,player.x,player.y,player.radius);
        grad.addColorStop(0,'#fef9c3'); grad.addColorStop(0.5,'#facc15'); grad.addColorStop(1,'#7c3aed');
        ctx.shadowBlur=25*pulse; ctx.shadowColor=overloadCharges>0?'#ffffff':'#a855f7';
        ctx.beginPath();ctx.arc(player.x,player.y,player.radius,0,Math.PI*2);ctx.fillStyle=grad;ctx.fill();
        if(overloadCharges>0){
            ctx.save();ctx.translate(player.x,player.y);ctx.rotate(ts*0.012);
            ctx.strokeStyle='#ffffff';ctx.lineWidth=3;ctx.setLineDash([2,3]);
            ctx.beginPath();ctx.arc(0,0,player.radius+10,0,Math.PI*2);ctx.stroke();
            ctx.restore();
            ctx.font='bold 9px Arial';ctx.textAlign='center';ctx.fillStyle='#facc15';
            ctx.fillText(`‚ö°${overloadCharges}`,player.x,player.y-player.radius-6);
        } else {
            ctx.save();ctx.translate(player.x,player.y);ctx.rotate(ts*0.005);
            ctx.strokeStyle=`rgba(250,204,21,${0.5*pulse})`;ctx.lineWidth=2;ctx.setLineDash([4,4]);
            ctx.beginPath();ctx.arc(0,0,player.radius+7,0,Math.PI*2);ctx.stroke();
            ctx.restore();
        }
        ctx.restore();
        return;
    }

    if(currentCharacter === 'admin') {
        ctx.save();
        if(player.invulnerable>0&&Math.floor(ts/100)%2===0)ctx.globalAlpha=0.5;
        const grad = ctx.createRadialGradient(player.x-6,player.y-6,2,player.x,player.y,player.radius);
        const h = adminHue;
        grad.addColorStop(0,`hsl(${h},100%,80%)`);
        grad.addColorStop(0.5,`hsl(${(h+120)%360},100%,60%)`);
        grad.addColorStop(1,`hsl(${(h+240)%360},100%,40%)`);
        ctx.shadowBlur=40; ctx.shadowColor=`hsl(${h},100%,60%)`;
        ctx.beginPath();ctx.arc(player.x,player.y,player.radius,0,Math.PI*2);
        ctx.fillStyle=grad; ctx.fill();
        ctx.font='16px Arial'; ctx.textAlign='center';
        ctx.fillText('üëë',player.x,player.y-player.radius-2);
        ctx.save();ctx.translate(player.x,player.y);ctx.rotate(ts*0.003);
        ctx.strokeStyle=`hsl(${(h+180)%360},100%,70%)`;ctx.lineWidth=3;
        ctx.setLineDash([5,5]);ctx.beginPath();ctx.arc(0,0,player.radius+8,0,Math.PI*2);ctx.stroke();
        ctx.restore();
        ctx.save();ctx.translate(player.x,player.y);ctx.rotate(-ts*0.005);
        ctx.strokeStyle=`hsl(${h},100%,70%)`;ctx.lineWidth=2;
        ctx.setLineDash([3,8]);ctx.beginPath();ctx.arc(0,0,player.radius+14,0,Math.PI*2);ctx.stroke();
        ctx.restore();
        ctx.restore();
        return;
    }

    if(currentCharacter === 'goldhoarder') {
        ctx.save();
        if(player.invulnerable>0&&Math.floor(ts/100)%2===0)ctx.globalAlpha=0.5;
        const grad = ctx.createRadialGradient(player.x-5,player.y-5,2,player.x,player.y,player.radius);
        grad.addColorStop(0,'#fef08a');
        grad.addColorStop(0.5,'#eab308');
        grad.addColorStop(1,'#92400e');
        ctx.shadowBlur=25; ctx.shadowColor='#fbbf24';
        ctx.beginPath();ctx.arc(player.x,player.y,player.radius,0,Math.PI*2);
        ctx.fillStyle=grad; ctx.fill();
        ctx.font='bold 14px Arial'; ctx.textAlign='center'; ctx.shadowBlur=0;
        ctx.fillStyle='#92400e';
        ctx.fillText('$',player.x+1,player.y+5);
        ctx.save();ctx.translate(player.x,player.y);ctx.rotate(ts*0.0008);
        ctx.strokeStyle='#fbbf24';ctx.lineWidth=2;
        ctx.setLineDash([4,6]);ctx.beginPath();ctx.arc(0,0,player.radius+7,0,Math.PI*2);ctx.stroke();
        ctx.restore();
        ctx.restore();
        return;
    }

    if(!sk.useImg){
        ctx.save();
        if(player.invulnerable>0&&Math.floor(ts/100)%2===0)ctx.globalAlpha=0.5;
        ctx.shadowBlur=30;ctx.shadowColor=sk.shadow;
        ctx.beginPath();ctx.arc(player.x,player.y,player.radius,0,Math.PI*2);ctx.fillStyle=sk.color;ctx.fill();
        if (sk.isVampire) {
            const ang=Math.atan2(mousePos.y-player.y,mousePos.x-player.x);
            const ex=player.x+Math.cos(ang)*8, ey=player.y+Math.sin(ang)*8;
            const perpX=-Math.sin(ang)*4, perpY=Math.cos(ang)*4;
            ctx.fillStyle='#ef4444';ctx.shadowBlur=10;ctx.shadowColor='#ef4444';
            ctx.beginPath();ctx.arc(ex+perpX,ey+perpY,3,0,Math.PI*2);ctx.fill();
            ctx.beginPath();ctx.arc(ex-perpX,ey-perpY,3,0,Math.PI*2);ctx.fill();
            ctx.fillStyle='white';ctx.shadowBlur=0;
            ctx.beginPath();ctx.moveTo(ex+perpX*0.4,ey+perpY*0.4);ctx.lineTo(ex+perpX*0.4+Math.cos(ang)*6,ey+perpY*0.4+Math.sin(ang)*6);ctx.lineTo(ex+perpX*1.2,ey+perpY*1.2);ctx.closePath();ctx.fill();
            ctx.beginPath();ctx.moveTo(ex-perpX*0.4,ey-perpY*0.4);ctx.lineTo(ex-perpX*0.4+Math.cos(ang)*6,ey-perpY*0.4+Math.sin(ang)*6);ctx.lineTo(ex-perpX*1.2,ey-perpY*1.2);ctx.closePath();ctx.fill();
        } else if (sk.isMachineGun) {
            const ang=Math.atan2(mousePos.y-player.y,mousePos.x-player.x);
            ctx.strokeStyle='#374151';ctx.lineWidth=6;ctx.lineCap='round';
            ctx.beginPath();ctx.moveTo(player.x,player.y);ctx.lineTo(player.x+Math.cos(ang)*28,player.y+Math.sin(ang)*28);ctx.stroke();
            ctx.strokeStyle='#9ca3af';ctx.lineWidth=4;ctx.lineCap='round';
            ctx.beginPath();ctx.moveTo(player.x,player.y);ctx.lineTo(player.x+Math.cos(ang)*28,player.y+Math.sin(ang)*28);ctx.stroke();
            if (ts - mgLastShot < 60) {
                ctx.globalAlpha=0.7;ctx.fillStyle='#fbbf24';ctx.shadowBlur=20;ctx.shadowColor='#fbbf24';
                ctx.beginPath();ctx.arc(player.x+Math.cos(ang)*30,player.y+Math.sin(ang)*30,4,0,Math.PI*2);ctx.fill();
            }
        } else {
            const ang=Math.atan2(mousePos.y-player.y,mousePos.x-player.x);
            ctx.fillStyle='white';ctx.beginPath();ctx.arc(player.x+Math.cos(ang)*8,player.y+Math.sin(ang)*8,5,0,Math.PI*2);ctx.fill();
        }
        ctx.restore();
    } else {
        ctx.save();
        if(currentCharacter==='dream'||currentCharacter==='technoblade'){
            const tier=getDreamArmorTier();
            const ringCol=tier.ringColor||(currentCharacter==='technoblade'?'#7c3aed':null);
            if(ringCol){
                const pulse=0.7+0.3*Math.sin(ts/300);
                ctx.shadowBlur=30*pulse;ctx.shadowColor=tier.glow||'#7c3aed';
                ctx.strokeStyle=ringCol;ctx.lineWidth=4;
                ctx.beginPath();ctx.arc(player.x,player.y,player.radius+6,0,Math.PI*2);ctx.stroke();
                if(tier.kills>=140||currentCharacter==='technoblade'){
                    ctx.strokeStyle=currentCharacter==='technoblade'?'#ef4444':'#a855f7';
                    ctx.lineWidth=2;ctx.globalAlpha=0.5+0.5*Math.sin(ts/150);
                    ctx.beginPath();ctx.arc(player.x,player.y,player.radius+12,0,Math.PI*2);ctx.stroke();
                }
            }
        } else {
            ctx.shadowBlur=20;ctx.shadowColor=sk.shadow;ctx.strokeStyle=sk.shadow;ctx.lineWidth=2;
            ctx.beginPath();ctx.arc(player.x,player.y,player.radius+2,0,Math.PI*2);ctx.stroke();
        }
        ctx.restore();
    }

    if(currentCharacter==='dream'||currentCharacter==='technoblade'){
        const tier=getDreamArmorTier(),tierIdx=DREAM_ARMOR_TIERS.indexOf(tier);
        if(tierIdx>lastDreamTierIdx&&lastDreamTierIdx>=0)dreamArmorAnnounce={text:`‚öîÔ∏è ${tier.name} Equipped!`,timer:180,color:tier.glow};
        lastDreamTierIdx=tierIdx;
        if(dreamArmorAnnounce&&dreamArmorAnnounce.timer>0){
            dreamArmorAnnounce.timer--;
            const alpha=Math.min(1,dreamArmorAnnounce.timer/40);
            const yOff=(180-dreamArmorAnnounce.timer)<20?(180-dreamArmorAnnounce.timer)*-1:-20;
            ctx.save();ctx.globalAlpha=alpha;ctx.font='bold 18px "Press Start 2P",monospace';ctx.textAlign='center';
            ctx.fillStyle=dreamArmorAnnounce.color;ctx.shadowBlur=20;ctx.shadowColor=dreamArmorAnnounce.color;
            ctx.fillText(dreamArmorAnnounce.text,canvas.width/2,80+yOff);
            ctx.font='bold 11px Arial';ctx.fillStyle='#fff';ctx.shadowBlur=0;
            ctx.fillText(`${Math.round(getDreamArmorTier().defense*100)}% damage reduction`,canvas.width/2,102+yOff);
            ctx.textAlign='left';ctx.restore();
        }
    } else {lastDreamTierIdx=-1;dreamArmorAnnounce=null;}

    if(bloodGodAnnounce&&bloodGodAnnounce.timer>0){
        bloodGodAnnounce.timer--;const t=bloodGodAnnounce.timer;const alpha=t>200?1:t/200;
        if(t>210){ctx.save();ctx.globalAlpha=(240-t)/30*0.35;ctx.fillStyle='#ef4444';ctx.fillRect(0,0,canvas.width,canvas.height);ctx.restore();}
        const scale=1+0.06*Math.sin(t/6);
        ctx.save();ctx.globalAlpha=alpha;ctx.textAlign='center';ctx.translate(canvas.width/2,canvas.height/2-10);ctx.scale(scale,scale);
        ctx.shadowBlur=40;ctx.shadowColor='#ef4444';ctx.font='bold 36px "Press Start 2P",monospace';ctx.fillStyle='#ef4444';
        ctx.fillText('BLOOD FOR THE',0,-28);ctx.fillText('BLOOD GOD',0,22);
        ctx.shadowBlur=0;ctx.fillStyle='#fca5a5';ctx.fillText('BLOOD FOR THE',0,-28);ctx.fillText('BLOOD GOD',0,22);
        ctx.restore();
    }
}

function tickVeteran(dt) {
    if(currentCharacter !== 'default') return;
    if(veteranTier >= VETERAN_TIERS.length - 1) return;
    veteranTimer += dt;
    if(veteranTimer >= 1800) {
        veteranTimer = 0;
        veteranTier = Math.min(veteranTier + 1, VETERAN_TIERS.length - 1);
        const t = VETERAN_TIERS[veteranTier];
        player.speed += t.speedBonus;
        floatMoneyText(`‚≠ê EVOLVED: ${t.name}!`);
        for(let i=0;i<100;i++) particles.push(new Particle(player.x, player.y, t.color));
        for(let r=20;r<120;r+=20) for(let a=0;a<Math.PI*2;a+=0.3) particles.push(new Particle(player.x+Math.cos(a)*r, player.y+Math.sin(a)*r, t.projColor));
    }
}

function tickFireEffects(dt) {
    enemies.forEach(e => {
        if(e.burning > 0) {
            e.burning -= dt;
            if(Math.floor(e.burning) % 18 === 0) {
                e.health -= (e.burnDmg || 1);
                particles.push(new Particle(e.x + (Math.random()-0.5)*e.radius, e.y + (Math.random()-0.5)*e.radius, '#ff4500'));
                if(e.health <= 0 && e.alive) { e.alive=false; player.kills++; gainExp(e.expValue); handleKill(e); }
            }
        }
    });
    firePatches = firePatches.filter(p => {
        p.timer -= dt;
        if(Math.floor(p.timer) % 12 === 0) {
            enemies.forEach(e => {
                if(Math.hypot(e.x-p.x, e.y-p.y) < p.radius) {
                    if(p.isBlizzard) {
                        e.frozen = Math.max(e.frozen||0, 60);
                        particles.push(new Particle(e.x, e.y, '#e0f7ff'));
                    } else {
                        e.burning = Math.max(e.burning||0, 120);
                        e.burnDmg = p.dmgPerTick || 1;
                        if(Math.random()<0.4) particles.push(new Particle(e.x, e.y, '#ff4500'));
                    }
                }
            });
        }
        ctx.save();
        ctx.globalAlpha = 0.25 * (p.timer / p.maxTimer);
        ctx.fillStyle = p.isBlizzard ? '#67e8f9' : '#ff4500';
        ctx.shadowBlur = 20;
        ctx.shadowColor = p.isBlizzard ? '#06b6d4' : '#ff4500';
        ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 0.15 * (p.timer / p.maxTimer);
        ctx.fillStyle = p.isBlizzard ? '#e0f7ff' : '#fbbf24';
        ctx.beginPath(); ctx.arc(p.x, p.y, p.radius*0.5, 0, Math.PI*2); ctx.fill();
        ctx.restore();
        return p.timer > 0;
    });
}

function doChainLightning(srcX, srcY, dmg, maxTargets, exclude) {
    const chainRange = 160;
    let targets = enemies.filter(e => e.alive && !exclude.has(e) && Math.hypot(e.x-srcX, e.y-srcY) < chainRange);
    targets.sort((a,b) => Math.hypot(a.x-srcX,a.y-srcY) - Math.hypot(b.x-srcX,b.y-srcY));
    targets = targets.slice(0, maxTargets);
    targets.forEach(e => {
        e.health -= dmg;
        const steps = 8;
        for(let s=0;s<=steps;s++) {
            const t2 = s/steps;
            const jx = (Math.random()-0.5)*18;
            const jy = (Math.random()-0.5)*18;
            particles.push(new Particle(srcX+(e.x-srcX)*t2+jx, srcY+(e.y-srcY)*t2+jy, '#facc15'));
        }
        if(e.health <= 0 && e.alive) { e.alive=false; player.kills++; gainExp(e.expValue); handleKill(e); }
    });
}

function tickGoldFormEnemies(dt) {
    enemies.forEach(e => {
        if (e.isGoldForm) {
            e.goldFormTimer -= dt;
            if (e.goldFormTimer <= 0) {
                e.isGoldForm = false;
                e.color = e.originalColor;
                for(let i=0;i<10;i++) particles.push(new Particle(e.x, e.y, e.originalColor));
            }
        }
    });
}

let lastTs = 0;
function gameLoop(ts){
    if(!gameRunning)return;
    const rawDt = lastTs ? Math.min(ts - lastTs, 50) : 16.667;
    const dt = (rawDt / 16.667) * (settings ? settings.gameSpeed : 1);
    lastTs = ts;

    // Call gold form tick function
    tickGoldFormEnemies(dt);

    // Update biome every frame
    updateBiome();

    // Update stats display every second if open
    if(statsDisplayOpen) {
        statsUpdateTimer += dt;
        if(statsUpdateTimer >= 60) {
            statsUpdateTimer = 0;
            updateStatsDisplay();
        }
    }

    ctx.clearRect(0,0,canvas.width,canvas.height);
    
    // Draw biome background effect
    drawBiomeBackground();
    
    const biomeColors = getBiomeColors();
    ctx.strokeStyle=biomeColors.gridColor;ctx.lineWidth=1;
    for(let x=0;x<canvas.width;x+=50){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,canvas.height);ctx.stroke();}
    for(let y=0;y<canvas.height;y+=50){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(canvas.width,y);ctx.stroke();}

    drawWalls();
    drawNavDebug();

    if(currentCharacter==='admin'){
        ctx.strokeStyle=`hsla(${adminHue},80%,50%,0.12)`;ctx.lineWidth=1;
        for(let x=0;x<canvas.width;x+=50){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,canvas.height);ctx.stroke();}
        for(let y=0;y<canvas.height;y+=50){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(canvas.width,y);ctx.stroke();}
    }

    roundTimer+=dt;if(roundTimer>=120){currentRound++;if(currentRound===dailyCodeWave){revealDailyCode();}roundTimer=0;
        if(currentRound>0 && currentRound%25===0) earnMoney(25,`wave ${currentRound} milestone`);
        if(currentRound>0 && currentRound%25===0 && currentRound!==lastShopWave) {
            lastShopWave=currentRound;
            openWaveShop(currentRound);
            return;
        }
        if(currentRound>=600) {
            floatMoneyText('üèÜ WAVE 600 REACHED! YOU WIN!');
            endGame();
            return;
        }
    }
    if(!hakariDomainActive && ts-lastEnemySpawn>getSpawnInterval()){spawnWave();lastEnemySpawn=ts;}

    if (CHARACTERS[currentCharacter].isBoxer && gameRunning && !document.getElementById('levelUpNotice').classList.contains('show')) {
        if (ts - boxerAuraLastHit > boxerAuraCooldown) {
            enemies.forEach(e => {
                const d = Math.hypot(e.x - player.x, e.y - player.y);
                if (d < boxerAuraRadius) {
                    e.health -= player.damage;
                    if (e.health <= 0 && e.alive) { e.alive = false; player.kills++; gainExp(e.expValue); handleKill(e); }
                    for(let i=0;i<3;i++) particles.push(new Particle(e.x, e.y, '#fca5a5'));
                }
            });
            boxerAuraLastHit = ts;
        }
    }
    if (CHARACTERS[currentCharacter].isGoldHoarder && gameRunning && !document.getElementById('levelUpNotice').classList.contains('show')) {
        if (ts - mgLastShot > GH_FIRE_INTERVAL) { shootProjectile(); mgLastShot = ts; }
    }
    if (CHARACTERS[currentCharacter].isAdmin && gameRunning && !document.getElementById('levelUpNotice').classList.contains('show')) {
        if (ts - mgLastShot > 80) { shootProjectile(true); mgLastShot = ts; }
    }
    if (!CHARACTERS[currentCharacter].isMachineGun && !CHARACTERS[currentCharacter].isAdmin && !CHARACTERS[currentCharacter].isGoldHoarder && !CHARACTERS[currentCharacter].isBoxer && autoFireEnabled &&
        !document.getElementById('levelUpNotice').classList.contains('show')) {
        if (!tickNewCharAutoFire(ts, dt)) {
            const overclockMult = 1 - Math.min(passiveState.overclock * 0.25, 0.75);
            const fireInterval = 250 * overclockMult;
            if (ts - autoFireLastShot > fireInterval) { shootProjectile(); autoFireLastShot = ts; }
        }
    }

    for(let i=0;i<adminCooldowns.length;i++) if(adminCooldowns[i]>0) adminCooldowns[i]-=dt;

    let mx=0,my=0;
    if(keys[binds.moveUp]||keys['arrowup'])my-=1;if(keys[binds.moveDown]||keys['arrowdown'])my+=1;
    if(keys[binds.moveLeft]||keys['arrowleft'])mx-=1;if(keys[binds.moveRight]||keys['arrowright'])mx+=1;
    if(mx||my){const m=Math.sqrt(mx*mx+my*my);const bSpd=passiveState.berserkerActive?1.5:1;const ghSpd=CHARACTERS[currentCharacter].isGoldHoarder?GH_SPEED_MULT:1;const biomeSpd=1+biomeSpeedBonus;player.x+=(mx/m)*player.speed*dt*bSpd*ghSpd*biomeSpd;player.y+=(my/m)*player.speed*dt*bSpd*ghSpd*biomeSpd;}
    player.x=Math.max(player.radius,Math.min(canvas.width-player.radius,player.x));
    player.y=Math.max(player.radius,Math.min(canvas.height-player.radius,player.y));
    const pResolved = (currentCharacter==='phantom'&&phantomPhasing) ? {x:player.x,y:player.y} : resolveCircleWall(player.x, player.y, player.radius);
    player.x = pResolved.x; player.y = pResolved.y;
    if(player.dashCooldown>0)player.dashCooldown-=dt;
    if(player.invulnerable>0)player.invulnerable-=dt;
    if(player.specialCooldown>0){player.specialCooldown-=dt;updateHUD();}
    player.manaRegen+=dt;if(player.manaRegen>=60){player.mana=Math.min(player.mana+1+passiveState.manaflow/30,player.maxMana);player.manaRegen=0;updateHUD();}
    tickPassives(dt);
    tickVeteran(dt);
    tickFireEffects(dt);
    tickGoldFormEnemies(dt);
    tickNewCharacters(ts, dt);
    turrets=turrets.filter(t=>{if(t.life<=0)return false;t.update(dt);t.draw();return true;});
    tickAirstrikes(dt);
    if(passiveState.blackholeActive){
        passiveState.blackholeTimer-=dt;
        enemies.forEach(e=>{
            const dx=canvas.width/2-e.x, dy=canvas.height/2-e.y, dist=Math.sqrt(dx*dx+dy*dy);
            if(dist>5){e.x+=dx/dist*4*dt; e.y+=dy/dist*4*dt;}
        });
        for(let i=0;i<2;i++) particles.push(new Particle(canvas.width/2,canvas.height/2,'#7c3aed'));
        if(passiveState.blackholeTimer<=0){
            passiveState.blackholeActive=false;
            enemies.forEach(e=>{ if(e.alive){e.alive=false;player.kills++;gainExp(e.expValue);handleKill(e);} });
            for(let i=0;i<200;i++) particles.push(new Particle(canvas.width/2,canvas.height/2,'#a855f7'));
        }
    }

    updateSkinOverlay(ts);
    drawPlayer(ts, dt);
    
    // Apply biome tint overlay
    if(biomeColors.playerGlow && biomeColors.playerGlow !== '#3b82f6') {
        ctx.save();
        ctx.globalAlpha = 0.08;
        ctx.fillStyle = biomeColors.playerGlow;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
    }

    const diff=getDifficulty();
    ctx.save();ctx.font='bold 13px Arial';
    ctx.fillStyle=diff===0?'rgba(255,255,255,0.4)':`hsl(${Math.max(0,120-diff*15)},90%,55%)`;
    ctx.textAlign='right';
    ctx.shadowColor = biomeColors.uiColor;
    ctx.shadowBlur = 8;
    ctx.fillText(`Wave ${currentRound} ‚Ä¢ Tier ${diff+1}`,canvas.width-12,22);
    const sc=getSpawnCount();ctx.font='bold 11px Arial';ctx.fillStyle='rgba(255,255,255,0.3)';
    ctx.shadowColor = 'rgba(0,0,0,0.3)';
    ctx.fillText(`${sc} enemy${sc>1?'s':''}/wave`,canvas.width-12,40);
    ctx.fillStyle='rgba(251,191,36,0.7)';ctx.fillText(`üí∞ ${runGold} gold`,canvas.width-12,60);
    ctx.textAlign='left';ctx.restore();

    if(currentCharacter==='phantom'){
        ctx.save();ctx.font='bold 10px Arial';ctx.fillStyle='rgba(125,211,252,0.8)';ctx.textAlign='left';
        ctx.shadowBlur=6;ctx.shadowColor='#38bdf8';
        ctx.fillText(`üëª PHANTOM ‚Äî shots pierce walls! | R: Ghost Walk${phantomPhasing?' [PHASING]':' (3s CD)'}`,12,22);ctx.restore();
    }
    if(currentCharacter==='druid'){
        ctx.save();ctx.font='bold 10px Arial';ctx.fillStyle='rgba(74,222,128,0.8)';ctx.textAlign='left';
        ctx.shadowBlur=6;ctx.shadowColor='#16a34a';
        ctx.fillText(`üåø DRUID ‚Äî shots ROOT enemies 1.5s! | R: Mushroom ring (heal zone) | Shrooms: ${druidShrooms.length}`,12,22);ctx.restore();
    }
    if(currentCharacter==='pyromancer'){
        ctx.save();ctx.font='bold 10px Arial';ctx.fillStyle='rgba(251,146,60,0.9)';ctx.textAlign='left';
        ctx.shadowBlur=6;ctx.shadowColor='#c2410c';
        const pct2=pyroCharging?Math.round(Math.min(pyroChargeTimer/180,1)*100):0;
        ctx.fillText('üîÆ PYROMANCER ‚Äî hold click to charge shots' + (pyroCharging?' ['+pct2+'%]':'') + ' | R: Meteor Strike',12,22);ctx.restore();
    }
    if(currentCharacter==='cyborg'){
        ctx.save();ctx.font='bold 10px Arial';ctx.fillStyle=cyborgMode==='rapid'?'rgba(56,189,248,0.9)':'rgba(192,132,252,0.9)';ctx.textAlign='left';
        ctx.shadowBlur=6;ctx.shadowColor=cyborgMode==='rapid'?'#0ea5e9':'#7c3aed';
        ctx.fillText(`ü§ñ CYBORG [${cyborgMode.toUpperCase()}] E: toggle mode | R: Laser Sweep`,12,22);ctx.restore();
    }
    if(currentCharacter==='timewizard'){
        ctx.save();ctx.font='bold 10px Arial';ctx.fillStyle='rgba(216,180,254,0.9)';ctx.textAlign='left';
        ctx.shadowBlur=6;ctx.shadowColor='#7c3aed';
        const snapHp=timeWizardSnapshot?Math.round(timeWizardSnapshot.health):'--';
        ctx.fillText(`‚è≥ TIME WIZARD ‚Äî shots echo twice! | R: Rewind HP | Snapshot: ${snapHp} HP`,12,22);ctx.restore();
    }
    if(CHARACTERS[currentCharacter].isMachineGun){
        ctx.save();ctx.font='bold 10px Arial';ctx.fillStyle='rgba(200,200,200,0.4)';ctx.textAlign='left';
        ctx.fillText('üî´ MACHINE GUN ‚Äî 1 dmg | no special',12,22);ctx.restore();
    }
    if(currentCharacter==='goldhoarder'){
        ctx.save();ctx.font='bold 10px Arial';ctx.fillStyle='rgba(234,179,8,0.7)';ctx.textAlign='left';
        ctx.shadowBlur=6;ctx.shadowColor='#fbbf24';
        ctx.fillText('ü™ô GOLD HOARDER ‚Äî 5x gold | slow & weak | R: Gold Rush',12,22);ctx.restore();
    }
    if(currentCharacter==='default'){
        const vt=VETERAN_TIERS[veteranTier];
        const secLeft=veteranTier<VETERAN_TIERS.length-1?Math.ceil((1800-veteranTimer)/60):'MAX';
        ctx.save();ctx.font='bold 10px Arial';ctx.fillStyle=vt.color;ctx.textAlign='left';
        ctx.shadowBlur=8;ctx.shadowColor=vt.shadow;
        ctx.fillText(`‚≠ê ${vt.name} ‚Äî R: ${vt.label} | evolves in: ${secLeft}s`,12,22);ctx.restore();
    }
    if(currentCharacter==='fire'){
        ctx.save();ctx.font='bold 10px Arial';ctx.fillStyle='rgba(255,100,0,0.8)';ctx.textAlign='left';
        ctx.shadowBlur=6;ctx.shadowColor='#ff4500';
        ctx.fillText('üî• FIRE BALL ‚Äî shots leave burn patches | R: Inferno (ignites all)',12,22);ctx.restore();
    }
    if(currentCharacter==='ice'){
        ctx.save();ctx.font='bold 10px Arial';ctx.fillStyle='rgba(103,232,249,0.8)';ctx.textAlign='left';
        ctx.shadowBlur=6;ctx.shadowColor='#06b6d4';
        ctx.fillText('‚ùÑÔ∏è ICE BALL ‚Äî pierce shots | shatter frozen for 3x dmg | R: Blizzard',12,22);ctx.restore();
    }
    if(currentCharacter==='electric'){
        ctx.save();ctx.font='bold 10px Arial';ctx.fillStyle='rgba(250,204,21,0.8)';ctx.textAlign='left';
        ctx.shadowBlur=6;ctx.shadowColor='#a855f7';
        ctx.fillText(`‚ö° TESLA ‚Äî shots auto-chain | R: Overload${overloadCharges>0?' ACTIVE x'+overloadCharges:''}`,12,22);ctx.restore();
    }
    if(currentCharacter==='admin'){
        ctx.save();ctx.font='bold 11px "Press Start 2P",monospace';
        ctx.fillStyle=`hsl(${adminHue},100%,70%)`;ctx.textAlign='left';
        ctx.shadowBlur=10;ctx.shadowColor=`hsl(${adminHue},100%,60%)`;
        ctx.fillText('üëë THE ADMIN ‚Äî PRESS 1-9 FOR ABILITIES',12,22);ctx.restore();
    }
    let buffY = canvas.height - 14;
    const buffFont = 'bold 11px Arial';
    if(passiveState.berserkerActive){
        ctx.save();ctx.font=buffFont;ctx.fillStyle='#ef4444';ctx.textAlign='left';
        const bt=Math.ceil(passiveState.berserkerTimer/60);
        ctx.fillText(`üò§ BERSERKER ${bt}s`,12,buffY);ctx.restore();buffY-=16;
    }
    if(passiveState.timeslowActive){
        ctx.save();ctx.font=buffFont;ctx.fillStyle='#06b6d4';ctx.textAlign='left';
        const tt=Math.ceil(passiveState.timeslowTimer/60);
        ctx.fillText(`‚è≥ TIME SLOW ${tt}s`,12,buffY);ctx.restore();buffY-=16;
    }
    if(turrets.length>0){
        ctx.save();ctx.font=buffFont;ctx.fillStyle='#22c55e';ctx.textAlign='left';
        ctx.fillText(`‚öôÔ∏è TURRETS: ${turrets.length}`,12,buffY);ctx.restore();buffY-=16;
    }
    if(passiveState.trishot>0&&passiveState.trishotTimer>0){
        ctx.save();ctx.font=buffFont;ctx.fillStyle='#fbbf24';ctx.textAlign='left';
        ctx.fillText(`üèπ TRIPLE SHOT ${Math.ceil(passiveState.trishotTimer/60)}s`,12,buffY);ctx.restore();buffY-=16;
    }
    if(passiveState.homingshot>0&&passiveState.homingTimer>0){
        ctx.save();ctx.font=buffFont;ctx.fillStyle='#a78bfa';ctx.textAlign='left';
        ctx.fillText(`üéØ HOMING ${Math.ceil(passiveState.homingTimer/60)}s`,12,buffY);ctx.restore();buffY-=16;
    }
    if(passiveState.blackholeActive){
        ctx.save();ctx.font=buffFont;ctx.fillStyle='#a855f7';ctx.textAlign='left';
        ctx.fillText(`üåë BLACK HOLE ${Math.ceil(passiveState.blackholeTimer/60)}s`,12,buffY);ctx.restore();buffY-=16;
    }

    projectiles=projectiles.filter(proj=>{
        if(!proj.alive)return false;proj.update(dt);if(projectileHitsWall(proj)){proj.alive=false;for(let i=0;i<4;i++)particles.push(new Particle(proj.x,proj.y,'rgba(100,180,255,0.7)'));return false;}proj.draw();
        for(let e of enemies){if(!e.alive)continue;const dx=e.x-proj.x,dy=e.y-proj.y;
            if(Math.sqrt(dx*dx+dy*dy)<e.radius+proj.radius){
                let pdmg = proj.damage;
                if(passiveState.crit>0&&Math.random()<passiveState.crit){pdmg*=3;}

                if(currentCharacter==='ice'||proj.isIce){
                    if(e.frozen>0){ pdmg*=3; floatMoneyText('üíé SHATTER!'); for(let i=0;i<25;i++) particles.push(new Particle(e.x,e.y,'#e0f7ff')); }
                    e.health-=pdmg;
                    e.frozen=Math.max(e.frozen||0,90);
                    for(let i=0;i<6;i++) particles.push(new Particle(e.x,e.y,'#67e8f9'));
                    if(e.health<=0&&e.alive){e.alive=false;player.kills++;gainExp(e.expValue);handleKill(e);const sk2=CHARACTERS[currentCharacter];if(sk2.msgNormal)showDeathMsg(e.name,sk2.msgNormal);for(let i=0;i<20;i++)particles.push(new Particle(e.x,e.y,e.color));}
                    continue;
                }

                e.health-=pdmg; proj.alive=false;

                if(currentCharacter==='fire'||proj.isFire){
                    firePatches.push({x:e.x,y:e.y,radius:50,timer:180,maxTimer:180,dmgPerTick:player.damage*0.25});
                    e.burning=(e.burning||0)+120; e.burnDmg=player.damage*0.35;
                    for(let i=0;i<10;i++) particles.push(new Particle(e.x,e.y,'#ff4500'));
                }

                if(currentCharacter==='electric'||proj.isElectric){
                    const chainCount = overloadCharges>0 ? enemies.length : 3;
                    if(overloadCharges>0){ overloadCharges--; floatMoneyText(`‚ö° OVERLOAD! (${overloadCharges} left)`); }
                    doChainLightning(e.x, e.y, pdmg*0.7, chainCount, new Set([e]));
                }

                if(currentCharacter==='default'){
                    if(veteranTier>=3) e.frozen=Math.max(e.frozen||0,60);
                    if(veteranTier>=4 && e.alive){ e.burning=(e.burning||0)+90; e.burnDmg=pdmg*0.3; }
                }

                // DRUID ‚Äî vine root
                if(proj.isDruidVine) {
                    e.frozen = Math.max(e.frozen||0, 90); // root = freeze for ~1.5s
                    for(let i=0;i<12;i++) particles.push(new Particle(e.x,e.y,'#4ade80'));
                    for(let i=0;i<8;i++) particles.push(new Particle(e.x,e.y,'#16a34a'));
                }

                // PHANTOM ‚Äî phasing shots deal bonus damage when ghost walking
                if(proj.isPhantom && phantomPhasing) {
                    e.health -= pdmg * 0.5; // extra 50% while phasing
                    for(let i=0;i<5;i++) particles.push(new Particle(e.x,e.y,'#7dd3fc'));
                }

                if(passiveState.explosive>0&&Math.random()<passiveState.explosive){
                    enemies.forEach(en=>{
                        const d=Math.hypot(en.x-e.x,en.y-e.y);
                        if(d<60+passiveState.explosive*20&&d>0){
                            en.health-=pdmg*0.6;
                            if(en.health<=0&&en.alive){en.alive=false;player.kills++;gainExp(en.expValue);handleKill(en);}
                        }
                    });
                    for(let i=0;i<20;i++)particles.push(new Particle(e.x,e.y,'#f97316'));
                }
                if(passiveState.novaleak>0){
                    passiveState.novaHitCount=(passiveState.novaHitCount||0)+1;
                    if(passiveState.novaHitCount % Math.max(1,6-passiveState.novaleak) === 0){
                        for(let i=0;i<8;i++){const a=(Math.PI*2/8)*i;const np=new Projectile(e.x,e.y,a,pdmg,'#c084fc',true);projectiles.push(np);}
                        for(let i=0;i<12;i++)particles.push(new Particle(e.x,e.y,'#a855f7'));
                    }
                }
                if(e.health<=0&&e.alive){e.alive=false;player.kills++;gainExp(e.expValue);
                    handleKill(e);
                    const sk2=CHARACTERS[currentCharacter];if(sk2.msgNormal)showDeathMsg(e.name,proj.isSpecial&&sk2.msgSpecial?sk2.msgSpecial:sk2.msgNormal);
                    for(let i=0;i<20;i++)particles.push(new Particle(e.x,e.y,e.color));}
                break;}}
        return proj.alive;
    });
    enemies=enemies.filter(e=>{if(!e.alive)return false;e.update(dt);if(e.alive)e.draw();return e.alive;});
    
    // Boss handling
    if (currentBoss && currentBoss.alive) {
        currentBoss.update(dt);
        currentBoss.draw();
        
        // Handle boss health from projectiles
        projectiles = projectiles.filter(proj => {
            if (currentBoss && !proj.alive) return false;
            if (currentBoss && proj.alive && !currentBoss.dashInProgress) {
                const d = Math.hypot(proj.x - currentBoss.x, proj.y - currentBoss.y);
                if (d < currentBoss.radius + proj.radius) {
                    currentBoss.health -= proj.damage;
                    proj.alive = false;
                    for(let i=0;i<10;i++) particles.push(new Particle(proj.x, proj.y, '#fbbf24'));
                    if (currentBoss.health <= 0) {
                        currentBoss.alive = false;
                        triangleEnemyUnlocked = true;
                        player.kills += 10;
                        gainExp(500);
                        floatMoneyText('üëπ TRIANGLE DEFEATED! Triangle enemies unlocked!');
                        for(let i=0;i<150;i++) particles.push(new Particle(currentBoss.x + (Math.random()-0.5)*100, currentBoss.y + (Math.random()-0.5)*100, '#fbbf24'));
                        currentBoss = null;
                        bossBullets = [];
                        earnMoney(50, 'triangle boss defeated!');
                    }
                    return false;
                }
            }
            return true;
        });
        
        // Handle boss bullets
        bossBullets = bossBullets.filter(b => {
            if (!b.alive) return false;
            b.x += b.vx * dt;
            b.y += b.vy * dt;
            
            // Draw bullet
            ctx.save();
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#dc2626';
            ctx.fillStyle = '#ef4444';
            ctx.beginPath();
            ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // Check collision with player
            if (Math.hypot(b.x - player.x, b.y - player.y) < b.radius + player.radius && player.invulnerable <= 0) {
                let dmg = applyDreamArmor(b.damage);
                dmg = applyPassiveIncomingDamage(dmg);
                player.health -= dmg;
                player.invulnerable = 30;
                updateHUD();
                if (player.health <= 0) endGame();
                b.alive = false;
                for(let i=0;i<15;i++) particles.push(new Particle(b.x, b.y, '#dc2626'));
                return false;
            }
            
            // Remove if off screen
            if (b.x < -50 || b.x > canvas.width + 50 || b.y < -50 || b.y > canvas.height + 50) {
                b.alive = false;
                return false;
            }
            
            return true;
        });
        
        // Mini triangles
        miniTriangles = miniTriangles.filter(mt => {
            if (!mt.alive) return false;
            mt.x += mt.vx * dt;
            mt.y += mt.vy * dt;
            mt.rotation += 0.1 * dt;
            
            // Draw mini triangle
            ctx.save();
            ctx.translate(mt.x, mt.y);
            ctx.rotate(mt.rotation);
            ctx.fillStyle = '#fca5a5';
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#fca5a5';
            ctx.beginPath();
            const s = mt.radius;
            ctx.moveTo(0, -s);
            ctx.lineTo(s * 0.866, s * 0.5);
            ctx.lineTo(-s * 0.866, s * 0.5);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            
            // Check collision with player
            if (Math.hypot(mt.x - player.x, mt.y - player.y) < mt.radius + player.radius && player.invulnerable <= 0) {
                player.health -= 25;
                player.invulnerable = 30;
                updateHUD();
                if (player.health <= 0) endGame();
                mt.alive = false;
                for(let i=0;i<15;i++) particles.push(new Particle(mt.x, mt.y, '#fca5a5'));
                return false;
            }
            
            // Remove if off screen
            if (mt.x < -50 || mt.x > canvas.width + 50 || mt.y < -50 || mt.y > canvas.height + 50) {
                mt.alive = false;
                return false;
            }
            
            // Check collision with projectiles
            projectiles = projectiles.filter(proj => {
                if (proj.alive && Math.hypot(proj.x - mt.x, proj.y - mt.y) < mt.radius + proj.radius) {
                    mt.alive = false;
                    proj.alive = false;
                    for(let i=0;i<10;i++) particles.push(new Particle(mt.x, mt.y, '#fca5a5'));
                    return false;
                }
                return true;
            });
            
            return true;
        });
    }
    
    items=items.filter(it=>{if(!it.alive)return false;it.update(dt);it.draw();return it.alive;});
    particles=particles.filter(p=>{if(p.life<=0)return false;p.update(dt);p.draw();return true;});
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // HAKARI DOMAIN EXPANSION LOGIC
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    if (hakariDomainActive) {
        // Pause enemy waves but keep gameplay running
        hakariDomainTimer -= dt;
        hakariRollTimer += dt;
        
        // Draw domain shield around player
        ctx.save();
        ctx.translate(player.x, player.y);
        const domainSize = 200;
        const pulse = 0.3 + 0.2 * Math.sin(hakariRollTimer * 0.02);
        ctx.strokeStyle = `rgba(236, 72, 153, ${pulse})`;
        ctx.lineWidth = 4;
        ctx.setLineDash([10, 10]);
        ctx.beginPath();
        ctx.arc(0, 0, domainSize, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
        
        // Draw "DOMAIN" text
        ctx.save();
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#ec4899';
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#ec4899';
        ctx.fillText('üé∞ DOMAIN EXPANSION üé∞', player.x, player.y - 220);
        ctx.restore();
        
        // Draw roll count
        ctx.save();
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#fbbf24';
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#fbbf24';
        ctx.fillText(`ROLLS: ${hakariRollCount}`, player.x, player.y - 190);
        const timeLeft = Math.ceil(hakariDomainTimer / 60);
        ctx.fillStyle = '#7c3aed';
        ctx.shadowColor = '#7c3aed';
        ctx.fillText(`TIME: ${timeLeft}s`, player.x, player.y - 160);
        ctx.restore();
        
        // Rolling animation ‚Äî spin text
        if (hakariRollCount > 0) {
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(hakariRollTimer * 0.05);
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#ec4899';
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#ec4899';
            ctx.fillText('üé∞', 0, 30);
            ctx.restore();
        }
        
        // Auto-roll every ~1 second
        if (Math.floor(hakariRollTimer / 60) > hakariRollCount && hakariRollCount < 60) {
            hakariRollCount++;
            // Fixed jackpot chance: no pity system
            const jackpotChance = 0.10; // 10% flat chance per roll
            if (Math.random() < jackpotChance) {
                // JACKPOT HIT!
                hakariJackpotActive = true;
                hakariJackpotTimer = 15060; // 4m 11s = 251 seconds = 15060 frames at 60fps
                hakariJackpotCooldown = 1200; // 20 second cooldown before domain can be popped again (1200 frames at 60fps)
                hakariDomainActive = false; // exit domain
                floatMoneyText('üé∞ JACKPOT! IMMORTALITY UNLOCKED! 4:11 üé∞');
                for(let i=0;i<200;i++) particles.push(new Particle(player.x + (Math.random()-0.5)*200, player.y + (Math.random()-0.5)*200, '#fbbf24'));
                for(let i=0;i<200;i++) particles.push(new Particle(player.x + (Math.random()-0.5)*200, player.y + (Math.random()-0.5)*200, '#ec4899'));
            }
        }
        
        // Time expired
        if (hakariDomainTimer <= 0) {
            hakariDomainActive = false;
            floatMoneyText('‚è±Ô∏è Domain time expired! No jackpot.');
            for(let i=0;i<100;i++) particles.push(new Particle(player.x + (Math.random()-0.5)*150, player.y + (Math.random()-0.5)*150, '#7c3aed'));
        }
        
        // Return early to skip normal game updates while in domain
        requestAnimationFrame(gameLoop);
        return;
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // HAKARI JACKPOT IMMORTALITY
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    if (hakariJackpotActive) {
        hakariJackpotTimer -= dt;
        
        // Draw immortality aura
        ctx.save();
        ctx.translate(player.x, player.y);
        const auraRotation = Date.now() * 0.0005;
        ctx.rotate(auraRotation);
        ctx.strokeStyle = 'rgba(251, 191, 36, 0.6)';
        ctx.lineWidth = 3;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.arc(0, 0, player.radius + 30, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
        
        // Draw jackpot countdown
        const minLeft = Math.floor(hakariJackpotTimer / 3600);
        const secLeft = Math.floor((hakariJackpotTimer % 3600) / 60);
        ctx.save();
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#fbbf24';
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#fbbf24';
        ctx.fillText(`üé∞ IMMORTAL ${minLeft}:${secLeft.toString().padStart(2, '0')} üé∞`, player.x, player.y - 40);
        ctx.restore();
        
        // Make all shots one-shot
        projectiles.forEach(p => {
            if (p.damage < player.damage * 50) {
                p.damage = player.damage * 50; // one-shot damage
            }
        });
        
        // Invulnerability effect
        player.invulnerable = Math.max(player.invulnerable, 1);
        
        // Time expired
        if (hakariJackpotTimer <= 0) {
            hakariJackpotActive = false;
            floatMoneyText('‚è∞ Jackpot immortality ended!');
        }
        
        // Handle jackpot cooldown
        if (hakariJackpotCooldown > 0) {
            hakariJackpotCooldown -= dt;
        }
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // YUJI ITADORI - SUKUNA TRANSFORMATION VISUALS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    if(currentCharacter === 'yuji_itadori') {
        // Draw Sukuna finger counter
        ctx.save();
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.fillStyle = yujiIsSukuna ? '#8b0000' : '#e84d4d';
        ctx.shadowBlur = 20;
        ctx.shadowColor = yujiIsSukuna ? '#8b0000' : '#e84d4d';
        const fingerText = yujiIsSukuna ? 'SUKUNA' : `ü©∏ Fingers: ${yujiSukunaFingers}/20`;
        ctx.fillText(fingerText, player.x, player.y - 60);
        ctx.restore();
        
        // If Sukuna, draw red aura
        if(yujiIsSukuna) {
            ctx.save();
            ctx.strokeStyle = 'rgba(139, 0, 0, 0.4)';
            ctx.lineWidth = 4;
            ctx.setLineDash([8, 6]);
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.radius + 40, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }
    }
    
    // Malevolent Shrine continuous damage effect
    if(sukunaMalevolentActive) {
        // Apply 5% of enemy maxHealth as damage per frame
        enemies.forEach(e => {
            const damagePerFrame = e.maxHealth * 0.05 * (dt / 60); // 5% per second
            e.health -= damagePerFrame;
            // Visual damage indicator
            particles.push(new Particle(e.x + (Math.random()-0.5)*30, e.y + (Math.random()-0.5)*30, '#8b0000'));
        });
    }
    
    // Malevolent Shrine effect visualization and cooldown
    if(sukunaMalevolentActive && sukunaMalevolentTimer > 0) {
        sukunaMalevolentTimer -= dt;
        ctx.save();
        ctx.fillStyle = `rgba(139, 0, 0, ${0.3 * (sukunaMalevolentTimer / 180)})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = `rgba(139, 0, 0, ${0.6 * (sukunaMalevolentTimer / 180)})`;
        ctx.lineWidth = 3;
        ctx.strokeRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
    } else if(sukunaMalevolentActive && sukunaMalevolentTimer <= 0) {
        sukunaMalevolentActive = false;
    }
    
    // Handle Malevolent Shrine cooldown
    if(sukunaMalevolentCooldown > 0) {
        sukunaMalevolentCooldown -= dt;
    }
    
    // Draw Boxer aura
    if(currentCharacter==='boxer') {
        ctx.save();
        ctx.strokeStyle='rgba(220,38,38,0.3)';
        ctx.lineWidth=3;
        ctx.setLineDash([6,4]);
        ctx.beginPath();
        ctx.arc(player.x,player.y,boxerAuraRadius,0,Math.PI*2);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();
    }

    floatingTexts=floatingTexts.filter(ft=>{
        ft.y+=ft.vy*dt; ft.life-=dt;
        ctx.save();ctx.globalAlpha=ft.life/120;ctx.font='bold 12px Arial';ctx.fillStyle='#fbbf24';
        ctx.textAlign='left';ctx.fillText(ft.text,ft.x,ft.y);ctx.restore();
        return ft.life>0;
    });

    // Process and render current notification
    processNotificationQueue();
    if(currentNotification !== null) {
        notificationTimer -= dt;
        const alpha = notificationTimer < 60 ? notificationTimer / 60 : 1;
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#fbbf24';
        ctx.shadowBlur = 12;
        ctx.shadowColor = '#fbbf24';
        ctx.fillText(currentNotification, canvas.width / 2, 80);
        ctx.restore();
        if(notificationTimer <= 0) {
            currentNotification = null;
        }
    }

    if(currentCharacter==='admin')updateAdminKeys();

    requestAnimationFrame(gameLoop);
}



const DEFAULT_BINDS = {
    moveUp:    'w',
    moveDown:  's',
    moveLeft:  'a',
    moveRight: 'd',
    dash:      ' ',
    special:   'r',
    pause:     'escape',
};
const BIND_LABELS = {
    moveUp: '‚¨Ü Move Up', moveDown: '‚¨á Move Down',
    moveLeft: '‚¨Ö Move Left', moveRight: '‚û° Move Right',
    dash: 'üí® Dash', special: '‚ú® Special (R)', pause: '‚è∏ Pause',
};

const DEFAULT_SETTINGS = {
    screenShake: true,
    particles: true,
    deathFeed: true,
    navDebug: false,
    gameSpeed: 1,
};

let binds = { ...DEFAULT_BINDS };
let settings = { ...DEFAULT_SETTINGS };
let listeningFor = null;
let gamePaused = false;
let settingsFromPause = false;

function loadSettings() {
    try {
        const b = JSON.parse(localStorage.getItem('ballSurvivalBinds'));
        const s = JSON.parse(localStorage.getItem('ballSurvivalSettings'));
        if (b) binds = { ...DEFAULT_BINDS, ...b };
        if (s) settings = { ...DEFAULT_SETTINGS, ...s };
    } catch(e) {}
    applySettings();
}

function saveSettings() {
    localStorage.setItem('ballSurvivalBinds', JSON.stringify(binds));
    localStorage.setItem('ballSurvivalSettings', JSON.stringify(settings));
}

function applySettings() {
    document.getElementById('toggleShake').checked    = settings.screenShake;
    document.getElementById('toggleParticles').checked= settings.particles;
    document.getElementById('toggleDeathFeed').checked= settings.deathFeed;
    document.getElementById('toggleNavDebug').checked = settings.navDebug;
    document.getElementById('sliderSpeed').value      = settings.gameSpeed;
    document.getElementById('speedVal').textContent   = settings.gameSpeed + 'x';
    document.getElementById('deathFeed').style.display = settings.deathFeed ? 'flex' : 'none';
}

function resetKeybinds() {
    binds = { ...DEFAULT_BINDS };
    saveSettings();
    renderKeybindRows();
}

function formatKey(k) {
    if (k === ' ')       return 'SPACE';
    if (k === 'escape')  return 'ESC';
    if (k === 'arrowup') return '‚Üë';
    if (k === 'arrowdown') return '‚Üì';
    if (k === 'arrowleft') return '‚Üê';
    if (k === 'arrowright') return '‚Üí';
    return k.toUpperCase();
}

function renderKeybindRows() {
    const container = document.getElementById('keybindRows');
    container.innerHTML = '';
    Object.keys(DEFAULT_BINDS).forEach(action => {
        const row = document.createElement('div');
        row.className = 'keybind-row';
        const label = document.createElement('span');
        label.className = 'keybind-label';
        label.textContent = BIND_LABELS[action];
        const btn = document.createElement('button');
        btn.className = 'keybind-btn' + (listeningFor === action ? ' listening' : '');
        btn.textContent = listeningFor === action ? 'Press key...' : formatKey(binds[action]);
        btn.onclick = () => startListening(action);
        row.appendChild(label);
        row.appendChild(btn);
        container.appendChild(row);
    });
}

function startListening(action) {
    listeningFor = action;
    renderKeybindRows();
}

document.addEventListener('keydown', e => {
    if (listeningFor) {
        e.preventDefault();
        const k = e.key.toLowerCase();
        binds[listeningFor] = k;
        listeningFor = null;
        saveSettings();
        renderKeybindRows();
        return;
    }
});

function showSettings(fromPause) {
    settingsFromPause = fromPause;
    if (fromPause) {
        document.getElementById('pauseMenu').style.display = 'none';
    } else {
        document.getElementById('mainMenu').style.display = 'none';
    }
    document.getElementById('settingsMenu').style.display = 'block';
    renderKeybindRows();
    applySettings();
}

function closeSettings() {
    document.getElementById('settingsMenu').style.display = 'none';
    if (settingsFromPause) {
        document.getElementById('pauseMenu').style.display = 'block';
    } else {
        document.getElementById('mainMenu').style.display = 'block';
        updateMoneyDisplay();
    }
}

function openSettingsFromPause() {
    showSettings(true);
}

function pauseGame() {
    if (!gameRunning && !gamePaused) return;
    gamePaused = true;
    gameRunning = false;
    document.getElementById('pauseOverlay').style.display = 'block';
    document.getElementById('pauseMenu').style.display = 'block';
}

function resumeGame() {
    gamePaused = false;
    gameRunning = true;
    document.getElementById('pauseOverlay').style.display = 'none';
    document.getElementById('pauseMenu').style.display = 'none';
    lastTs = 0;
    requestAnimationFrame(gameLoop);
}

function pauseToMainMenu() {
    gamePaused = false;
    gameRunning = false;
    document.getElementById('pauseOverlay').style.display = 'none';
    document.getElementById('pauseMenu').style.display = 'none';
    document.getElementById('gameContainer').style.display = 'none';
    document.getElementById('playerSkinOverlay').style.display = 'none';
    document.getElementById('mainMenu').style.display = 'block';
    updateMoneyDisplay();
}

function drawNavDebug() {
    if (!settings.navDebug || !navGrid) return;
    ctx.save();
    ctx.globalAlpha = 0.18;
    for (let r = 0; r < navRows; r++) {
        for (let c = 0; c < navCols; c++) {
            if (!navGrid[r][c]) {
                ctx.fillStyle = '#ef4444';
                ctx.fillRect(c * NAV_CELL, r * NAV_CELL, NAV_CELL, NAV_CELL);
            }
        }
    }
    ctx.restore();
}

function drawBiomeBackground() {
    ctx.save();
    switch(currentBiome.effect) {
        case 'freeze':
            ctx.fillStyle = 'rgba(135, 206, 250, 0.08)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            for(let i = 0; i < 3; i++) {
                ctx.fillStyle = `rgba(200, 220, 255, ${0.05 + Math.random() * 0.05})`;
                ctx.fillRect(Math.random() * canvas.width, Math.random() * canvas.height, Math.random() * 100 + 50, 2);
            }
            break;
        case 'burn':
            ctx.fillStyle = 'rgba(255, 100, 0, 0.06)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            for(let i = 0; i < 2; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const grad = ctx.createRadialGradient(x, y, 0, x, y, 100);
                grad.addColorStop(0, 'rgba(255, 140, 0, 0.08)');
                grad.addColorStop(1, 'rgba(255, 100, 0, 0)');
                ctx.fillStyle = grad;
                ctx.fillRect(x - 100, y - 100, 200, 200);
            }
            break;
        case 'electric':
            ctx.fillStyle = 'rgba(255, 255, 0, 0.04)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = 'rgba(255, 255, 100, 0.1)';
            ctx.lineWidth = 1;
            for(let i = 0; i < 2; i++) {
                ctx.beginPath();
                ctx.moveTo(0, Math.random() * canvas.height);
                ctx.lineTo(canvas.width, Math.random() * canvas.height);
                ctx.stroke();
            }
            break;
        case 'dark':
            ctx.fillStyle = 'rgba(100, 100, 150, 0.12)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            for(let i = 0; i < 5; i++) {
                ctx.fillStyle = `rgba(80, 80, 120, ${Math.random() * 0.05})`;
                ctx.fillRect(Math.random() * canvas.width, Math.random() * canvas.height, Math.random() * 150, Math.random() * 150);
            }
            break;
        case 'water':
            ctx.fillStyle = 'rgba(100, 150, 200, 0.08)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = 'rgba(150, 170, 200, 0.06)';
            ctx.lineWidth = 2;
            for(let i = 0; i < 3; i++) {
                const y = (canvas.height / 3) * (i + 1);
                ctx.beginPath();
                for(let x = 0; x < canvas.width; x += 30) {
                    ctx.lineTo(x, y + Math.sin(x * 0.01) * 10);
                }
                ctx.stroke();
            }
            break;
    }
    ctx.restore();
}

document.addEventListener('keydown',e=>{
    if(listeningFor) return;
    const k = e.key.toLowerCase();
    keys[k] = true;
    if((k === binds.pause || k === 'escape' || k === 'p') && (gameRunning || gamePaused) && !shopOpen) {
        e.preventDefault();
        if(gamePaused) resumeGame(); else pauseGame();
        return;
    }
    if(k === 'tab' && gameRunning) { e.preventDefault(); toggleStatsDisplay(); return; }
    if(k === binds.dash) { e.preventDefault(); if(gameRunning) dash(); }
    if(k === binds.special && gameRunning) specialAttack();
    // Cyborg mode toggle (E key)
    if(k === 'e' && currentCharacter === 'cyborg' && gameRunning) {
        cyborgMode = cyborgMode === 'rapid' ? 'heavy' : 'rapid';
        floatMoneyText(cyborgMode === 'rapid' ? 'ü§ñ RAPID MODE ‚ö°' : 'ü§ñ HEAVY MODE üí•');
        for(let i=0;i<20;i++) particles.push(new Particle(player.x, player.y, cyborgMode==='rapid'?'#38bdf8':'#c084fc'));
        updateHUD();
    }
    // Builder wall move toggle (E key)
    if(k === 'e' && currentCharacter === 'builder' && gameRunning) {
        builderMoveMode = !builderMoveMode;
        builderSelectedWall = null;
        floatMoneyText(builderMoveMode ? 'üèóÔ∏è MOVE MODE ON' : 'üèóÔ∏è MOVE MODE OFF');
        for(let i=0;i<15;i++) particles.push(new Particle(player.x, player.y, '#d2691e'));
    }
    if(currentCharacter==='admin'&&gameRunning){
        const n=parseInt(e.key);
        if(n>=1&&n<=9)doAdminAbility(n-1);
    }
});
document.addEventListener('keyup',e=>{keys[e.key.toLowerCase()]=false;});
canvas.addEventListener('mousemove',e=>{
    const r=canvas.getBoundingClientRect();
    mousePos.x=e.clientX-r.left;
    mousePos.y=e.clientY-r.top;
    // Builder move wall with mouse
    if(currentCharacter==='builder' && gameRunning && builderMoveMode && builderSelectedWall) {
        builderSelectedWall.x = mousePos.x - builderSelectedWall.w/2;
        builderSelectedWall.y = mousePos.y - builderSelectedWall.h/2;
    }
});

// Pyromancer charge shot ‚Äî hold to charge, release to fire
canvas.addEventListener('mousedown',e=>{
    // Builder wall move
    if(currentCharacter==='builder' && gameRunning && builderMoveMode) {
        const r = canvas.getBoundingClientRect();
        const mx = e.clientX - r.left;
        const my = e.clientY - r.top;
        // Find wall at mouse position
        for(let w of builderWalls) {
            if(mx >= w.x && mx <= w.x + w.w && my >= w.y && my <= w.y + w.h) {
                builderSelectedWall = w;
                break;
            }
        }
        return;
    }
    // Builder build wall (Shift+Click)
    if(currentCharacter==='builder' && gameRunning && e.shiftKey) {
        if(builderWalls.length >= 8) {
            floatMoneyText('üèóÔ∏è Max 8 walls!');
            return;
        }
        const r = canvas.getBoundingClientRect();
        const mx = e.clientX - r.left;
        const my = e.clientY - r.top;
        builderWalls.push({ x: mx-20, y: my-20, w: 40, h: 40, hp: 50, maxHp: 50, reinforced: false });
        floatMoneyText('üèóÔ∏è Wall built!');
        for(let i=0;i<20;i++) particles.push(new Particle(mx, my, '#d2691e'));
        return;
    }
    if(currentCharacter==='pyromancer'&&gameRunning){pyroCharging=true;pyroChargeTimer=0;}
    else if(currentCharacter!=='boxer'&&gameRunning) shootProjectile(currentCharacter==='admin');
});
canvas.addEventListener('mouseup',e=>{
    builderSelectedWall = null;
    if(currentCharacter==='pyromancer'&&gameRunning&&pyroCharging){
        pyroCharging=false;
        const pct=Math.min(pyroChargeTimer/180,1);
        const angle=Math.atan2(mousePos.y-player.y,mousePos.x-player.x);
        const dmg=applyPassiveDamageBoost(player.damage*(1+pct*4)); // 1x‚Äì5x
        const radius=5+pct*12;
        const sk=CHARACTERS[currentCharacter];
        const p=new Projectile(player.x,player.y,angle,dmg,sk.projColor,false);
        p.radius=radius;
        p.speed=Math.max(5,9-pct*3); // bigger = slower
        p.isFire=true;
        projectiles.push(p);
        for(let i=0;i<Math.round(10+pct*30);i++) particles.push(new Particle(player.x,player.y,'#fb923c'));
        if(pct>0.7) floatMoneyText(`üîÆ ${Math.round(pct*100)}% CHARGED! ${Math.round(dmg)} dmg!`);
    }
});

// Replace old click handler ‚Äî only fires for non-pyromancer
canvas.removeEventListener('click', null);  // clean slate, mousedown handles it now

let boxerAuraLastHit = 0;
let boxerAuraRadius = 120;
let boxerAuraCooldown = 200; // ms between hits

let currentBoss = null;
let bossBullets = [];
let miniTriangles = [];
let bossSpawned = false;
let triangleEnemyUnlocked = false;

let tutorialActive = false;
let tutorialStep = 0;

function showTutorial(){
    document.getElementById('mainMenu').style.display='none';
    document.getElementById('tutorial').style.display='none';
    document.getElementById('gameContainer').style.display='block';
    // Pause gameplay while the tutorial overlay is open
    gameRunning = false;
    startInteractiveTutorial();
}

function startInteractiveTutorial(){
    tutorialActive = true;
    tutorialStep = 0;
    const overlay = document.getElementById('tutorialOverlay');
    overlay.style.display = 'flex';
    applyTutorialStep();
}

function applyTutorialStep(){
    const titleEl = document.getElementById('tutorialTitle');
    const bodyEl = document.getElementById('tutorialBody');
    const hintEl = document.getElementById('tutorialHint');
    const controls = document.getElementById('controls');
    const hud = document.getElementById('hud');

    [controls, hud].forEach(el => { if (el) el.classList.remove('tutorial-highlight'); });

    if (tutorialStep === 0){
        titleEl.textContent = 'Welcome to Ball Survival';
        bodyEl.innerHTML = 'You are the blue ball in the arena. Survive waves of enemies as long as you can. The longer you survive, the stronger enemies become, but you also get stronger!';
        hintEl.textContent = 'Press Next to learn how to move.';
    } else if (tutorialStep === 1){
        titleEl.textContent = 'Movement Controls';
        bodyEl.innerHTML = '<b>WASD</b> or <b>Arrow Keys</b> - Move around the arena<br/>Your character will automatically move in the direction you press. Use this to dodge incoming enemies!';
        hintEl.textContent = 'Try moving around now, then press Next.';
    } else if (tutorialStep === 2){
        titleEl.textContent = 'Aiming & Shooting';
        bodyEl.innerHTML = '<b>Mouse Movement</b> - Aim toward any direction<br/><b>Left Click</b> - Fire projectiles (or auto-attack)<br/>Your projectiles deal damage to enemies and help you clear waves faster!';
        hintEl.textContent = 'Move your mouse and press Next when ready.';
    } else if (tutorialStep === 3){
        titleEl.textContent = 'Dash Mechanic';
        bodyEl.innerHTML = '<b>SPACE</b> - Dash toward your mouse position<br/>Dash quickly moves you out of danger with a short cooldown. Use it to escape from enemy groups or to reposition for better angles.';
        if (hud) hud.classList.add('tutorial-highlight');
        hintEl.textContent = 'Try dashing a few times to understand the mechanic.';
    } else if (tutorialStep === 4){
        titleEl.textContent = 'Special Abilities';
        bodyEl.innerHTML = '<b>R Key</b> - Activate your character\'s special ability<br/>Each character has a unique ability with a cooldown. The ability name is shown on the HUD when ready. Press R to unleash powerful effects!';
        hintEl.textContent = 'Watch for the R cooldown indicator in the HUD.';
    } else if (tutorialStep === 5){
        titleEl.textContent = 'Enemy Types';
        bodyEl.innerHTML = '<b>Red Circles</b> (Speed 2-3) - Basic enemies, easy to handle<br/><b>Purple Triangles</b> (Speed 3.5) - Faster, deal more damage<br/><b>Pink Mini-Boss</b> (Spawns every 15 waves) - Much tougher, high health<br/><b>Red Triangle Boss</b> (Spawns every 50 waves) - THE TRIANGLE, extremely dangerous!';
        hintEl.textContent = 'Learn to identify which enemies pose the greatest threat.';
    } else if (tutorialStep === 6){
        titleEl.textContent = 'Leveling & Experience';
        bodyEl.innerHTML = 'Every enemy you kill grants EXP. When your EXP bar fills up, you level up and can choose 2 active abilities or 2 passive upgrades. Stack synergistic upgrades to become powerful!';
        hintEl.textContent = 'Choosing upgrades wisely is key to surviving longer waves!';
    } else if (tutorialStep === 7){
        titleEl.textContent = 'Gold & Wave Shop';
        bodyEl.innerHTML = 'Enemies drop gold when defeated. Between waves (every 5 waves at checkpoints), visit the Wave Shop with <b>E Key</b> to spend gold on powerful permanent upgrades like more health, damage, speed, and armor!';
        hintEl.textContent = 'Save gold for the Wave Shop rather than using abilities you don\'t need.';
    } else if (tutorialStep === 8){
        titleEl.textContent = 'Biome System';
        bodyEl.innerHTML = 'The arena changes to different biomes every 25-75 waves, each with unique effects:<br/>üå≤ <b>Forest</b> - Normal<br/>‚ùÑÔ∏è <b>Blizzard</b> - -50% speed<br/>üî• <b>Lava Fields</b> - +30% damage<br/>‚ö° <b>Storm</b> - +20% damage & speed<br/>üåô <b>Twilight</b> - +30% attack speed<br/>üåä <b>Flooded</b> - -15% damage, -30% speed';
        hintEl.textContent = 'Study biome bonuses to adjust your strategy!';
    } else if (tutorialStep === 9){
        titleEl.textContent = 'Stats Display (TAB Key)';
        bodyEl.innerHTML = 'Press <b>TAB</b> during gameplay to open your stats panel showing:<br/>‚Ä¢ Current Health & Max Health<br/>‚Ä¢ Total Damage (with biome bonus)<br/>‚Ä¢ Movement Speed (with biome bonus)<br/>‚Ä¢ Level, Kills, Wave Count<br/>‚Ä¢ Armor Percentage & Lifesteal Percentage';
        hintEl.textContent = 'Use TAB to monitor your progression and build effectiveness!';
    } else if (tutorialStep === 10){
        titleEl.textContent = 'Character Selection';
        bodyEl.innerHTML = 'Visit the Character Shop to unlock 18 unique characters, each with different starting stats, special abilities, and playstyles. <b>Toji Fushiguro</b> is a limited-time character that expires on Feb 28, 2026 at 12 PM CST with a weapon-swap ability!';
        hintEl.textContent = 'Different characters excel at different strategies!';
    } else if (tutorialStep === 11){
        titleEl.textContent = 'Game Pause & Settings';
        bodyEl.innerHTML = 'Press <b>ESC</b> or <b>P</b> during gameplay to pause and access settings. You can adjust volume, toggle graphics effects, and return to the main menu anytime.';
        hintEl.textContent = 'Take breaks whenever you need!';
    } else if (tutorialStep === 12){
        titleEl.textContent = 'Survival Tips';
        bodyEl.innerHTML = '<b>Dodge Patterns:</b> Circle enemies move in straight lines, triangles are faster<br/><b>Manage Gold:</b> Invest in health & armor early, then damage<br/><b>Use Abilities:</b> Time your R ability when surrounded<br/><b>Wave Milestones:</b> Bosses appear every 50 waves, mini-bosses every 15<br/><b>Biome Advantage:</b> Capitalize on biome bonuses for your current stats!';
        hintEl.textContent = 'Apply these strategies to beat your high score!';
    } else {
        endTutorial();
    }
}

function nextTutorialStep(){
    if (!tutorialActive) return;
    tutorialStep++;
    applyTutorialStep();
}

function skipTutorial(){
    endTutorial();
}

function endTutorial(){
    tutorialActive = false;
    const overlay = document.getElementById('tutorialOverlay');
    if (overlay) overlay.style.display = 'none';
    // Start a fresh run after tutorial so the player can immediately play
    document.getElementById('gameContainer').style.display='block';
    if (!gameRunning) {
        gameRunning = true;
        resetGame();
        requestAnimationFrame(gameLoop);
    }
}
function closeCharInfo() {
    document.getElementById('infoModal').classList.remove('open');
}

const CHAR_INFO = {
    phantom: {
        name: 'Phantom', tag: '$250 ¬∑ Wall Phaser', icon: 'üëª',
        iconBg: 'linear-gradient(135deg,#0ea5e9,#1e1b4b)', iconGlow: '#7dd3fc',
        stats: [{ label: 'Damage', value: '22 (1.1x base)' },{ label: 'Projectiles', value: 'Pierce through walls' },{ label: 'Phase Bonus', value: '+50% damage while phasing' },{ label: 'Mana Cost', value: '20 mana' },{ label: 'Cooldown', value: '3 seconds' }],
        abilities: `<b>Passive ‚Äî Ethereal Shots:</b> All projectiles pass directly through walls and terrain, opening unique attack angles.<br><br><b>R ‚Äî Ghost Walk (20 mana, 180 frame CD):</b> Phase through walls for 4 seconds (240 frames), gain massive speed boost (1.8x), become temporarily invulnerable, and deal +50% bonus damage on all hits while phasing.`,
        playstyle: 'Excels at hitting enemies through walls before they can reach you. Position behind cover and fire freely, then Ghost Walk to reposition and burst.',
        tip: 'üí° Tip: Fire from inside or behind walls ‚Äî enemies must navigate around while you shoot through. Ghost Walk lets you escape surrounded situations instantly.',
    },
    druid: {
        name: 'Druid', tag: '$750 ¬∑ Root & Heal', icon: 'üåø',
        iconBg: 'linear-gradient(135deg,#15803d,#052e16)', iconGlow: '#4ade80',
        stats: [{ label: 'Damage', value: '20 (standard)' },{ label: 'Root Duration', value: '1.5 seconds (90 frames)' },{ label: 'Mushroom Heal', value: '~3 HP/sec in zone' },{ label: 'Mushroom Zone', value: '55px radius, 8 seconds' },{ label: 'Mana Cost', value: '35 mana' }],
        abilities: `<b>Passive ‚Äî Vine Shots:</b> Every projectile roots hit enemies in place for 1.5 seconds, making them stationary targets.<br><br><b>R ‚Äî Heal Mushrooms (35 mana):</b> Spawns 5 healing mushrooms in a ring around you. Stand inside any mushroom's radius to slowly regenerate HP (~3 HP per second). Each lasts 8 seconds.`,
        playstyle: 'Control + sustain. Root groups of enemies to create stationary targets, position mushrooms as a safe healing zone in a corner.',
        tip: 'üí° Tip: Drop mushrooms in a corner before a big wave hits, then root enemies as they approach and retreat to heal between engagements.',
    },
    pyromancer: {
        name: 'Pyromancer', tag: '$1500 ¬∑ Charge Blaster', icon: 'üîÆ',
        iconBg: 'linear-gradient(135deg,#c2410c,#431407)', iconGlow: '#fb923c',
        stats: [{ label: 'Damage', value: '10‚Äì50 (1x‚Äì5x based on charge)' },{ label: 'Charge Time', value: 'Up to 3 seconds max' },{ label: 'Shot Size', value: 'Grows with charge level' },{ label: 'Meteor DMG', value: '160 (8x base), 120px AoE' },{ label: 'Mana Cost', value: '45 mana' }],
        abilities: `<b>Active ‚Äî Charge Shot:</b> Hold the mouse button to charge (max 3s = 100%). Release to fire. Fully charged: 5x damage, massive radius, fire patches.<br><br><b>R ‚Äî Meteor Strike (45 mana):</b> After 0.8s telegraph, a meteor crashes at cursor dealing 8x damage in 120px radius AoE.`,
        playstyle: 'Sniper/burst damage. Charge shots against clusters, drop Meteor on bosses and elite groups.',
        tip: 'üí° Tip: Meteor shows a warning ring before impact ‚Äî aim at rooted or slow enemies. Combine with root passives from the wave shop for guaranteed hits.',
    },
    cyborg: {
        name: 'Cyborg', tag: '$3000 ¬∑ Dual Mode', icon: 'ü§ñ',
        iconBg: 'linear-gradient(135deg,#0ea5e9,#4c1d95)', iconGlow: '#38bdf8',
        stats: [{ label: 'Rapid Mode DMG', value: '13 (65%) ¬∑ 110ms fire rate' },{ label: 'Heavy Mode DMG', value: '56 (2.8x) ¬∑ 550ms fire rate' },{ label: 'Mode Toggle', value: 'E key ‚Äî instant switch' },{ label: 'Laser Sweep DMG', value: '3.5x total over 360¬∞' },{ label: 'Price', value: '$3000' }],
        abilities: `<b>Passive ‚Äî Dual Mode (E key toggle):</b><br>‚Ä¢ <span style="color:#38bdf8">RAPID:</span> Ultra-fast weak shots (110ms), slight spread.<br>‚Ä¢ <span style="color:#c084fc">HEAVY:</span> Slow massive shots (550ms), 2.8x damage, large hitbox.<br><br><b>R ‚Äî Laser Sweep (30 mana):</b> Spins a 360¬∞ laser over 1.4s, hitting every enemy in its path.`,
        playstyle: 'Adaptive. Rapid for clearing small enemies, Heavy for elites and bosses. Laser Sweep when surrounded.',
        tip: 'üí° Tip: Heavy mode single shots outdamage Rapid against bosses. Learn to swap mid-fight.',
    },
    timewizard: {
        name: 'Time Wizard', tag: '$4500 ¬∑ Echo & Rewind', icon: '‚è≥',
        iconBg: 'linear-gradient(135deg,#7c3aed,#1e1b4b)', iconGlow: '#d8b4fe',
        stats: [{ label: 'Main Shot DMG', value: '20 (standard)' },{ label: 'Echo Shot DMG', value: '12 (60%) after 0.3s delay' },{ label: 'Rewind Snapshot', value: 'Saved every 5 seconds' },{ label: 'Cooldown', value: '5 seconds' },{ label: 'Price', value: '$4500' }],
        abilities: `<b>Passive ‚Äî Time Echo:</b> Every shot fires a ghost echo 0.3s later at the same angle ‚Äî effectively 1.6x DPS output.<br><br><b>R ‚Äî Rewind (60 mana, 5s CD):</b> Restores HP to value from 5 seconds ago. Best used immediately after taking burst damage.`,
        playstyle: 'Sustained pressure ‚Äî every shot is two shots. Save Rewind for emergencies right after big damage spikes.',
        tip: 'üí° Tip: Use Rewind proactively right after taking big damage, not when already near death. Snapshot updates every 5 seconds.',
    },
    default: {
        name: 'The Veteran', tag: 'Free ¬∑ Evolving Fighter', icon: '‚≠ê',
        iconBg: 'linear-gradient(135deg,#3b82f6,#1e3a8a)', iconGlow: '#3b82f6',
        stats: [{ label: 'Damage', value: '20 (scales with tier)' },{ label: 'Speed', value: '5 (+0.5‚Äì2.5 per evolution)' },{ label: 'Mana Cost', value: '20' },{ label: 'Evolution Rate', value: 'Every 30 seconds' },{ label: 'Price', value: 'FREE' }],
        abilities: `<b>Passive ‚Äî Evolution:</b> Every 30 seconds you automatically evolve to the next tier, gaining bonus damage, speed, and a more powerful R ability. There are 5 tiers: Rookie ‚Üí Soldier ‚Üí Elite ‚Üí Commander ‚Üí Legend.<br><br><b>R ‚Äî Adaptive Strike:</b> Changes with each tier.<br>‚Ä¢ <span style="color:#3b82f6">Rookie:</span> 8-shot burst ring (1.0x dmg)<br>‚Ä¢ <span style="color:#22c55e">Soldier:</span> 12-shot volley (1.4x dmg)<br>‚Ä¢ <span style="color:#f97316">Elite:</span> 16-shot nova + area damage (2.0x dmg)<br>‚Ä¢ <span style="color:#a855f7">Commander:</span> 20-shot shockwave + freezes enemies (2.8x dmg)<br>‚Ä¢ <span style="color:#fbbf24">Legend:</span> 32-shot annihilation + kills everything in 350px (4.0x dmg)`,
        playstyle: 'Starts weak but becomes one of the most powerful characters over time. Focus on surviving the early waves, then snowball hard once you hit Elite and Commander.',
        tip: 'üí° Tip: Tier 3+ shots auto-freeze enemies on hit. Tier 4+ also ignites them. Stack speed upgrades on level-up to make the most of the speed bonuses each evolution gives you.',
    },
    goldhoarder: {
        name: 'Gold Hoarder', tag: 'Free ¬∑ Money Specialist', icon: 'ü™ô',
        iconBg: 'linear-gradient(135deg,#ca8a04,#713f12)', iconGlow: '#fbbf24',
        stats: [{ label: 'Damage', value: '15 (strong!)' },{ label: 'Fire Rate', value: 'Slow (700ms)' },{ label: 'Speed', value: '68.75% of normal' },{ label: 'Accuracy', value: '‚ö†Ô∏è Heavy spread' },{ label: 'Gold Mult', value: '6.25x ALL gold' }],
        abilities: `<b>Passive ‚Äî Gold Multiplier:</b> Every source of gold is multiplied by 6.25x (kills, bosses, wave milestones). Increased from original 5x via 25% buff.<br><br><b>R ‚Äî Gold Rush (40 mana):</b> Converts all enemies within 180px into gold coins instantly, giving you coins for free.`,
        playstyle: 'Weak at combat but more viable after the 25% buff. Focus on kiting, surviving, and using Gold Rush when enemies cluster. Extra speed and damage make dodging easier.',
        tip: 'üí° Tip: With the buff, use Gold Rush more aggressively early on. The higher damage helps survive longer between uses. Stack gold bonuses from wave shops to snowball your advantage.',
    },
    vampire: {
        name: 'Vampire', tag: '100 ¬∑ Lifesteal Tank', icon: 'üßõ',
        iconBg: 'linear-gradient(135deg,#7f1d1d,#450a0a)', iconGlow: '#ef4444',
        stats: [{ label: 'Damage', value: '20 (standard)' },{ label: 'Speed', value: '5 (standard)' },{ label: 'Heal on Kill', value: '+8 HP per kill' },{ label: 'Dash Type', value: 'Teleport (instant blink)' },{ label: 'Dash Cooldown', value: '60 frames (1 second)' },{ label: 'Price', value: '$100' }],
        abilities: `<b>Passive ‚Äî Bloodsucker:</b> Every enemy you kill instantly heals you for 8 HP. No resource cost ‚Äî the more you kill, the more you sustain.<br><br><b>Dash ‚Äî Vampire Blink (SPACE, 60 frame CD):</b> Instantly teleports directly to your mouse cursor location. No dash distance limit ‚Äî appears exactly where you aimed. Grants 15 frames of invulnerability on arrival, perfect for repositioning or escaping surrounded situations.<br><br><b>No R ability ‚Äî Focus on raw killing power to maximize heal output.</b>`,
        playstyle: 'Beginner-friendly sustain character. The core loop: kill enemy ‚Üí heal 8 HP ‚Üí stay alive longer ‚Üí kill more ‚Üí spiral into dominance. The teleport dash is your primary mobility and escape tool. Stack Lifesteal passives from the wave shop for insane healing (up to +5 HP per stack).',
        tip: 'üí° Tip: Teleport dash is on a 1-second cooldown, so you can chain them for rapid repositioning. Combine with Lifesteal passives: at 3 stacks you heal 23 HP per kill, essentially negating all small enemy damage.',
    },
    builder: {
        name: 'The Builder', tag: 'Free ¬∑ Wall Master', icon: 'üß±',
        iconBg: 'linear-gradient(135deg,#a0522d,#d2691e)', iconGlow: '#d2691e',
        stats: [{ label: 'Damage', value: '20 (standard)' },{ label: 'Speed', value: '5 (standard)' },{ label: 'Wall HP', value: '50 per wall' },{ label: 'Max Walls', value: '8 active' },{ label: 'Price', value: 'FREE' }],
        abilities: `<b>Passive ‚Äî Construction:</b> Walls are permanent obstacles that enemies must navigate around. You can have up to 8 walls active at once.<br><br><b>E ‚Äî Move Walls:</b> Hold E and click on a wall to pick it up and relocate it. Perfect for repositioning your defenses mid-fight.<br><br><b>Shift+Click ‚Äî Build New Walls:</b> Hold Shift and click on the ground to build a new wall at that location (costs no resources).<br><br><b>R ‚Äî Reinforce (30 mana, 2s CD):</b> Strengthens the nearest wall, doubling its durability and making it glow with power.`,
        playstyle: 'Strategic defense. Build walls to funnel enemies into kill zones. Move walls mid-fight to adapt to new threats. Use Reinforce to protect critical walls.',
        tip: 'üí° Tip: Build walls to create corridors, then position yourself to fire down the hallway. Reinforce walls that enemies are attacking repeatedly.',
    },
    boxer: {
        name: 'Boxer', tag: '$500 ¬∑ Melee Rushdown', icon: 'üëä',
        iconBg: 'linear-gradient(135deg,#dc2626,#991b1b)', iconGlow: '#ef4444',
        stats: [{ label: 'Damage', value: '40 (2x)' },{ label: 'Speed', value: '5 (standard)' },{ label: 'Dash Damage', value: 'Hits all enemies in path' },{ label: 'Cooldown', value: '2 seconds per dash' },{ label: 'Price', value: '$500' }],
        abilities: `<b>Passive ‚Äî Close-Range Fighter:</b> Deal 2x normal damage. All projectiles are short-range but devastating at close quarters.<br><br><b>R ‚Äî Power Dash (25 mana, 2s CD):</b> Dash forward in a straight line, damaging every enemy you pass through. The dash itself carries your full damage output.`,
        playstyle: 'Aggressive melee character. Get close, spam shots, and use Power Dash to burst through clusters. You trade defense for raw output.',
        tip: 'üí° Tip: Master the dash range ‚Äî it hits harder than shots but puts you in danger. Dash to escape when surrounded and deal damage simultaneously.',
    },
    fire: {
        name: 'Fire Ball', tag: '$500 ¬∑ Area Control', icon: 'üî•',
        iconBg: 'linear-gradient(135deg,#ff4500,#7f1d1d)', iconGlow: '#ff4500',
        stats: [{ label: 'Damage', value: '10 + burn DoT (40% dmg/tick)' },{ label: 'Mana Cost', value: '25 (Inferno)' },{ label: 'Price', value: '$500' }],
        abilities: `<b>Passive ‚Äî Burning Ground:</b> Every shot leaves a burning patch (50px radius, 3s).<br><br><b>R ‚Äî Inferno (25 mana):</b> Ignites every enemy on screen. Also fires a 16-shot ring of fire projectiles.`,
        playstyle: 'Zone-control. Lay down burn patches on enemy approach paths and force them to walk through fire.',
        tip: 'üí° Tip: Shoot corridors between walls to create fire lanes that enemies must walk through.',
    },
    ice: {
        name: 'Ice Ball', tag: '$1000 ¬∑ Cryo Sniper', icon: '‚ùÑÔ∏è',
        iconBg: 'linear-gradient(135deg,#e0f7ff,#06b6d4)', iconGlow: '#67e8f9',
        stats: [{ label: 'Damage', value: '10 base / 30 on shatter (3x)' },{ label: 'Shot Type', value: 'Piercing' },{ label: 'Freeze Duration', value: '1.5 seconds per hit' },{ label: 'Shatter Bonus', value: '3x damage on frozen enemies' },{ label: 'Mana Cost', value: '30 mana' }],
        abilities: `<b>Passive ‚Äî Piercing Cryo Shots:</b> Projectiles pass through enemies and freeze each hit for 1.5s.<br><br><b>Passive ‚Äî Shatter:</b> Shooting a frozen enemy deals 3x damage and is the key to burst potential.<br><br><b>R ‚Äî Blizzard (30 mana):</b> Freezes all enemies within 350px and drops a blizzard zone that reapplies freeze.`,
        playstyle: 'High skill ceiling. Managing freeze‚Üíshatter combos is key to maximizing damage.',
        tip: 'üí° Tip: Use Blizzard to freeze a group, then walk through them triggering shatter combos. Pair with root/slow shop passives.',
    },
    electric: {
        name: 'Tesla', tag: '$2500 ¬∑ Chain Lightning', icon: '‚ö°',
        iconBg: 'linear-gradient(135deg,#facc15,#7c3aed)', iconGlow: '#a855f7',
        stats: [{ label: 'Damage', value: '10 base / 7 per chain target (70%)' },{ label: 'Chains', value: '3 nearby enemies per shot' },{ label: 'Price', value: '$2500' }],
        abilities: `<b>Passive ‚Äî Auto-Chain:</b> Every shot chains lightning to up to 3 nearby enemies.<br><br><b>R ‚Äî Overload (35 mana):</b> 8 charges ‚Äî next 8 shots chain to EVERY enemy on screen.`,
        playstyle: 'Scales with enemy density. Save Overload for the peak of a wave when the screen is full.',
        tip: 'üí° Tip: Position yourself to hit the enemy closest to the largest cluster.',
    },
    wemmbu: {
        name: 'Wemmbu', tag: '$5000 ¬∑ Berserker', icon: 'üí¢',
        iconBg: 'linear-gradient(135deg,#a855f7,#4c1d95)', iconGlow: '#a855f7',
        stats: [{ label: 'Slam Range', value: '280px ‚Äî instant kill' },{ label: 'Cooldown', value: '3 seconds' },{ label: 'Price', value: '$5000' }],
        abilities: `<b>R ‚Äî Ground Slam (35 mana, 3s CD):</b> Instantly kills every enemy within 280px. Each kill triggers full kill effects.`,
        playstyle: 'Bursty mob-clearer. Normal shooting between slams, then slam to erase full waves.',
        tip: 'üí° Tip: The slam range (280px) is larger than it looks. Stack mana upgrades.',
    },
    eggchan: {
        name: 'Eggchan', tag: '$5000 ¬∑ Spam Archer', icon: 'üèπ',
        iconBg: 'linear-gradient(135deg,#f9a8d4,#db2777)', iconGlow: '#ec4899',
        stats: [{ label: 'Damage', value: '10 base / 20 on bow shots (2x)' },{ label: 'Mana Cost', value: '1 per arrow (spammable!)' },{ label: 'Arrow Speed', value: 'Fast (18px/frame)' },{ label: 'Fire Rate', value: 'Auto-fire + R spam' },{ label: 'Price', value: '$5000' }],
        abilities: `<b>R ‚Äî Bow Shot (1 mana):</b> Fires a fast arrow dealing 2x damage. Spammable at only 1 mana cost ‚Äî at 100 max mana you can fire 100 arrows.`,
        playstyle: 'Spam-focused character. Press R constantly while normal shots auto-fire. The goal is constant output.',
        tip: 'üí° Tip: With 100 mana you can fire 100 arrows. Grab Mana Flow and Max Mana upgrades to maximize your spam potential.',
    },
    dream: {
        name: 'Dream', tag: '$5000 ¬∑ Kill-Scaling Tank', icon: 'üåø',
        iconBg: 'linear-gradient(135deg,#22c55e,#14532d)', iconGlow: '#22c55e',
        stats: [{ label: 'Armor', value: 'Scales with kills ‚Äî up to 80% reduction' },{ label: 'Dash', value: 'Teleport to mouse' },{ label: 'Price', value: '$5000' }],
        abilities: `<b>Passive ‚Äî Dream Armor:</b> Armor scales with kill count. Tiers from No Armor ‚Üí Leather ‚Üí Chainmail ‚Üí Iron ‚Üí Diamond ‚Üí Netherite ‚Üí Netherite Prot IV.<br><br><b>No R ability</b>`,
        playstyle: 'Gets dramatically stronger the more you play. Also has the vampire teleport dash.',
        tip: 'üí° Tip: Check the armor bar in the HUD to see how close you are to the next tier.',
    },
    technoblade: {
        name: 'Technoblade', tag: '$50000 ¬∑ God of Combat', icon: 'üëë',
        iconBg: 'linear-gradient(135deg,#7c3aed,#4c1d95)', iconGlow: '#a855f7',
        stats: [{ label: 'Max Mana', value: '200 (doubled)' },{ label: 'Armor', value: 'Same as Dream (kill-scaling)' },{ label: 'Blood God DMG', value: 'Instant kill ALL' },{ label: 'Mana Cost', value: '150 mana' },{ label: 'Price', value: '$50,000' }],
        abilities: `<b>Passive ‚Äî Dream Armor:</b> Identical to Dream's passive armor system. Scales with kill count up to 80% reduction.<br><br><b>R ‚Äî Blood for the Blood God (150 mana):</b> Instantly kills EVERY enemy on screen. Full crowd-clear ability.`,
        playstyle: 'Ultimate power fantasy. Doubled mana pool, screen-clearing genocide button, and Dream\'s armor passive.',
        tip: 'üí° Tip: Grab Mana Flow passives from the wave shop to speed up regen between Blood God uses. At 200 max mana, you can nearly chain them.',
    },
    admin: {
        name: 'THE ADMIN', tag: '$1,000,000,000 ¬∑ Absolute Power', icon: 'üëë',
        iconBg: 'linear-gradient(135deg,#7c3aed,#000)', iconGlow: '#ffffff',
        stats: [{ label: 'Health', value: '500 (5x normal)' },{ label: 'Mana', value: '9999 (unlimited)' },{ label: 'Damage', value: '100 (5x normal)' },{ label: 'Speed', value: '7 (fastest)' },{ label: 'Price', value: '$1,000,000,000' }],
        abilities: `<b>All 9 Godlike Abilities (Press 1-9):</b><br>1Ô∏è‚É£ BURST ‚Äî 12-shot ring<br>2Ô∏è‚É£ EXPLOSION ‚Äî 16-shot + area nuke<br>3Ô∏è‚É£ FREEZE ‚Äî Instant freeze all<br>4Ô∏è‚É£ CHAIN ‚ö° ‚Äî Instant electrocute all<br>5Ô∏è‚É£ SLAM ‚Äî Instant kill 350px radius<br>6Ô∏è‚É£ BOW ‚Äî 5 rapid arrows<br>7Ô∏è‚É£ BLOOD GOD ‚Äî Instant kill ALL<br>8Ô∏è‚É£ NUKE ‚Äî Kill all + full heal<br>9Ô∏è‚É£ TELEPORT ‚Äî Blink to mouse<br><br>All passives active. Vampire lifesteal. Dream armor. Auto-fire.`,
        playstyle: 'Cheat character. 9 god-tier abilities, 5x stats, unlimited mana, all passives. There is no challenge ‚Äî that\'s the point.',
        tip: 'üí∞ You need $1,000,000,000 to unlock this. Play Gold Hoarder for a very long time.',
    },
    dice: {
        name: 'Dice', tag: '$2345 ¬∑ Gambler\'s Paradise', icon: 'üé≤',
        iconBg: 'linear-gradient(135deg,#f97316,#ea580c)', iconGlow: '#fbbf24',
        stats: [{ label: 'Damage', value: '10‚Äì150 (randomized per shot)' },{ label: 'Speed', value: '3‚Äì8 (randomized at start)' },{ label: 'Health', value: '80‚Äì175 (randomized at start)' },{ label: 'Mana Cost', value: '1‚Äìmax mana (random)' },{ label: 'Cooldown', value: '1‚Äì120 frames (random)' },{ label: 'Price', value: '$2345' }],
        abilities: `<b>Passive ‚Äî Chaos Shots:</b> Every projectile deals random damage between 10‚Äì150. Your speed and max HP are randomized at the start of each run (3‚Äì8 speed, 80‚Äì175 max health).<br><br><b>R ‚Äî Random Special (Random mana/CD):</b> Activates a random ability guaranteed to work standalone. Each use costs random mana (1 to max) with random cooldown (1‚Äì120 frames). Possible abilities: Mushrooms, Meteor, Laser Sweep, Inferno, Dash Punch, Blizzard, Overload, Ground Slam, Blood God, or Veteran Burst. Never rolls abilities that need special character setups.`,
        playstyle: 'Pure randomness. Every run is completely different ‚Äî even your stats start random. Every R press is a mystery: different mana cost, different cooldown, different ability. Adapt or die trying.',
        tip: 'üé≤ Tip: The ability pool is carefully balanced ‚Äî you\'ll never get stuck with a useless ability. But mana/cooldown? That\'s the real gamble.',
    },
    hakari_v2: {
        name: 'Hakari', tag: 'LIMITED ¬∑ Domain Master', icon: 'üé∞',
        iconBg: 'linear-gradient(135deg,#ec4899,#7c3aed)', iconGlow: '#ec4899',
        stats: [{ label: 'Damage', value: '20 (standard)' },{ label: 'Domain Duration', value: '60 seconds' },{ label: 'Domain Size', value: '200px safe zone (enemies can\'t enter)' },{ label: 'Jackpot Immortality', value: '4 min 11 sec (one-shot everything)' },{ label: 'Jackpot Chance', value: '10% per roll (FIXED)' },{ label: 'Jackpot Cooldown', value: '20 seconds after jackpot' }],
        abilities: `<b>R ‚Äî Domain Expansion (0 mana, no cooldown):</b> Creates a sacred domain around you for 60 seconds. Within the domain, you are completely safe ‚Äî no enemies can enter. Waves automatically pause while in the domain. Cannot be activated during jackpot immortality.<br><br><b>Automatic Rolling:</b> Once in the domain, you begin rolling every second. Each roll has a FIXED 10% chance of landing a JACKPOT (no pity system ‚Äî pure luck every time).<br><br><b>Jackpot Effect:</b> Hit a jackpot within the 60-second window to unlock 4 minutes and 11 seconds of IMMORTALITY. During this time, all your projectiles deal 50x damage (one-shot everything) and you are invulnerable. After jackpot ends, Domain Expansion has a 20-second cooldown before you can pop it again.`,
        playstyle: 'High-risk gambling with no pity safety net. Use Domain Expansion strategically when surrounded or at low health. Each roll is a 10/100 lottery ‚Äî some runs you hit immediately, others you never hit. If you don\'t hit jackpot within 60 seconds, you exit and must survive normally.',
        tip: 'üé∞ Tip: The 10% roll makes it even more unpredictable than before. Pure luck means sometimes you hit on roll 1, sometimes never. Use domains when you can afford to lose time if you don\'t hit. After hitting jackpot, you\'ll have a 20-second vulnerability window before you can pop domain again.',
    },
    yuji_itadori: {
        name: 'Yuji Itadori', tag: 'LIMITED ¬∑ Cursed Spirit Host', icon: 'ü©∏',
        iconBg: 'linear-gradient(135deg,#e84d4d,#7f1d1d)', iconGlow: '#e84d4d',
        stats: [{ label: 'Damage', value: '20 (standard)' },{ label: 'Sukuna Fingers', value: 'Collect from enemies (5% drop)' },{ label: 'Transformation', value: 'At 20 fingers ‚Üí Becomes Sukuna' },{ label: 'Shrine Cooldown', value: '5 seconds' },{ label: 'Price', value: 'LIMITED ($28,000)' }],
        abilities: `<b>Passive ‚Äî Sukuna Finger Collection:</b> Enemies have a 5% chance to drop Sukuna Fingers when killed. Collect 20 fingers to transform into Sukuna permanently.<br><br><b>R ‚Äî Cursed Slash (Yuji Form, 0 mana):</b> Fires an 8-shot projectile ring of cursed slashes.<br><br><b>R ‚Äî Malevolent Shrine (Sukuna Form, 0 mana, 5s CD):</b> Activate a continuous damage aura that deals 5% of each enemy's max health per second for 3 seconds. Can only be activated once every 5 seconds.`,
        playstyle: 'Scaling character with a transformation mechanic. Early game: focus on collecting fingers while surviving. At 20 fingers: transform into Sukuna and gain a sustained damage ability with strategic cooldown management.',
        tip: 'Tip: With only a 5% drop rate, expect to farm for ~400 kills to collect 20 fingers. Once you transform, use Malevolent Shrine strategically on high-health enemy groups. The 5% health damage scales with enemy toughness, making it effective against bosses.',
    },
    toji: {
        name: 'Toji Fushiguro', tag: 'LIMITED ¬∑ Tool Master', icon: 'ü™µ',
        iconBg: 'linear-gradient(135deg,#6b4423,#3d2817)', iconGlow: '#f59e0b',
        stats: [{ label: 'Damage', value: '20 (standard)' },{ label: 'Tool Swap Cooldown', value: '2 seconds' },{ label: 'Damage Bonus', value: '+30% while active' },{ label: 'Speed Bonus', value: '+20% while active' },{ label: 'Price', value: 'LIMITED ($20,000)' }],
        abilities: `<b>Passive ‚Äî Cursed Tool Mastery:</b> No cursed energy = pure combat skill. Gain +10% damage and +5% attack speed permanently.<br><br><b>R ‚Äî Tool Swap (40 mana, 2s CD):</b> Swap between Sharp (maximum damage) and Heavy (stun) weapon modes. Sharp mode: +30% damage for 3 seconds. Heavy mode: +20% damage + slow enemies by 50% for 2 seconds. Choose your strategy mid-fight.`,
        playstyle: 'Adaptable warrior. Switch between aggressive damage bursts and defensive slow modes depending on the situation. High mobility and raw combat prowess with no reliance on cursed techniques.',
        tip: 'üí° Tip: Use Sharp mode for high-priority targets. Use Heavy mode when surrounded to create breathing room. The tool swap cooldown is short (2 seconds) allowing frequent strategy switches during combat.',
    },
};

function showCharInfo(skin) {
    const info = CHAR_INFO[skin];
    if (!info) return;
    const modal = document.getElementById('infoModal');
    const icon = document.getElementById('infoIcon');
    icon.textContent = info.icon;
    icon.style.background = info.iconBg;
    icon.style.boxShadow = `0 0 20px ${info.iconGlow}`;
    document.getElementById('infoName').textContent = info.name;
    document.getElementById('infoName').style.color = info.iconGlow;
    document.getElementById('infoTag').textContent = info.tag;
    const statsEl = document.getElementById('infoStats');
    statsEl.innerHTML = info.stats.map(s =>
        `<div class="info-row"><span class="label">${s.label}</span><span class="value" style="color:${info.iconGlow}">${s.value}</span></div>`
    ).join('');
    document.getElementById('infoAbilities').innerHTML = info.abilities;
    document.getElementById('infoPlaystyle').innerHTML = info.playstyle;
    document.getElementById('infoTip').innerHTML = info.tip;
    document.getElementById('infoBox').style.borderColor = info.iconGlow + '55';
    document.getElementById('infoBox').style.boxShadow = `0 0 60px ${info.iconGlow}22, 0 0 120px rgba(0,0,0,0.9)`;
    modal.classList.add('open');
}

function showCharacterShop(){document.getElementById('mainMenu').style.display='none';document.getElementById('characterShop').style.display='block';updateShopDisplay();}
function backToMenu(){document.getElementById('tutorial').style.display='none';document.getElementById('characterShop').style.display='none';document.getElementById('moneyPopup').classList.remove('show');document.getElementById('mainMenu').style.display='block';updateMoneyDisplay();}
function startGame(){
    document.getElementById('mainMenu').style.display='none';
    document.getElementById('gameContainer').style.display='block';
    gameRunning=true;
    resetGame();
    updateBiome();
    updateBiomeColors();
    showBiomeIndicator();
    requestAnimationFrame(gameLoop);
}
function backToMainMenu(){document.getElementById('gameOver').style.display='none';document.getElementById('gameContainer').style.display='none';skinOverlay.style.display='none';document.getElementById('mainMenu').style.display='block';updateMoneyDisplay();}
function updateMoneyDisplay(){document.getElementById('totalMoney').textContent=totalMoney;document.getElementById('shopMoney').textContent=totalMoney;}
function updateShopDisplay(){
    updateMoneyDisplay();
    document.querySelectorAll('.character-card').forEach(c=>c.classList.remove('selected'));
    const idx=CHARACTER_ORDER.indexOf(currentCharacter);if(idx>=0)document.querySelectorAll('.character-card')[idx].classList.add('selected');
    ['phantom','druid','pyromancer','cyborg','timewizard','fire','ice','electric','boxer','wemmbu','eggchan','dream','technoblade','admin','dice','hakari_v2','yuji_itadori','toji'].forEach(s=>{const el=document.getElementById(s+'Character');if(el){if(!unlockedCharacters.includes(s))el.classList.add('locked');else el.classList.remove('locked');}});
}
function updateMcSkinClass(){
    if(['wemmbu','eggchan','dream','technoblade'].includes(currentCharacter))document.body.classList.add('mc-skin');
    else document.body.classList.remove('mc-skin');
}
function selectCharacter(name){
    // Check if limited character is expired
    if (LIMITED_CHARACTERS.includes(name)) {
        const limitDate = LIMITED_EXPIRY[name];
        const now = new Date();
        if (now >= limitDate) {
            alert(`‚è±Ô∏è This character is no longer available!`);
            return;
        }
    }
    
    if(!unlockedCharacters.includes(name)){
        const price = PRICES[name];
        if(totalMoney >= price) {
            // Show confirmation dialog for purchase
            const charInfo = CHAR_INFO[name];
            const charName = charInfo ? charInfo.name : name;
            if(confirm(`Purchase ${charName} for $${price}?\n\nYour balance: $${totalMoney}`)) {
                totalMoney -= price;
                unlockedCharacters.push(name);
                currentCharacter = name;
                savePersistentData();
                updateShopDisplay();
                floatMoneyText(`‚ú® Unlocked: ${charName}!`);
            }
        } else {
            alert(`Not enough money!\n\nNeed: $${price}\nYou have: $${totalMoney}`);
        }
    } else {
        currentCharacter = name;
        savePersistentData();
        updateShopDisplay();
    }
    updateMcSkinClass();
}
function savePersistentData(){
    localStorage.setItem('ballRPGMoney',totalMoney);
    localStorage.setItem('ballRPGCharacters',JSON.stringify(unlockedCharacters));
    localStorage.setItem('ballRPGCurrentCharacter',currentCharacter);
    localStorage.setItem('ballRPGUsedCodes',JSON.stringify(usedCodes));
}

function resetAllProgress(){
    if(confirm('Are you sure you want to reset ALL progress? This cannot be undone!')){
        localStorage.clear();
        totalMoney = 0;
        unlockedCharacters = ['default', 'goldhoarder'];
        currentCharacter = 'default';
        usedCodes = [];
        savePersistentData();
        updateMoneyDisplay();
        updateShopDisplay();
        updateMcSkinClass();
        alert('Progress reset! The page will reload.');
        location.reload();
    }
}

const CODES = {
    '/give @s all': { reward: 'allclaims', amount: 50000, message: 'üéÅ COMMAND EXECUTED: All characters & $50,000 unlocked!' }
};

let usedCodes = JSON.parse(localStorage.getItem('ballRPGUsedCodes')) || [];

function submitCode() {
    const codeInput = document.getElementById('codeInput');
    const code = codeInput.value.toLowerCase().trim();
    
    if (!code) {
        alert('Please enter a code!');
        return;
    }
    
    if (!CODES[code]) {
        alert('Invalid code!');
        codeInput.value = '';
        return;
    }
    
    // Check if code has already been used
    if (usedCodes.includes(code)) {
        alert('You already used this code!');
        codeInput.value = '';
        return;
    }
    
    const codeData = CODES[code];
    
    if (codeData.reward === 'money') {
        totalMoney += codeData.amount;
        usedCodes.push(code);
        savePersistentData();
        updateMoneyDisplay();
        floatMoneyText(codeData.message);
        alert(codeData.message);
    } else if (codeData.reward === 'character') {
        if (!unlockedCharacters.includes(codeData.character)) {
            unlockedCharacters.push(codeData.character);
            usedCodes.push(code);
            savePersistentData();
            alert(codeData.message);
        } else {
            alert('You already have this character!');
        }
    } else if (codeData.reward === 'allcharacters') {
        const allChars = Object.keys(CHARACTERS);
        let newCharsAdded = 0;
        allChars.forEach(char => {
            if (!unlockedCharacters.includes(char)) {
                unlockedCharacters.push(char);
                newCharsAdded++;
            }
        });
        if (newCharsAdded > 0) {
            usedCodes.push(code);
            savePersistentData();
            alert('üéâ All characters unlocked!');
        } else {
            alert('You already have all characters!');
        }
    } else if (codeData.reward === 'combo') {
        totalMoney += 10000;
        if (!unlockedCharacters.includes('hakari_v2')) unlockedCharacters.push('hakari_v2');
        if (!unlockedCharacters.includes('yuji_itadori')) unlockedCharacters.push('yuji_itadori');
        usedCodes.push(code);
        savePersistentData();
        updateMoneyDisplay();
        floatMoneyText(codeData.message);
        alert('‚ú® Claimed: Hakari + Yuji Itadori + $10,000!');
    } else if (codeData.reward === 'allclaims') {
        totalMoney += codeData.amount;
        const allChars = Object.keys(CHARACTERS);
        let newCharsAdded = 0;
        allChars.forEach(char => {
            if (!unlockedCharacters.includes(char)) {
                unlockedCharacters.push(char);
                newCharsAdded++;
            }
        });
        usedCodes.push(code);
        savePersistentData();
        updateMoneyDisplay();
        floatMoneyText(codeData.message);
        alert(codeData.message);
    }
    
    codeInput.value = '';
}

// Allow Enter key to submit code
document.addEventListener('DOMContentLoaded', () => {
    const codeInput = document.getElementById('codeInput');
    if (codeInput) {
        codeInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') submitCode();
        });
    }
});

document.addEventListener('DOMContentLoaded', () => {
    loadSettings();
    updateMoneyDisplay();
    updateMcSkinClass();
    document.getElementById('mainMenu').style.display = 'block';
});


</script>
</body>
</html>
